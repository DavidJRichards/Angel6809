
6502/65C02 Turbo Assembler listing file of "sbc.asm"
done on Thu Nov 14 14:46:55 2024


>8002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8aa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8af2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8be2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8da2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8db2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8dc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8dd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8de2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8df2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8eb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9aa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9af2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9be2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9da2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9db2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9dc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9dd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9de2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9df2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9eb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aaa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aaf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ace2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ada2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>add2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ade2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aeb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>baa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>baf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>beb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>caa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>caf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ceb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ced2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>daa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>daf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>deb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ded2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>def2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eaa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ead2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eaf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ece2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ede2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eeb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>faa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>faf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>feb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff        .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff  ;
.9000                              lab_cold

.9000  a0 04      ldy #$04         	LDY	#PG2_TABE-PG2_TABS-1
.9002                              lab_2d13
.9002  b9 f6 b0   lda $b0f6,y      	LDA	PG2_TABS,Y		; get byte
.9005  99 00 02   sta $0200,y      	STA	ccflag,Y		; store in page 2
.9008  88         dey              	DEY				; decrement count
.9009  10 f7      bpl $9002        	BPL	LAB_2D13		; loop if not done
.900b  a2 ff      ldx #$ff         	LDX	#$FF			; set byte
.900d  86 88      stx $88          	STX	Clineh		; set current line high byte (set immediate mode)
.900f  9a         txs              	TXS				; reset stack pointer
.9010  a9 4c      lda #$4c         	LDA	#$4C			; code for JMP
.9012  85 a1      sta $a1          	STA	Fnxjmp		; save for jump vector for functions
.9014  a2 1c      ldx #$1c         	LDX	#StrTab-LAB_2CEE	; set byte count
.9016                              lab_2d4e
.9016  bd fa b0   lda $b0fa,x      	LDA	LAB_2CEE-1,X	; get byte from table
.9019  95 bb      sta $bb,x        	STA	LAB_IGBY-1,X	; save byte in page zero
.901b  ca         dex              	DEX				; decrement count
.901c  d0 f8      bne $9016        	BNE	LAB_2D4E		; loop if not all done
.901e                              lab_gmem
.901e  a2 12      ldx #$12         	LDX	#EndTab-StrTab-1	; set byte count-1
.9020                              tabloop
.9020  bd 17 b1   lda $b117,x      	LDA	StrTab,X		; get byte from table
.9023  95 00      sta $00,x        	STA	PLUS_0,X		; save byte in page zero
.9025  ca         dex              	DEX				; decrement count
.9026  10 f8      bpl $9020        	BPL	TabLoop		; loop if not all done
.9028  a9 00      lda #$00         	LDA	#$00			; clear A
.902a  85 dc      sta $dc          	STA	NmiBase		; clear NMI handler enabled flag
.902c  85 df      sta $df          	STA	IrqBase		; clear IRQ handler enabled flag
.902e  85 b2      sta $b2          	STA	FAC1_o		; clear FAC1 overflow byte
.9030  85 67      sta $67          	STA	last_sh		; clear descriptor stack top item pointer high byte
.9032  a9 0e      lda #$0e         	LDA	#$0E			; set default tab size
.9034  85 64      sta $64          	STA	TabSiz		; save it
.9036  a9 03      lda #$03         	LDA	#$03			; set garbage collect step size for descriptor stack
.9038  85 a0      sta $a0          	STA	g_step		; save it
.903a  a2 68      ldx #$68         	LDX	#des_sk		; descriptor stack start
.903c  86 65      stx $65          	STX	next_s		; set descriptor stack pointer
.903e  20 92 98   jsr $9892        	JSR	LAB_CRLF		; print CR/LF
.9041  a9 2a      lda #$2a         	LDA	#<LAB_MSZM		; point to memory size message (low addr)
.9043  a0 b1      ldy #$b1         	LDY	#>LAB_MSZM		; point to memory size message (high addr)
.9045  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.9048  20 40 92   jsr $9240        	JSR	LAB_INLN		; print "? " and get BASIC input
.904b  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.904d  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.904f  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get last byte back
.9052  d0 1f      bne $9073        	BNE	LAB_2DAA		; branch if not null (user typed something)
.9054  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.9056                              lab_2d93
.9056  e6 11      inc $11          	INC	Itempl		; increment temporary integer low byte
.9058  d0 08      bne $9062        	BNE	LAB_2D99		; branch if no overflow
.905a  e6 12      inc $12          	INC	Itemph		; increment temporary integer high byte
.905c  a5 12      lda $12          	LDA	Itemph		; get high byte
.905e  c9 80      cmp #$80         	CMP	#>Ram_top		; compare with top of RAM+1
.9060  f0 1d      beq $907f        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
.9062                              lab_2d99
.9062  a9 55      lda #$55         	LDA	#$55			; set test byte
.9064  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.9066  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.9068  d0 15      bne $907f        	BNE	LAB_2DB6		; branch if fail
.906a  0a         asl              	ASL				; shift test byte left (now $AA)
.906b  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.906d  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.906f  f0 e5      beq $9056        	BEQ	LAB_2D93		; if ok go do next byte
.9071  d0 0c      bne $907f        	BNE	LAB_2DB6		; branch if fail
.9073                              lab_2daa
.9073  20 a6 a9   jsr $a9a6        	JSR	LAB_2887		; get FAC1 from string
.9076  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9078  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.907a  b0 a2      bcs $901e        	BCS	LAB_GMEM		; if too large go try again
.907c  20 f7 a4   jsr $a4f7        	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
.907f                              lab_2db6
.907f  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.9081  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte
.9083  c0 01      cpy #$01         	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
.9085  90 97      bcc $901e        	BCC	LAB_GMEM		; if too small go try again
.9087  85 85      sta $85          	STA	Ememl			; set end of mem low byte
.9089  84 86      sty $86          	STY	Ememh			; set end of mem high byte
.908b  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.908d  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.908f  a0 00      ldy #$00         	LDY	#<Ram_base		; set start addr low byte
.9091  a2 04      ldx #$04         	LDX	#>Ram_base		; set start addr high byte
.9093  84 79      sty $79          	STY	Smeml			; save start of mem low byte
.9095  86 7a      stx $7a          	STX	Smemh			; save start of mem high byte
.9097  98         tya              	TYA				; clear A
.9098  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first byte
.909a  e6 79      inc $79          	INC	Smeml			; increment start of mem low byte
.909c                              lab_2e05
.909c  20 92 98   jsr $9892        	JSR	LAB_CRLF		; print CR/LF
.909f  20 50 93   jsr $9350        	JSR	LAB_1463		; do "NEW" and "CLEAR"
.90a2  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.90a4  38         sec              	SEC				; set carry for subtract
.90a5  e5 79      sbc $79          	SBC	Smeml			; subtract start of mem low byte
.90a7  aa         tax              	TAX				; copy to X
.90a8  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.90aa  e5 7a      sbc $7a          	SBC	Smemh			; subtract start of mem high byte
.90ac  20 82 aa   jsr $aa82        	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
.90af  a9 39      lda #$39         	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
.90b1  a0 b1      ldy #$b1         	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
.90b3  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.90b6  a9 5a      lda #$5a         	LDA	#<LAB_1274		; warm start vector low byte
.90b8  a0 91      ldy #$91         	LDY	#>LAB_1274		; warm start vector high byte
.90ba  85 01      sta $01          	STA	Wrmjpl		; save warm start vector low byte
.90bc  84 02      sty $02          	STY	Wrmjph		; save warm start vector high byte
.90be  6c 01 00   jmp ($0001)      	JMP	(Wrmjpl)		; go do warm start
.90c1                              lab_11cf
.90c1  20 0b 91   jsr $910b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.90c4  85 7f      sta $7f          	STA	Earryl		; save new array mem end low byte
.90c6  84 80      sty $80          	STY	Earryh		; save new array mem end high byte
.90c8                              lab_11d6
.90c8  38         sec              	SEC				; set carry for subtract
.90c9  a5 a6      lda $a6          	LDA	Obendl		; get block end low byte
.90cb  e5 aa      sbc $aa          	SBC	Ostrtl		; subtract block start low byte
.90cd  a8         tay              	TAY				; copy MOD(block length/$100) byte to Y
.90ce  a5 a7      lda $a7          	LDA	Obendh		; get block end high byte
.90d0  e5 ab      sbc $ab          	SBC	Ostrth		; subtract block start high byte
.90d2  aa         tax              	TAX				; copy block length high byte to X
.90d3  e8         inx              	INX				; +1 to allow for count=0 exit
.90d4  98         tya              	TYA				; copy block length low byte to A
.90d5  f0 24      beq $90fb        	BEQ	LAB_120A		; branch if length low byte=0
.90d7  38         sec              	SEC				; set carry for add + 1, two's complement
.90d8  49 ff      eor #$ff         	EOR	#$FF			; invert low byte for subtract
.90da  65 a6      adc $a6          	ADC	Obendl		; add block end low byte
.90dc  85 a6      sta $a6          	STA	Obendl		; save corrected old block end low byte
.90de  b0 03      bcs $90e3        	BCS	LAB_11F3		; branch if no underflow
.90e0  c6 a7      dec $a7          	DEC	Obendh		; else decrement block end high byte
.90e2  38         sec              	SEC				; set carry for add + 1, two's complement
.90e3                              lab_11f3
.90e3  98         tya              	TYA				; get MOD(block length/$100) byte
.90e4  49 ff      eor #$ff         	EOR	#$FF			; invert low byte for subtract
.90e6  65 a4      adc $a4          	ADC	Nbendl		; add destination end low byte
.90e8  85 a4      sta $a4          	STA	Nbendl		; save modified new block end low byte
.90ea  b0 08      bcs $90f4        	BCS	LAB_1203		; branch if no underflow
.90ec  c6 a5      dec $a5          	DEC	Nbendh		; else decrement block end high byte
.90ee  90 04      bcc $90f4        	BCC	LAB_1203		; branch always
.90f0                              lab_11ff
.90f0  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.90f2  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; copy byte to destination
.90f4                              lab_1203
.90f4  88         dey              	DEY				; decrement index
.90f5  d0 f9      bne $90f0        	BNE	LAB_11FF		; loop until Y=0
.90f7  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.90f9  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; save byte to destination
.90fb                              lab_120a
.90fb  c6 a7      dec $a7          	DEC	Obendh		; decrement source pointer high byte
.90fd  c6 a5      dec $a5          	DEC	Nbendh		; decrement destination pointer high byte
.90ff  ca         dex              	DEX				; decrement block count
.9100  d0 f2      bne $90f4        	BNE	LAB_1203		; loop until count = $0
.9102  60         rts              	RTS
.9103                              lab_1212
.9103  85 78      sta $78          	STA	TempB			; save result in temp byte
.9105  ba         tsx              	TSX				; copy stack
.9106  e4 78      cpx $78          	CPX	TempB			; compare new "limit" with stack
.9108  90 30      bcc $913a        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
.910a  60         rts              	RTS
.910b                              lab_121f
.910b  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.910d  90 2a      bcc $9139        	BCC	LAB_124B		; if less then exit (is ok)
.910f  d0 04      bne $9115        	BNE	LAB_1229		; skip next test if greater (tested <)
.9111  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.9113  90 24      bcc $9139        	BCC	LAB_124B		; if less then exit (is ok)
.9115                              lab_1229
.9115  48         pha              	PHA				; push addr low byte
.9116  a2 08      ldx #$08         	LDX	#$08			; set index to save Adatal to expneg inclusive
.9118  98         tya              	TYA				; copy addr high byte (to push on stack)
.9119                              lab_122d
.9119  48         pha              	PHA				; push byte
.911a  b5 a3      lda $a3,x        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
.911c  ca         dex              	DEX				; decrement index
.911d  10 fa      bpl $9119        	BPL	LAB_122D		; loop until all done
.911f  20 df a1   jsr $a1df        	JSR	LAB_GARB		; garbage collection routine
.9122  a2 00      ldx #$00         	LDX	#$00			; clear the index to restore bytes
.9124                              lab_1238
.9124  68         pla              	PLA				; pop byte
.9125  95 a4      sta $a4,x        	STA	Adatal,X		; save byte to Adatal to expneg
.9127  e8         inx              	INX				; increment index
.9128  e0 08      cpx #$08         	CPX	#$08			; compare with end + 1
.912a  30 f8      bmi $9124        	BMI	LAB_1238		; loop if more to do
.912c  68         pla              	PLA				; pop addr high byte
.912d  a8         tay              	TAY				; copy back to Y
.912e  68         pla              	PLA				; pop addr low byte
.912f  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.9131  90 06      bcc $9139        	BCC	LAB_124B		; if less then exit (is ok)
.9133  d0 05      bne $913a        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
.9135  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.9137  b0 01      bcs $913a        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
.9139                              lab_124b
.9139  60         rts              	RTS
.913a                              lab_omer
.913a  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.913c                              lab_xerr
.913c  20 92 98   jsr $9892        	JSR	LAB_CRLF		; print CR/LF
.913f  bd b2 b6   lda $b6b2,x      	LDA	LAB_BAER,X		; get error message pointer low byte
.9142  bc b3 b6   ldy $b6b3,x      	LDY	LAB_BAER+1,X	; get error message pointer high byte
.9145  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.9148  20 89 93   jsr $9389        	JSR	LAB_1491		; flush stack and clear continue flag
.914b  a9 ef      lda #$ef         	LDA	#<LAB_EMSG		; point to " Error" low addr
.914d  a0 b7      ldy #$b7         	LDY	#>LAB_EMSG		; point to " Error" high addr
.914f                              lab_1269
.914f  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.9152  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.9154  c8         iny              	INY				; increment it
.9155  f0 03      beq $915a        	BEQ	LAB_1274		; go do warm start (was immediate mode)
.9157  20 77 aa   jsr $aa77        	JSR	LAB_2953		; print " in line [LINE #]"
.915a                              lab_1274
.915a  a9 00      lda #$00         	LDA	#$00			; clear A
.915c  85 df      sta $df          	STA	IrqBase		; clear enabled byte
.915e  85 dc      sta $dc          	STA	NmiBase		; clear enabled byte
.9160  a9 00      lda #$00         	LDA	#<LAB_RMSG		; point to "Ready" message low byte
.9162  a0 b8      ldy #$b8         	LDY	#>LAB_RMSG		; point to "Ready" message high byte
.9164  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; go do print string
.9167                              lab_127d
.9167  20 4d 92   jsr $924d        	JSR	LAB_1357		; call for BASIC input
.916a                              lab_1280
.916a  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.916c  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.916e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9171  f0 f4      beq $9167        	BEQ	LAB_127D		; loop while null
.9173  a2 ff      ldx #$ff         	LDX	#$FF			; current line to null value
.9175  86 88      stx $88          	STX	Clineh		; set current line high byte
.9177  90 06      bcc $917f        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
.9179  20 7e 92   jsr $927e        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.917c  4c f3 94   jmp $94f3        	JMP	LAB_15F6		; go scan and interpret code
.917f                              lab_1295
.917f  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.9182  20 7e 92   jsr $927e        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.9185  84 5d      sty $5d          	STY	Ibptr			; save index pointer to end of crunched line
.9187  20 24 93   jsr $9324        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.918a  90 44      bcc $91d0        	BCC	LAB_12E6		; branch if not found
.918c  a0 01      ldy #$01         	LDY	#$01			; set index to next line pointer high byte
.918e  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.9190  85 72      sta $72          	STA	ut1_ph		; save it
.9192  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.9194  85 71      sta $71          	STA	ut1_pl		; save it
.9196  a5 ab      lda $ab          	LDA	Baslnh		; get found line pointer high byte
.9198  85 74      sta $74          	STA	ut2_ph		; save it
.919a  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.919c  88         dey              	DEY				; decrement index
.919d  f1 aa      sbc ($aa),y      	SBC	(Baslnl),Y		; subtract next line pointer low byte
.919f  18         clc              	CLC				; clear carry for add
.91a0  65 7b      adc $7b          	ADC	Svarl			; add start of vars low byte
.91a2  85 7b      sta $7b          	STA	Svarl			; save new start of vars low byte
.91a4  85 73      sta $73          	STA	ut2_pl		; save destination pointer low byte
.91a6  a5 7c      lda $7c          	LDA	Svarh			; get start of vars high byte
.91a8  69 ff      adc #$ff         	ADC	#$FF			; -1 + carry
.91aa  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.91ac  e5 ab      sbc $ab          	SBC	Baslnh		; subtract found line pointer high byte
.91ae  aa         tax              	TAX				; copy to block count
.91af  38         sec              	SEC				; set carry for subtract
.91b0  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.91b2  e5 7b      sbc $7b          	SBC	Svarl			; subtract start of vars low byte
.91b4  a8         tay              	TAY				; copy to bytes in first block count
.91b5  b0 03      bcs $91ba        	BCS	LAB_12D0		; branch if overflow
.91b7  e8         inx              	INX				; increment block count (correct for =0 loop exit)
.91b8  c6 74      dec $74          	DEC	ut2_ph		; decrement destination high byte
.91ba                              lab_12d0
.91ba  18         clc              	CLC				; clear carry for add
.91bb  65 71      adc $71          	ADC	ut1_pl		; add source pointer low byte
.91bd  90 03      bcc $91c2        	BCC	LAB_12D8		; branch if no overflow
.91bf  c6 72      dec $72          	DEC	ut1_ph		; else decrement source pointer high byte
.91c1  18         clc              	CLC				; clear carry
.91c2                              lab_12d8
.91c2  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from source
.91c4  91 73      sta ($73),y      	STA	(ut2_pl),Y		; copy to destination
.91c6  c8         iny              	INY				; increment index
.91c7  d0 f9      bne $91c2        	BNE	LAB_12D8		; while <> 0 do this block
.91c9  e6 72      inc $72          	INC	ut1_ph		; increment source pointer high byte
.91cb  e6 74      inc $74          	INC	ut2_ph		; increment destination pointer high byte
.91cd  ca         dex              	DEX				; decrement block count
.91ce  d0 f2      bne $91c2        	BNE	LAB_12D8		; loop until all done
.91d0                              lab_12e6
.91d0  ad 0d 02   lda $020d        	LDA	Ibuffs		; get byte from start of input buffer
.91d3  f0 3f      beq $9214        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
.91d5  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.91d7  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.91d9  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.91db  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.91dd  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte	(end of BASIC)
.91df  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.91e1  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte	(end of BASIC)
.91e3  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.91e5  65 5d      adc $5d          	ADC	Ibptr			; add input buffer pointer	(also buffer length)
.91e7  90 01      bcc $91ea        	BCC	LAB_1301		; branch if no overflow from add
.91e9  c8         iny              	INY				; else increment high byte
.91ea                              lab_1301
.91ea  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte	(move to, low byte)
.91ec  84 a5      sty $a5          	STY	Nbendh		; save new block end high byte
.91ee  20 c1 90   jsr $90c1        	JSR	LAB_11CF		; open up space in memory
.91f1  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.91f3  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.91f5  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.91f7  84 7c      sty $7c          	STY	Svarh			; save start of vars high byte
.91f9  a4 5d      ldy $5d          	LDY	Ibptr			; get input buffer pointer	(also buffer length)
.91fb  88         dey              	DEY				; adjust for loop type
.91fc                              lab_1311
.91fc  b9 09 02   lda $0209,y      	LDA	Ibuffs-4,Y		; get byte from crunched line
.91ff  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.9201  88         dey              	DEY				; decrement count
.9202  c0 03      cpy #$03         	CPY	#$03			; compare with first byte-1
.9204  d0 f6      bne $91fc        	BNE	LAB_1311		; continue while count <> 3
.9206  a5 12      lda $12          	LDA	Itemph		; get line # high byte
.9208  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.920a  88         dey              	DEY				; decrement count
.920b  a5 11      lda $11          	LDA	Itempl		; get line # low byte
.920d  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.920f  88         dey              	DEY				; decrement count
.9210  a9 ff      lda #$ff         	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
.9212  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.9214                              lab_1319
.9214  20 65 93   jsr $9365        	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
.9217  a6 79      ldx $79          	LDX	Smeml			; get start of mem low byte
.9219  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.921b  a0 01      ldy #$01         	LDY	#$01			; index to high byte of next line pointer
.921d                              lab_1325
.921d  86 71      stx $71          	STX	ut1_pl		; set line start pointer low byte
.921f  85 72      sta $72          	STA	ut1_ph		; set line start pointer high byte
.9221  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get it
.9223  f0 18      beq $923d        	BEQ	LAB_133E		; exit if end of program
.9225  a0 04      ldy #$04         	LDY	#$04			; point to first code byte of line
.9227                              lab_1330
.9227  c8         iny              	INY				; next code byte
.9228  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.922a  d0 fb      bne $9227        	BNE	LAB_1330		; loop if not [EOL]
.922c  38         sec              	SEC				; set carry for add + 1
.922d  98         tya              	TYA				; copy end index
.922e  65 71      adc $71          	ADC	ut1_pl		; add to line start pointer low byte
.9230  aa         tax              	TAX				; copy to X
.9231  a0 00      ldy #$00         	LDY	#$00			; clear index, point to this line's next line pointer
.9233  91 71      sta ($71),y      	STA	(ut1_pl),Y		; set next line pointer low byte
.9235  98         tya              	TYA				; clear A
.9236  65 72      adc $72          	ADC	ut1_ph		; add line start pointer high byte + carry
.9238  c8         iny              	INY				; increment index to high byte
.9239  91 71      sta ($71),y      	STA	(ut1_pl),Y		; save next line pointer low byte
.923b  90 e0      bcc $921d        	BCC	LAB_1325		; go do next line, branch always, carry clear
.923d                              lab_133e
.923d  4c 67 91   jmp $9167        	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
.9240                              lab_inln
.9240  20 eb 98   jsr $98eb        	JSR	LAB_18E3		; print "?" character
.9243  20 e8 98   jsr $98e8        	JSR	LAB_18E0		; print " "
.9246  d0 05      bne $924d        	BNE	LAB_1357		; call for BASIC input and return
.9248                              lab_134b
.9248  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.924b  ca         dex              	DEX				; decrement the buffer counter (delete)

>924c  2c                          	.byte	$2C			; make LDX into BIT abs
.924d                              lab_1357

.924d  a2 00      ldx #$00         	LDX	#$00			; clear BASIC line buffer pointer
.924f                              lab_1359
.924f  20 ea b0   jsr $b0ea        	JSR	V_INPT		; call scan input device
.9252  90 fb      bcc $924f        	BCC	LAB_1359		; loop if no byte
.9254  f0 f9      beq $924f        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
.9256  c9 07      cmp #$07         	CMP	#$07			; compare with [BELL]
.9258  f0 10      beq $926a        	BEQ	LAB_1378		; branch if [BELL]
.925a  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.925c  f0 19      beq $9277        	BEQ	LAB_1384		; do CR/LF exit if [CR]
.925e  e0 00      cpx #$00         	CPX	#$00			; compare pointer with $00
.9260  d0 04      bne $9266        	BNE	LAB_1374		; branch if not empty
.9262  c9 21      cmp #$21         	CMP	#$21			; compare with [SP]+1
.9264  90 e9      bcc $924f        	BCC	LAB_1359		; if < ignore character
.9266                              lab_1374
.9266  c9 08      cmp #$08         	CMP	#$08			; compare with [BACKSPACE] (delete last character)
.9268  f0 de      beq $9248        	BEQ	LAB_134B		; go delete last character
.926a                              lab_1378
.926a  e0 47      cpx #$47         	CPX	#Ibuffe-Ibuffs	; compare character count with max
.926c  b0 0c      bcs $927a        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
.926e  9d 0d 02   sta $020d,x      	STA	Ibuffs,X		; else store in buffer
.9271  e8         inx              	INX				; increment pointer
.9272                              lab_137f
.9272  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.9275  d0 d8      bne $924f        	BNE	LAB_1359		; always loop for next character
.9277                              lab_1384
.9277  4c 89 98   jmp $9889        	JMP	LAB_1866		; do CR/LF exit to BASIC
.927a                              lab_138e
.927a  a9 07      lda #$07         	LDA	#$07			; [BELL] character into A
.927c  d0 f4      bne $9272        	BNE	LAB_137F		; go print the [BELL] but ignore input character
.927e                              lab_13a6
.927e  a0 ff      ldy #$ff         	LDY	#$FF			; set save index (makes for easy math later)
.9280  38         sec              	SEC				; set carry for subtract
.9281  a5 c3      lda $c3          	LDA	Bpntrl		; get basic execute pointer low byte
.9283  e9 0d      sbc #$0d         	SBC	#<Ibuffs		; subtract input buffer start pointer
.9285  aa         tax              	TAX				; copy result to X (index past line # if any)
.9286  86 60      stx $60          	STX	Oquote		; clear open quote/DATA flag
.9288                              lab_13ac
.9288  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; get byte from input buffer
.928b  f0 51      beq $92de        	BEQ	LAB_13EC		; if null save byte then exit
.928d  c9 5f      cmp #$5f         	CMP	#"_"			; compare with "_"
.928f  b0 4d      bcs $92de        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.9291  c9 3c      cmp #$3c         	CMP	#"<"			; compare with "<"
.9293  b0 0e      bcs $92a3        	BCS	LAB_13CC		; if >= go crunch now
.9295  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.9297  b0 45      bcs $92de        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.9299  85 5c      sta $5c          	STA	Scnquo		; save buffer byte as search character
.929b  c9 22      cmp #$22         	CMP	#$22			; is it quote character?
.929d  f0 61      beq $9300        	BEQ	LAB_1410		; branch if so (copy quoted string)
.929f  c9 2a      cmp #$2a         	CMP	#"*"			; compare with "*"
.92a1  90 3b      bcc $92de        	BCC	LAB_13EC		; if < go save byte then continue crunching
.92a3                              lab_13cc
.92a3  24 60      bit $60          	BIT	Oquote		; get open quote/DATA token flag
.92a5  70 37      bvs $92de        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
.92a7  86 78      stx $78          	STX	TempB			; save buffer read index
.92a9  84 ba      sty $ba          	STY	csidx			; copy buffer save index
.92ab  a0 12      ldy #$12         	LDY	#<TAB_1STC		; get keyword first character table low address
.92ad  84 73      sty $73          	STY	ut2_pl		; save pointer low byte
.92af  a0 b3      ldy #$b3         	LDY	#>TAB_1STC		; get keyword first character table high address
.92b1  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.92b3  a0 00      ldy #$00         	LDY	#$00			; clear table pointer
.92b5                              lab_13d0
.92b5  d1 73      cmp ($73),y      	CMP	(ut2_pl),Y		; compare with keyword first character table byte
.92b7  f0 05      beq $92be        	BEQ	LAB_13D1		; go do word_table_chr if match
.92b9  90 21      bcc $92dc        	BCC	LAB_13EA		; if < keyword first character table byte go restore
.92bb  c8         iny              	INY				; else increment pointer
.92bc  d0 f7      bne $92b5        	BNE	LAB_13D0		; and loop (branch always)
.92be                              lab_13d1
.92be  98         tya              	TYA				; copy matching index
.92bf  0a         asl              	ASL				; *2 (bytes per pointer)
.92c0  aa         tax              	TAX				; copy to new index
.92c1  bd 30 b3   lda $b330,x      	LDA	TAB_CHRT,X		; get keyword table pointer low byte
.92c4  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.92c6  bd 31 b3   lda $b331,x      	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
.92c9  85 74      sta $74          	STA	ut2_ph		; save pointer high byte
.92cb  a0 ff      ldy #$ff         	LDY	#$FF			; clear table pointer (make -1 for start)
.92cd  a6 78      ldx $78          	LDX	TempB			; restore buffer read index
.92cf                              lab_13d6
.92cf  c8         iny              	INY				; next table byte
.92d0  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from table
.92d2                              lab_13d8
.92d2  30 08      bmi $92dc        	BMI	LAB_13EA		; all bytes matched so go save token
.92d4  e8         inx              	INX				; next buffer byte
.92d5  dd 0d 02   cmp $020d,x      	CMP	Ibuffs,X		; compare with byte from input buffer
.92d8  f0 f5      beq $92cf        	BEQ	LAB_13D6		; go compare next if match
.92da  d0 2b      bne $9307        	BNE	LAB_1417		; branch if >< (not found keyword)
.92dc                              lab_13ea
.92dc  a4 ba      ldy $ba          	LDY	csidx			; restore save index
.92de                              lab_13ec
.92de  e8         inx              	INX				; increment buffer index (to next input byte)
.92df  c8         iny              	INY				; increment save index (to next output byte)
.92e0  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save byte to output
.92e3  c9 00      cmp #$00         	CMP	#$00			; set the flags, set carry
.92e5  f0 32      beq $9319        	BEQ	LAB_142A		; do exit if was null [EOL]
.92e7  e9 3a      sbc #$3a         	SBC	#":"			; subtract ":" (carry set by CMP #00)
.92e9  f0 04      beq $92ef        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
.92eb  c9 49      cmp #$49         	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
.92ed  d0 02      bne $92f1        	BNE	LAB_1401		; branch if not DATA
.92ef                              lab_13ff
.92ef  85 60      sta $60          	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
.92f1                              lab_1401
.92f1  49 57      eor #$57         	EOR	#TK_REM-$3A		; effectively subtract REM token offset
.92f3  d0 93      bne $9288        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
.92f5  85 5c      sta $5c          	STA	Asrch			; else was REM so set search for [EOL]
.92f7                              lab_1408
.92f7  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; get byte from input buffer
.92fa  f0 e2      beq $92de        	BEQ	LAB_13EC		; branch if null [EOL]
.92fc  c5 5c      cmp $5c          	CMP	Asrch			; compare with stored character
.92fe  f0 de      beq $92de        	BEQ	LAB_13EC		; branch if match (end quote)
.9300                              lab_1410
.9300  c8         iny              	INY				; increment buffer save index
.9301  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save byte to output
.9304  e8         inx              	INX				; increment buffer read index
.9305  d0 f0      bne $92f7        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
.9307                              lab_1417
.9307  a6 78      ldx $78          	LDX	TempB			; compare has failed, restore buffer index (start byte!)
.9309                              lab_141b
.9309  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get table byte
.930b  08         php              	PHP				; save status
.930c  c8         iny              	INY				; increment table index
.930d  28         plp              	PLP				; restore byte status
.930e  10 f9      bpl $9309        	BPL	LAB_141B		; if not end of keyword go do next
.9310  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from keyword table
.9312  d0 be      bne $92d2        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
.9314  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; restore byte from input buffer
.9317  10 c3      bpl $92dc        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
.9319                              lab_142a
.9319  c8         iny              	INY				; increment pointer
.931a  c8         iny              	INY				; increment pointer (makes it next line pointer high byte)
.931b  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
.931e  c8         iny              	INY				; adjust for line copy
.931f  c8         iny              	INY				; adjust for line copy
.9320  c8         iny              	INY				; adjust for line copy
.9321  c6 c3      dec $c3          	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
.9323  60         rts              	RTS
.9324                              lab_ssln
.9324  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.9326  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.9328                              lab_shln
.9328  a0 01      ldy #$01         	LDY	#$01			; set index
.932a  85 aa      sta $aa          	STA	Baslnl		; save low byte as current
.932c  86 ab      stx $ab          	STX	Baslnh		; save high byte as current
.932e  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get pointer high byte from addr
.9330  f0 1a      beq $934c        	BEQ	LAB_145F		; pointer was zero so we"re done, do "not found" exit
.9332  a0 03      ldy #$03         	LDY	#$03			; set index to line # high byte
.9334  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.9336  88         dey              	DEY				; decrement index (point to low byte)
.9337  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.9339  d0 04      bne $933f        	BNE	LAB_1455		; if <> skip low byte check
.933b  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.933d  c5 11      cmp $11          	CMP	Itempl		; compare with temporary integer low byte
.933f                              lab_1455
.933f  b0 09      bcs $934a        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
.9341                              lab_1456
.9341  88         dey              	DEY				; decrement index to next line ptr high byte
.9342  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.9344  aa         tax              	TAX				; copy to X
.9345  88         dey              	DEY				; decrement index to next line ptr low byte
.9346  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.9348  90 de      bcc $9328        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
.934a                              lab_145e
.934a  f0 01      beq $934d        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
.934c                              lab_145f
.934c  18         clc              	CLC				; clear found flag
.934d                              lab_1460
.934d  60         rts              	RTS
.934e                              lab_new
.934e  d0 fd      bne $934d        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
.9350                              lab_1463
.9350  a9 00      lda #$00         	LDA	#$00			; clear A
.9352  a8         tay              	TAY				; clear Y
.9353  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, low byte
.9355  c8         iny              	INY				; increment index
.9356  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, high byte
.9358  18         clc              	CLC				; clear carry
.9359  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.935b  69 02      adc #$02         	ADC	#$02			; calculate end of BASIC low byte
.935d  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.935f  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.9361  69 00      adc #$00         	ADC	#$00			; add any carry
.9363  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.9365                              lab_1477
.9365  18         clc              	CLC				; clear carry
.9366  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.9368  69 ff      adc #$ff         	ADC	#$FF			; -1
.936a  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.936c  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.936e  69 ff      adc #$ff         	ADC	#$FF			; -1+carry
.9370  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.9372                              lab_147a
.9372  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.9374  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.9376  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.9378  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.937a  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.937c  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte
.937e  85 7d      sta $7d          	STA	Sarryl		; save var mem end low byte
.9380  84 7e      sty $7e          	STY	Sarryh		; save var mem end high byte
.9382  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.9384  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.9386  20 44 95   jsr $9544        	JSR	LAB_161A		; perform RESTORE command
.9389                              lab_1491
.9389  a2 68      ldx #$68         	LDX	#des_sk		; set descriptor stack pointer
.938b  86 65      stx $65          	STX	next_s		; save descriptor stack pointer
.938d  68         pla              	PLA				; pull return address low byte
.938e  aa         tax              	TAX				; copy return address low byte
.938f  68         pla              	PLA				; pull return address high byte
.9390  8e fe 01   stx $01fe        	STX	LAB_SKFE		; save to cleared stack
.9393  8d ff 01   sta $01ff        	STA	LAB_SKFF		; save to cleared stack
.9396  a2 fd      ldx #$fd         	LDX	#$FD			; new stack pointer
.9398  9a         txs              	TXS				; reset stack
.9399  a9 00      lda #$00         	LDA	#$00			; clear byte
.939b  85 8c      sta $8c          	STA	Cpntrh		; clear continue pointer high byte
.939d  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.939f                              lab_14a6
.939f  60         rts              	RTS
.93a0                              lab_clear
.93a0  f0 d0      beq $9372        	BEQ	LAB_147A		; if no following token go do "CLEAR"
.93a2  60         rts              	RTS
.93a3                              lab_list
.93a3  90 06      bcc $93ab        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
.93a5  f0 04      beq $93ab        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
.93a7  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.93a9  d0 f4      bne $939f        	BNE	LAB_14A6		; exit if not - (LIST -m)
.93ab                              lab_14bd
.93ab  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.93ae  20 24 93   jsr $9324        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.93b1  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.93b4  f0 0c      beq $93c2        	BEQ	LAB_14D4		; branch if no more characters
.93b6  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.93b8  d0 93      bne $934d        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
.93ba  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.93bd  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.93c0  d0 8b      bne $934d        	BNE	LAB_1460		; exit if not ok
.93c2                              lab_14d4
.93c2  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.93c4  05 12      ora $12          	ORA	Itemph		; OR temporary integer high byte
.93c6  d0 06      bne $93ce        	BNE	LAB_14E2		; branch if start set
.93c8  a9 ff      lda #$ff         	LDA	#$FF			; set for -1
.93ca  85 11      sta $11          	STA	Itempl		; set temporary integer low byte
.93cc  85 12      sta $12          	STA	Itemph		; set temporary integer high byte
.93ce                              lab_14e2
.93ce  a0 01      ldy #$01         	LDY	#$01			; set index for line
.93d0  84 60      sty $60          	STY	Oquote		; clear open quote flag
.93d2  20 92 98   jsr $9892        	JSR	LAB_CRLF		; print CR/LF
.93d5  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.93d7  f0 3e      beq $9417        	BEQ	LAB_152B		; if null all done so exit
.93d9  20 14 95   jsr $9514        	JSR	LAB_1629		; do CRTL-C check vector
.93dc  c8         iny              	INY				; increment index for line
.93dd  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.93df  aa         tax              	TAX				; copy to X
.93e0  c8         iny              	INY				; increment index
.93e1  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.93e3  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.93e5  d0 04      bne $93eb        	BNE	LAB_14FF		; branch if no high byte match
.93e7  e4 11      cpx $11          	CPX	Itempl		; compare with temporary integer low byte
.93e9  f0 02      beq $93ed        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
.93eb                              lab_14ff
.93eb  b0 2a      bcs $9417        	BCS	LAB_152B		; if greater all done so exit
.93ed                              lab_1501
.93ed  84 97      sty $97          	STY	Tidx1			; save index for line
.93ef  20 82 aa   jsr $aa82        	JSR	LAB_295E		; print XA as unsigned integer
.93f2  a9 20      lda #$20         	LDA	#$20			; space is the next character
.93f4                              lab_1508
.93f4  a4 97      ldy $97          	LDY	Tidx1			; get index for line
.93f6  29 7f      and #$7f         	AND	#$7F			; mask top out bit of character
.93f8                              lab_150c
.93f8  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.93fb  c9 22      cmp #$22         	CMP	#$22			; was it " character
.93fd  d0 06      bne $9405        	BNE	LAB_1519		; branch if not
.93ff  a5 60      lda $60          	LDA	Oquote		; get open quote flag
.9401  49 ff      eor #$ff         	EOR	#$FF			; toggle it
.9403  85 60      sta $60          	STA	Oquote		; save it back
.9405                              lab_1519
.9405  c8         iny              	INY				; increment index
.9406  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next byte
.9408  d0 0e      bne $9418        	BNE	LAB_152E		; branch if not [EOL] (go print character)
.940a  a8         tay              	TAY				; else clear index
.940b  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.940d  aa         tax              	TAX				; copy to X
.940e  c8         iny              	INY				; increment index
.940f  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.9411  86 aa      stx $aa          	STX	Baslnl		; set pointer to line low byte
.9413  85 ab      sta $ab          	STA	Baslnh		; set pointer to line high byte
.9415  d0 b7      bne $93ce        	BNE	LAB_14E2		; go do next line if not [EOT]
.9417                              lab_152b
.9417  60         rts              	RTS
.9418                              lab_152e
.9418  10 de      bpl $93f8        	BPL	LAB_150C		; just go print it if not token byte
.941a  24 60      bit $60          	BIT	Oquote		; test the open quote flag
.941c  30 da      bmi $93f8        	BMI	LAB_150C		; just go print character if open quote set
.941e  a2 b5      ldx #$b5         	LDX	#>LAB_KEYT		; get table address high byte
.9420  0a         asl              	ASL				; *2
.9421  0a         asl              	ASL				; *4
.9422  90 02      bcc $9426        	BCC	LAB_152F		; branch if no carry
.9424  e8         inx              	INX				; else increment high byte
.9425  18         clc              	CLC				; clear carry for add
.9426                              lab_152f
.9426  69 16      adc #$16         	ADC	#<LAB_KEYT		; add low byte
.9428  90 01      bcc $942b        	BCC	LAB_1530		; branch if no carry
.942a  e8         inx              	INX				; else increment high byte
.942b                              lab_1530
.942b  85 73      sta $73          	STA	ut2_pl		; save table pointer low byte
.942d  86 74      stx $74          	STX	ut2_ph		; save table pointer high byte
.942f  84 97      sty $97          	STY	Tidx1			; save index for line
.9431  a0 00      ldy #$00         	LDY	#$00			; clear index
.9433  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get length
.9435  aa         tax              	TAX				; copy length
.9436  c8         iny              	INY				; increment index
.9437  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get 1st character
.9439  ca         dex              	DEX				; decrement length
.943a  f0 b8      beq $93f4        	BEQ	LAB_1508		; if no more characters exit and print
.943c  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.943f  c8         iny              	INY				; increment index
.9440  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address low byte
.9442  48         pha              	PHA				; save it for now
.9443  c8         iny              	INY				; increment index
.9444  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address high byte
.9446  a0 00      ldy #$00         	LDY	#$00
.9448  85 74      sta $74          	STA	ut2_ph		; save keyword pointer high byte
.944a  68         pla              	PLA				; pull low byte
.944b  85 73      sta $73          	STA	ut2_pl		; save keyword pointer low byte
.944d                              lab_1540
.944d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get character
.944f  ca         dex              	DEX				; decrement character count
.9450  f0 a2      beq $93f4        	BEQ	LAB_1508		; if last character exit and print
.9452  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.9455  c8         iny              	INY				; increment index
.9456  d0 f5      bne $944d        	BNE	LAB_1540		; loop for next character
.9458                              lab_for
.9458  a9 80      lda #$80         	LDA	#$80			; set FNX
.945a  85 61      sta $61          	STA	Sufnxf		; set subscript/FNX flag
.945c  20 b4 97   jsr $97b4        	JSR	LAB_LET		; go do LET
.945f  68         pla              	PLA				; pull return address
.9460  68         pla              	PLA				; pull return address
.9461  a9 10      lda #$10         	LDA	#$10			; we need 16d bytes !
.9463  20 03 91   jsr $9103        	JSR	LAB_1212		; check room on stack for A bytes
.9466  20 9d 96   jsr $969d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.9469  18         clc              	CLC				; clear carry for add
.946a  98         tya              	TYA				; copy index to A
.946b  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.946d  48         pha              	PHA				; push onto stack
.946e  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.9470  69 00      adc #$00         	ADC	#$00			; add carry
.9472  48         pha              	PHA				; push onto stack
.9473  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.9475  48         pha              	PHA				; push onto stack
.9476  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.9478  48         pha              	PHA				; push onto stack
.9479  a9 ae      lda #$ae         	LDA	#TK_TO		; get "TO" token
.947b  20 f1 9b   jsr $9bf1        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.947e  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.9481  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.9484  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.9486  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.9488  25 ad      and $ad          	AND	FAC1_1		; and FAC1 mantissa1
.948a  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.948c  a9 97      lda #$97         	LDA	#<LAB_159F		; set return address low byte
.948e  a0 94      ldy #$94         	LDY	#>LAB_159F		; set return address high byte
.9490  85 71      sta $71          	STA	ut1_pl		; save return address low byte
.9492  84 72      sty $72          	STY	ut1_ph		; save return address high byte
.9494  4c 84 9b   jmp $9b84        	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
.9497                              lab_159f
.9497  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
.9499  a0 b1      ldy #$b1         	LDY	#>LAB_259C		; set 1 pointer high addr
.949b  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.949e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.94a1  c9 b3      cmp #$b3         	CMP	#TK_STEP		; compare with STEP token
.94a3  d0 06      bne $94ab        	BNE	LAB_15B3		; jump if not "STEP"
.94a5  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.94a8  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.94ab                              lab_15b3
.94ab  20 e9 a8   jsr $a8e9        	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
.94ae  85 b0      sta $b0          	STA	FAC1_s		; set FAC1 sign (b7)
.94b0  20 79 9b   jsr $9b79        	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
.94b3  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.94b5  48         pha              	PHA				; push on stack
.94b6  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.94b8  48         pha              	PHA				; push on stack
.94b9  a9 81      lda #$81         	LDA	#TK_FOR		; get FOR token
.94bb  48         pha              	PHA				; push on stack
.94bc                              lab_15c2
.94bc  20 14 95   jsr $9514        	JSR	LAB_1629		; do CRTL-C check vector
.94bf  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.94c1  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.94c3  a6 88      ldx $88          	LDX	Clineh		; continue line is $FFxx for immediate mode
.94c5  e8         inx              	INX				; increment it (now $00 if immediate mode)
.94c6  f0 04      beq $94cc        	BEQ	LAB_15D1		; branch if null (immediate mode)
.94c8  85 8b      sta $8b          	STA	Cpntrl		; save continue pointer low byte
.94ca  84 8c      sty $8c          	STY	Cpntrh		; save continue pointer high byte
.94cc                              lab_15d1
.94cc  a0 00      ldy #$00         	LDY	#$00			; clear index
.94ce  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.94d0  f0 07      beq $94d9        	BEQ	LAB_15DC		; branch if null [EOL]
.94d2  c9 3a      cmp #$3a         	CMP	#":"			; compare with ":"
.94d4  f0 1d      beq $94f3        	BEQ	LAB_15F6		; branch if = (statement separator)
.94d6                              lab_15d9
.94d6  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; else syntax error then warm start
.94d9                              lab_15dc
.94d9  a0 02      ldy #$02         	LDY	#$02			; set index
.94db  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.94dd  18         clc              	CLC				; clear carry for no "BREAK" message
.94de  f0 56      beq $9536        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
.94e0  c8         iny              	INY				; increment index
.94e1  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # low byte
.94e3  85 87      sta $87          	STA	Clinel		; save current line low byte
.94e5  c8         iny              	INY				; increment index
.94e6  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # high byte
.94e8  85 88      sta $88          	STA	Clineh		; save current line high byte
.94ea  98         tya              	TYA				; A now = 4
.94eb  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.94ed  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.94ef  90 02      bcc $94f3        	BCC	LAB_15F6		; branch if no overflow
.94f1  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.94f3                              lab_15f6
.94f3  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.94f6                              lab_15f9
.94f6  20 fc 94   jsr $94fc        	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
.94f9                              lab_15fc
.94f9  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; loop
.94fc                              lab_15ff
.94fc  f0 54      beq $9552        	BEQ	LAB_1628		; exit if zero [EOL]
.94fe                              lab_1602
.94fe  0a         asl              	ASL				; *2 bytes per vector and normalise token
.94ff  b0 03      bcs $9504        	BCS	LAB_1609		; branch if was token
.9501  4c b4 97   jmp $97b4        	JMP	LAB_LET		; else go do implied LET
.9504                              lab_1609
.9504  c9 58      cmp #$58         	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
.9506  b0 ce      bcs $94d6        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
.9508  a8         tay              	TAY				; copy to index
.9509  b9 08 b2   lda $b208,y      	LDA	LAB_CTBL+1,Y	; get vector high byte
.950c  48         pha              	PHA				; onto stack
.950d  b9 07 b2   lda $b207,y      	LDA	LAB_CTBL,Y		; get vector low byte
.9510  48         pha              	PHA				; onto stack
.9511  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; jump to increment and scan memory
.9514                              lab_1629
.9514  6c 03 02   jmp ($0203)      	JMP	(VEC_CC)		; ctrl c check vector
.9517                              lab_1636
.9517  c9 03      cmp #$03         	CMP	#$03			; compare with CTRL-C
.9519                              lab_stop
.9519  b0 01      bcs $951c        	BCS	LAB_163B		; branch if token follows STOP
.951b                              lab_end
.951b  18         clc              	CLC				; clear the carry, indicate a normal program end
.951c                              lab_163b
.951c  d0 67      bne $9585        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
.951e  a5 c4      lda $c4          	LDA	Bpntrh		; get the BASIC execute pointer high byte
.9520  49 02      eor #$02         	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
.9522  f0 10      beq $9534        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
.9524  49 02      eor #$02         	EOR	#>Ibuffs		; correct the bits
.9526  a4 c3      ldy $c3          	LDY	Bpntrl		; get BASIC execute pointer low byte
.9528  84 8b      sty $8b          	STY	Cpntrl		; save continue pointer low byte
.952a  85 8c      sta $8c          	STA	Cpntrh		; save continue pointer high byte
.952c                              lab_1647
.952c  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.952e  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.9530  85 89      sta $89          	STA	Blinel		; save break line low byte
.9532  84 8a      sty $8a          	STY	Blineh		; save break line high byte
.9534                              lab_164f
.9534  68         pla              	PLA				; pull return address low
.9535  68         pla              	PLA				; pull return address high
.9536                              lab_1651
.9536  90 07      bcc $953f        	BCC	LAB_165E		; if was program end just do warm start
.9538  a9 e7      lda #$e7         	LDA	#<LAB_BMSG		; point to "Break" low byte
.953a  a0 b7      ldy #$b7         	LDY	#>LAB_BMSG		; point to "Break" high byte
.953c  4c 4f 91   jmp $914f        	JMP	LAB_1269		; print "Break" and do warm start
.953f                              lab_165e
.953f  4c 5a 91   jmp $915a        	JMP	LAB_1274		; go do warm start
.9542                              lab_restore
.9542  d0 0f      bne $9553        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
.9544                              lab_161a
.9544  38         sec              	SEC				; set carry for subtract
.9545  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.9547  e9 01      sbc #$01         	SBC	#$01			; -1
.9549  a4 7a      ldy $7a          	LDY	Smemh			; get start of mem high byte
.954b  b0 01      bcs $954e        	BCS	LAB_1624		; branch if no underflow
.954d                              lab_uflow
.954d  88         dey              	DEY				; else decrement high byte
.954e                              lab_1624
.954e  85 8f      sta $8f          	STA	Dptrl			; save DATA pointer low byte
.9550  84 90      sty $90          	STY	Dptrh			; save DATA pointer high byte
.9552                              lab_1628
.9552  60         rts              	RTS
.9553                              lab_restoren
.9553  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.9556  20 a0 96   jsr $96a0        	JSR	LAB_SNBL		; scan for next BASIC line
.9559  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.955b  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.955d  b0 0b      bcs $956a        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
.955f  98         tya              	TYA				; else copy line index to A
.9560  38         sec              	SEC				; set carry (+1)
.9561  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.9563  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.9565  90 07      bcc $956e        	BCC	LAB_go_search	; branch if no overflow to high byte
.9567  e8         inx              	INX				; increment high byte
.9568  b0 04      bcs $956e        	BCS	LAB_go_search	; branch always (can never be carry clear)
.956a                              lab_reset_search
.956a  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.956c  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.956e                              lab_go_search
.956e  20 28 93   jsr $9328        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.9571  b0 03      bcs $9576        	BCS	LAB_line_found	; if carry set go set pointer
.9573  4c 72 96   jmp $9672        	JMP	LAB_16F7		; else go do "Undefined statement" error
.9576                              lab_line_found
.9576  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.9578  e9 01      sbc #$01         	SBC	#$01			; -1
.957a  a4 ab      ldy $ab          	LDY	Baslnh		; get pointer high byte
.957c  b0 d0      bcs $954e        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
.957e  90 cd      bcc $954d        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
.9580                              lab_null
.9580  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter
.9583  86 0d      stx $0d          	STX	Nullct		; save new NULL count
.9585                              lab_167a
.9585  60         rts              	RTS
.9586                              lab_cont
.9586  d0 fd      bne $9585        	BNE	LAB_167A		; if following byte exit to do syntax error
.9588  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.958a  d0 05      bne $9591        	BNE	LAB_166C		; go do continue if we can
.958c  a2 1e      ldx #$1e         	LDX	#$1E			; error code $1E ("Can't continue" error)
.958e  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.9591                              lab_166c
.9591  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.9593  20 14 af   jsr $af14        	JSR	LAB_IRQ		; set IRQ flags
.9596  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.9598  20 17 af   jsr $af17        	JSR	LAB_NMI		; set NMI flags
.959b  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.959d  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.959f  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.95a1  a5 89      lda $89          	LDA	Blinel		; get break line low byte
.95a3  a4 8a      ldy $8a          	LDY	Blineh		; get break line high byte
.95a5  85 87      sta $87          	STA	Clinel		; set current line low byte
.95a7  84 88      sty $88          	STY	Clineh		; set current line high byte
.95a9  60         rts              	RTS
.95aa                              lab_run
.95aa  d0 03      bne $95af        	BNE	LAB_1696		; branch if RUN n
.95ac  4c 65 93   jmp $9365        	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
.95af                              lab_1696
.95af  20 72 93   jsr $9372        	JSR	LAB_147A		; go do "CLEAR"
.95b2  f0 2e      beq $95e2        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
.95b4                              lab_do
.95b4  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for DO
.95b6  20 03 91   jsr $9103        	JSR	LAB_1212		; check room on stack for A bytes
.95b9  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.95bb  48         pha              	PHA				; push on stack
.95bc  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.95be  48         pha              	PHA				; push on stack
.95bf  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.95c1  48         pha              	PHA				; push on stack
.95c2  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.95c4  48         pha              	PHA				; push on stack
.95c5  a9 9d      lda #$9d         	LDA	#TK_DO		; token for DO
.95c7  48         pha              	PHA				; push on stack
.95c8  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.95cb  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; go do interpreter inner loop
.95ce                              lab_gosub
.95ce  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.95d0  20 03 91   jsr $9103        	JSR	LAB_1212		; check room on stack for A bytes
.95d3  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.95d5  48         pha              	PHA				; push on stack
.95d6  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.95d8  48         pha              	PHA				; push on stack
.95d9  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.95db  48         pha              	PHA				; push on stack
.95dc  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.95de  48         pha              	PHA				; push on stack
.95df  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.95e1  48         pha              	PHA				; push on stack
.95e2                              lab_16b0
.95e2  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.95e5  20 eb 95   jsr $95eb        	JSR	LAB_GOTO		; perform GOTO n
.95e8  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; go do interpreter inner loop
.95eb                              lab_goto
.95eb  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.95ee  20 a0 96   jsr $96a0        	JSR	LAB_SNBL		; scan for next BASIC line
.95f1  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.95f3  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.95f5  b0 0b      bcs $9602        	BCS	LAB_16D0		; branch if >= (start search from beginning)
.95f7  98         tya              	TYA				; else copy line index to A
.95f8  38         sec              	SEC				; set carry (+1)
.95f9  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.95fb  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.95fd  90 07      bcc $9606        	BCC	LAB_16D4		; branch if no overflow to high byte
.95ff  e8         inx              	INX				; increment high byte
.9600  b0 04      bcs $9606        	BCS	LAB_16D4		; branch always (can never be carry)
.9602                              lab_16d0
.9602  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.9604  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.9606                              lab_16d4
.9606  20 28 93   jsr $9328        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.9609  90 67      bcc $9672        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
.960b  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.960d  e9 01      sbc #$01         	SBC	#$01			; -1
.960f  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.9611  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.9613  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.9615  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.9617                              lab_16e5
.9617  60         rts              	RTS
.9618                              lab_donok
.9618  a2 22      ldx #$22         	LDX	#$22			; error code $22 ("LOOP without DO" error)
.961a  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.961d                              lab_loop
.961d  a8         tay              	TAY				; save following token
.961e  ba         tsx              	TSX				; copy stack pointer
.961f  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get token byte from stack
.9622  c9 9d      cmp #$9d         	CMP	#TK_DO		; compare with DO token
.9624  d0 f2      bne $9618        	BNE	LAB_DONOK		; branch if no matching DO
.9626  e8         inx              	INX				; dump calling routine return address
.9627  e8         inx              	INX				; dump calling routine return address
.9628  9a         txs              	TXS				; correct stack
.9629  98         tya              	TYA				; get saved following token back
.962a  f0 20      beq $964c        	BEQ	LoopAlways		; if no following token loop forever
.962c  c9 3a      cmp #$3a         	CMP	#":"			; could be ":"
.962e  f0 1c      beq $964c        	BEQ	LoopAlways		; if :... loop forever
.9630  e9 b4      sbc #$b4         	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
.9632  aa         tax              	TAX				; copy to X (if it was UNTIL then Y will be correct)
.9633  f0 04      beq $9639        	BEQ	DoRest		; branch if was UNTIL
.9635  ca         dex              	DEX				; decrement result
.9636  d0 62      bne $969a        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
.9638  ca         dex              	DEX				; set invert result byte
.9639                              dorest
.9639  86 98      stx $98          	STX	Frnxth		; save invert result byte
.963b  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.963e  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate expression
.9641  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9643  f0 02      beq $9647        	BEQ	DoCmp			; if =0 go do straight compare
.9645  a9 ff      lda #$ff         	LDA	#$FF			; else set all bits
.9647                              docmp
.9647  ba         tsx              	TSX				; copy stack pointer
.9648  45 98      eor $98          	EOR	Frnxth		; EOR with invert byte
.964a  d0 1a      bne $9666        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
.964c                              loopalways
.964c  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get current line low byte
.964f  85 87      sta $87          	STA	Clinel		; save current line low byte
.9651  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get current line high byte
.9654  85 88      sta $88          	STA	Clineh		; save current line high byte
.9656  bd 04 01   lda $0104,x      	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
.9659  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.965b  bd 05 01   lda $0105,x      	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
.965e  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.9660  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9663  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; go do interpreter inner loop
.9666                              loopdone
.9666  e8         inx              	INX				; dump DO token
.9667  e8         inx              	INX				; dump current line low byte
.9668  e8         inx              	INX				; dump current line high byte
.9669  e8         inx              	INX				; dump BASIC execute pointer low byte
.966a  e8         inx              	INX				; dump BASIC execute pointer high byte
.966b  9a         txs              	TXS				; correct stack
.966c  4c 8c 96   jmp $968c        	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
.966f                              lab_16f4
.966f  a2 04      ldx #$04         	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)

>9671  2c                          	.byte	$2C			; makes next line BIT LAB_0EA2
.9672                              lab_16f7

.9672  a2 0e      ldx #$0e         	LDX	#$0E			; error code $0E ("Undefined statement" error)
.9674  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.9677                              lab_return
.9677  d0 9e      bne $9617        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
.9679                              lab_16e8
.9679  68         pla              	PLA				; dump calling routine return address
.967a  68         pla              	PLA				; dump calling routine return address
.967b  68         pla              	PLA				; pull token
.967c  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.967e  d0 ef      bne $966f        	BNE	LAB_16F4		; branch if no matching GOSUB
.9680                              lab_16ff
.9680  68         pla              	PLA				; pull current line low byte
.9681  85 87      sta $87          	STA	Clinel		; save current line low byte
.9683  68         pla              	PLA				; pull current line high byte
.9684  85 88      sta $88          	STA	Clineh		; save current line high byte
.9686  68         pla              	PLA				; pull BASIC execute pointer low byte
.9687  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.9689  68         pla              	PLA				; pull BASIC execute pointer high byte
.968a  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.968c                              lab_data
.968c  20 9d 96   jsr $969d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.968f                              lab_170f
.968f  98         tya              	TYA				; copy index to A
.9690  18         clc              	CLC				; clear carry for add
.9691  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.9693  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.9695  90 02      bcc $9699        	BCC	LAB_1719		; skip next if no carry
.9697  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.9699                              lab_1719
.9699  60         rts              	RTS
.969a                              lab_16fc
.969a  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.969d                              lab_snbs
.969d  a2 3a      ldx #$3a         	LDX	#":"			; set look for character = ":"

>969f  2c                          	.byte	$2C			; makes next line BIT $00A2
.96a0                              lab_snbl

.96a0  a2 00      ldx #$00         	LDX	#$00			; set alt search character = [EOL]
.96a2  a0 00      ldy #$00         	LDY	#$00			; set search character = [EOL]
.96a4  84 5c      sty $5c          	STY	Asrch			; store search character
.96a6                              lab_1725
.96a6  8a         txa              	TXA				; get alt search character
.96a7  45 5c      eor $5c          	EOR	Asrch			; toggle search character, effectively swap with $00
.96a9  85 5c      sta $5c          	STA	Asrch			; save swapped search character
.96ab                              lab_172d
.96ab  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.96ad  f0 ea      beq $9699        	BEQ	LAB_1719		; exit if null [EOL]
.96af  c5 5c      cmp $5c          	CMP	Asrch			; compare with search character
.96b1  f0 e6      beq $9699        	BEQ	LAB_1719		; exit if found
.96b3  c8         iny              	INY				; increment index
.96b4  c9 22      cmp #$22         	CMP	#$22			; compare current character with open quote
.96b6  d0 f3      bne $96ab        	BNE	LAB_172D		; if not open quote go get next character
.96b8  f0 ec      beq $96a6        	BEQ	LAB_1725		; if found go swap search character for alt search character
.96ba                              lab_if
.96ba  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate the expression
.96bd  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.96c0  c9 b1      cmp #$b1         	CMP	#TK_THEN		; compare with THEN token
.96c2  f0 11      beq $96d5        	BEQ	LAB_174B		; if it was THEN go do IF
.96c4  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with GOTO token
.96c6  d0 d2      bne $969a        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
.96c8  a6 c3      ldx $c3          	LDX	Bpntrl		; save the basic pointer low byte
.96ca  a4 c4      ldy $c4          	LDY	Bpntrh		; save the basic pointer high byte
.96cc  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.96cf  b0 c9      bcs $969a        	BCS	LAB_16FC		; if not numeric go do syntax error
.96d1  86 c3      stx $c3          	STX	Bpntrl		; restore the basic pointer low byte
.96d3  84 c4      sty $c4          	STY	Bpntrh		; restore the basic pointer high byte
.96d5                              lab_174b
.96d5  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.96d7  f0 1b      beq $96f4        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
.96d9  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; else increment and scan memory
.96dc  b0 03      bcs $96e1        	BCS	LAB_174D		; if not numeric go do var or keyword
.96de                              lab_174c
.96de  4c eb 95   jmp $95eb        	JMP	LAB_GOTO		; else was numeric so do GOTO n
.96e1                              lab_174d
.96e1  c9 90      cmp #$90         	CMP	#TK_RETURN		; compare the byte with the token for RETURN
.96e3  d0 03      bne $96e8        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
.96e5  4c fe 94   jmp $94fe        	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
.96e8                              lab_174g
.96e8  20 fc 94   jsr $94fc        	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
.96eb  a0 00      ldy #$00         	LDY	#$00			; clear the index
.96ed  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get the next BASIC byte
.96ef  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare it with the token for ELSE
.96f1  f0 99      beq $968c        	BEQ	LAB_DATA		; if ELSE ignore the following statement
.96f3  60         rts              	RTS				; else return to the interpreter inner loop
.96f4                              lab_174e
.96f4  a0 00      ldy #$00         	LDY	#$00			; clear the BASIC byte index
.96f6  a2 01      ldx #$01         	LDX	#$01			; clear the nesting depth
.96f8                              lab_1750
.96f8  c8         iny              	INY				; increment the BASIC byte index
.96f9  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get the next BASIC byte
.96fb  f0 0f      beq $970c        	BEQ	LAB_1753		; if EOL go add the pointer and return
.96fd  c9 8b      cmp #$8b         	CMP	#TK_IF		; compare the byte with the token for IF
.96ff  d0 03      bne $9704        	BNE	LAB_1752		; if not IF token skip the depth increment
.9701  e8         inx              	INX				; else increment the nesting depth ..
.9702  d0 f4      bne $96f8        	BNE	LAB_1750		; .. and continue looking
.9704                              lab_1752
.9704  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare the byte with the token for ELSE
.9706  d0 f0      bne $96f8        	BNE	LAB_1750		; if not ELSE token continue looking
.9708  ca         dex              	DEX				; was ELSE so decrement the nesting depth
.9709  d0 ed      bne $96f8        	BNE	LAB_1750		; loop if still nested
.970b  c8         iny              	INY				; increment the BASIC byte index past the ELSE
.970c                              lab_1753
.970c  98         tya              	TYA				; else copy line index to A
.970d  18         clc              	CLC				; clear carry for add
.970e  65 c3      adc $c3          	ADC	Bpntrl		; add the BASIC execute pointer low byte
.9710  85 c3      sta $c3          	STA	Bpntrl		; save the BASIC execute pointer low byte
.9712  90 02      bcc $9716        	BCC	LAB_1754		; branch if no overflow to high byte
.9714  e6 c4      inc $c4          	INC	Bpntrh		; else increment the BASIC execute pointer high byte
.9716                              lab_1754
.9716  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9719  90 c3      bcc $96de        	BCC	LAB_174C		; if numeric do GOTO n
.971b  4c fc 94   jmp $94fc        	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
.971e                              lab_rem
.971e  20 a0 96   jsr $96a0        	JSR	LAB_SNBL		; scan for next BASIC line
.9721  4c 8f 96   jmp $968f        	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
.9724                              lab_16fd
.9724  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.9727                              lab_on
.9727  c9 a9      cmp #$a9         	CMP	#TK_IRQ		; was it IRQ token ?
.9729  d0 03      bne $972e        	BNE	LAB_NOIN		; if not go check NMI
.972b  4c 38 af   jmp $af38        	JMP	LAB_SIRQ		; else go set-up IRQ
.972e                              lab_noin
.972e  c9 aa      cmp #$aa         	CMP	#TK_NMI		; was it NMI token ?
.9730  d0 03      bne $9735        	BNE	LAB_NONM		; if not go do normal ON command
.9732  4c 3c af   jmp $af3c        	JMP	LAB_SNMI		; else go set-up NMI
.9735                              lab_nonm
.9735  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter
.9738  48         pha              	PHA				; push GOTO/GOSUB token
.9739  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.973b  f0 04      beq $9741        	BEQ	LAB_176B		; branch if GOSUB
.973d  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with GOTO token
.973f                              lab_1767
.973f  d0 e3      bne $9724        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
.9741                              lab_176b
.9741  c6 af      dec $af          	DEC	FAC1_3		; decrement index (byte value)
.9743  d0 04      bne $9749        	BNE	LAB_1773		; branch if not zero
.9745  68         pla              	PLA				; pull GOTO/GOSUB token
.9746  4c fe 94   jmp $94fe        	JMP	LAB_1602		; go execute it
.9749                              lab_1773
.9749  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.974c  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
.974f  c9 2c      cmp #$2c         	CMP	#$2C			; compare next character with ","
.9751  f0 ee      beq $9741        	BEQ	LAB_176B		; loop if ","
.9753                              lab_177e
.9753  68         pla              	PLA				; else pull keyword token (run out of options)
.9754                              lab_177f
.9754  60         rts              	RTS
.9755                              lab_gfpn
.9755  a2 00      ldx #$00         	LDX	#$00			; clear reg
.9757  86 11      stx $11          	STX	Itempl		; clear temporary integer low byte
.9759                              lab_1785
.9759  86 12      stx $12          	STX	Itemph		; save temporary integer high byte
.975b  b0 f7      bcs $9754        	BCS	LAB_177F		; return if carry set, end of scan, character was
.975d  e0 19      cpx #$19         	CPX	#$19			; compare high byte with $19
.975f  a8         tay              	TAY				; ensure Zb = 0 if the branch is taken
.9760  b0 dd      bcs $973f        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
.9762  e9 2f      sbc #$2f         	SBC	#"0"-1		; subtract "0", $2F + carry, from byte
.9764  a8         tay              	TAY				; copy binary digit
.9765  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.9767  0a         asl              	ASL				; *2 low byte
.9768  26 12      rol $12          	ROL	Itemph		; *2 high byte
.976a  0a         asl              	ASL				; *2 low byte
.976b  26 12      rol $12          	ROL	Itemph		; *2 high byte, *4
.976d  65 11      adc $11          	ADC	Itempl		; + low byte, *5
.976f  85 11      sta $11          	STA	Itempl		; save it
.9771  8a         txa              	TXA				; get high byte copy to A
.9772  65 12      adc $12          	ADC	Itemph		; + high byte, *5
.9774  06 11      asl $11          	ASL	Itempl		; *2 low byte, *10d
.9776  2a         rol              	ROL				; *2 high byte, *10d
.9777  aa         tax              	TAX				; copy high byte back to X
.9778  98         tya              	TYA				; get binary digit back
.9779  65 11      adc $11          	ADC	Itempl		; add number low byte
.977b  85 11      sta $11          	STA	Itempl		; save number low byte
.977d  90 01      bcc $9780        	BCC	LAB_17B3		; if no overflow to high byte get next character
.977f  e8         inx              	INX				; else increment high byte
.9780                              lab_17b3
.9780  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.9783  4c 59 97   jmp $9759        	JMP	LAB_1785		; loop for next character
.9786                              lab_dec
.9786  a9 e4      lda #$e4         	LDA	#<LAB_2AFD		; set -1 pointer low byte

>9788  2c                          	.byte	$2C			; BIT abs to skip the LDA below
.9789                              lab_inc

.9789  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.978b                              lab_17b5
.978b  48         pha              	PHA				; save +/-1 pointer low byte
.978c                              lab_17b7
.978c  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var address
.978f  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.9791  30 1e      bmi $97b1        	BMI	IncrErr		; exit if string
.9793  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.9795  84 98      sty $98          	STY	Lvarph		; save var address high byte
.9797  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.979a  68         pla              	PLA				; get +/-1 pointer low byte
.979b  48         pha              	PHA				; save +/-1 pointer low byte
.979c  a0 b1      ldy #$b1         	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
.979e  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1
.97a1  20 a3 a8   jsr $a8a3        	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
.97a4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.97a7  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.97a9  d0 a8      bne $9753        	BNE	LAB_177E		; exit if not "," (either end or error)
.97ab  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.97ae  4c 8c 97   jmp $978c        	JMP	LAB_17B7		; go do next var
.97b1                              increrr
.97b1  4c dc 9a   jmp $9adc        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.97b4                              lab_let
.97b4  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var address
.97b7  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.97b9  84 98      sty $98          	STY	Lvarph		; save var address high byte
.97bb  a9 c2      lda #$c2         	LDA	#TK_EQUAL		; get = token
.97bd  20 f1 9b   jsr $9bf1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.97c0  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.97c2  48         pha              	PHA				; push data type flag
.97c3  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate expression
.97c6  68         pla              	PLA				; pop data type flag
.97c7  2a         rol              	ROL				; set carry if type = string
.97c8  20 d3 9a   jsr $9ad3        	JSR	LAB_CKTM		; type match check, set C for string
.97cb  d0 03      bne $97d0        	BNE	LAB_17D5		; branch if string
.97cd  4c a3 a8   jmp $a8a3        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.97d0                              lab_17d5
.97d0  a0 02      ldy #$02         	LDY	#$02			; set index to pointer high byte
.97d2  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string pointer high byte
.97d4  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.97d6  90 17      bcc $97ef        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.97d8  d0 07      bne $97e1        	BNE	LAB_17E6		; branch if >
.97da  88         dey              	DEY				; decrement index
.97db  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get pointer low byte
.97dd  c5 81      cmp $81          	CMP	Sstorl		; compare bottom of string space low byte
.97df  90 0e      bcc $97ef        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.97e1                              lab_17e6
.97e1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.97e3  c4 7c      cpy $7c          	CPY	Svarh			; compare start of vars high byte
.97e5  90 08      bcc $97ef        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
.97e7  d0 0d      bne $97f6        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
.97e9  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.97eb  c5 7b      cmp $7b          	CMP	Svarl			; compare start of vars low byte
.97ed  b0 07      bcs $97f6        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
.97ef                              lab_17f4
.97ef  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.97f1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.97f3  4c 0c 98   jmp $980c        	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
.97f6                              lab_17fb
.97f6  a0 00      ldy #$00         	LDY	#$00			; index to length
.97f8  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string length
.97fa  20 32 a1   jsr $a132        	JSR	LAB_209C		; copy string
.97fd  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.97ff  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.9801  85 b8      sta $b8          	STA	ssptr_l		; save descriptor pointer low byte
.9803  84 b9      sty $b9          	STY	ssptr_h		; save descriptor pointer high byte
.9805  20 11 a3   jsr $a311        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.9808  a9 ac      lda #$ac         	LDA	#<FAC1_e		; set descriptor pointer low byte
.980a  a0 00      ldy #$00         	LDY	#>FAC1_e		; get descriptor pointer high byte
.980c                              lab_1811
.980c  85 9e      sta $9e          	STA	des_2l		; save descriptor_2 pointer low byte
.980e  84 9f      sty $9f          	STY	des_2h		; save descriptor_2 pointer high byte
.9810  20 73 a3   jsr $a373        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.9813  a0 00      ldy #$00         	LDY	#$00			; index to length
.9815  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string length
.9817  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.9819  c8         iny              	INY				; index to string pointer low byte
.981a  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer low byte
.981c  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.981e  c8         iny              	INY				; index to string pointer high byte
.981f  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer high byte
.9821  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.9823  60         rts              	RTS
.9824                              lab_get
.9824  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var address
.9827  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.9829  84 98      sty $98          	STY	Lvarph		; save var address high byte
.982b  20 00 af   jsr $af00        	JSR	INGET			; get input byte
.982e  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.9830  30 07      bmi $9839        	BMI	LAB_GETS		; go get string character
.9832  a8         tay              	TAY				; copy character to Y
.9833  20 66 a0   jsr $a066        	JSR	LAB_1FD0		; convert Y to byte in FAC1
.9836  4c a3 a8   jmp $a8a3        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.9839                              lab_gets
.9839  48         pha              	PHA				; save character
.983a  a9 01      lda #$01         	LDA	#$01			; string is single byte
.983c  b0 01      bcs $983f        	BCS	LAB_IsByte		; branch if byte received
.983e  68         pla              	PLA				; string is null
.983f                              lab_isbyte
.983f  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.9842  f0 05      beq $9849        	BEQ	LAB_NoSt		; skip store if null string
.9844  68         pla              	PLA				; get character back
.9845  a0 00      ldy #$00         	LDY	#$00			; clear index
.9847  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.9849                              lab_nost
.9849  20 85 a1   jsr $a185        	JSR	LAB_RTST		; check for space on descriptor stack then put address
.984c  4c d0 97   jmp $97d0        	JMP	LAB_17D5		; do string LET and return
.984f                              lab_1829
.984f  20 d6 98   jsr $98d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.9852                              lab_182c
.9852  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9855                              lab_print
.9855  f0 3b      beq $9892        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
.9857                              lab_1831
.9857  c9 ac      cmp #$ac         	CMP	#TK_TAB		; compare with TAB( token
.9859  f0 56      beq $98b1        	BEQ	LAB_18A2		; go do TAB/SPC
.985b  c9 b0      cmp #$b0         	CMP	#TK_SPC		; compare with SPC( token
.985d  f0 52      beq $98b1        	BEQ	LAB_18A2		; go do TAB/SPC
.985f  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.9861  f0 38      beq $989b        	BEQ	LAB_188B		; go do move to next TAB mark
.9863  c9 3b      cmp #$3b         	CMP	#";"			; compare with ";"
.9865  f0 66      beq $98cd        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
.9867  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate expression
.986a  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.986c  30 e1      bmi $984f        	BMI	LAB_1829		; branch if string
.986e  20 95 aa   jsr $aa95        	JSR	LAB_296E		; convert FAC1 to string
.9871  20 44 a1   jsr $a144        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.9874  a0 00      ldy #$00         	LDY	#$00			; clear index
.9876  a5 0f      lda $0f          	LDA	TWidth		; get terminal width byte
.9878  f0 0a      beq $9884        	BEQ	LAB_185E		; skip check if zero
.987a  38         sec              	SEC				; set carry for subtract
.987b  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.987d  f1 ae      sbc ($ae),y      	SBC	(des_pl),Y		; subtract string length
.987f  b0 03      bcs $9884        	BCS	LAB_185E		; branch if less than terminal width
.9881  20 92 98   jsr $9892        	JSR	LAB_CRLF		; else print CR/LF
.9884                              lab_185e
.9884  20 d6 98   jsr $98d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.9887  f0 c9      beq $9852        	BEQ	LAB_182C		; always go continue processing line
.9889                              lab_1866
.9889  a9 00      lda #$00         	LDA	#$00			; clear byte
.988b  9d 0d 02   sta $020d,x      	STA	Ibuffs,X		; null terminate input
.988e  a2 0d      ldx #$0d         	LDX	#<Ibuffs		; set X to buffer start-1 low byte
.9890  a0 02      ldy #$02         	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
.9892                              lab_crlf
.9892  a9 0d      lda #$0d         	LDA	#$0D			; load [CR]
.9894  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.9897  a9 0a      lda #$0a         	LDA	#$0A			; load [LF]
.9899  d0 52      bne $98ed        	BNE	LAB_PRNA		; go print the character and return, branch always
.989b                              lab_188b
.989b  a5 0e      lda $0e          	LDA	TPos			; get terminal position
.989d  c5 10      cmp $10          	CMP	Iclim			; compare with input column limit
.989f  90 05      bcc $98a6        	BCC	LAB_1897		; branch if less
.98a1  20 92 98   jsr $9892        	JSR	LAB_CRLF		; else print CR/LF (next line)
.98a4  d0 27      bne $98cd        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
.98a6                              lab_1897
.98a6  38         sec              	SEC				; set carry for subtract
.98a7                              lab_1898
.98a7  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size
.98a9  b0 fc      bcs $98a7        	BCS	LAB_1898		; loop if result was +ve
.98ab  49 ff      eor #$ff         	EOR	#$FF			; complement it
.98ad  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.98af  d0 12      bne $98c3        	BNE	LAB_18B6		; always print A spaces (result is never $00)
.98b1                              lab_18a2
.98b1  48         pha              	PHA				; save token
.98b2  20 89 a4   jsr $a489        	JSR	LAB_SGBY		; scan and get byte parameter
.98b5  c9 29      cmp #$29         	CMP	#$29			; is next character )
.98b7  d0 7b      bne $9934        	BNE	LAB_1910		; if not do syntax error then warm start
.98b9  68         pla              	PLA				; get token back
.98ba  c9 ac      cmp #$ac         	CMP	#TK_TAB		; was it TAB ?
.98bc  d0 06      bne $98c4        	BNE	LAB_18B7		; if not go do SPC
.98be  8a         txa              	TXA				; copy integer value to A
.98bf  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.98c1  90 0a      bcc $98cd        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
.98c3                              lab_18b6
.98c3  aa         tax              	TAX				; copy result to X
.98c4                              lab_18b7
.98c4  8a         txa              	TXA				; set flags on size for SPC
.98c5  f0 06      beq $98cd        	BEQ	LAB_18BD		; branch if result was = $0, already here
.98c7                              lab_18ba
.98c7  20 e8 98   jsr $98e8        	JSR	LAB_18E0		; print " "
.98ca  ca         dex              	DEX				; decrement count
.98cb  d0 fa      bne $98c7        	BNE	LAB_18BA		; loop if not all done
.98cd                              lab_18bd
.98cd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.98d0  d0 85      bne $9857        	BNE	LAB_1831		; if more to print go do it
.98d2  60         rts              	RTS
.98d3                              lab_18c3
.98d3  20 44 a1   jsr $a144        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.98d6                              lab_18c6
.98d6  20 3e a3   jsr $a33e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.98d9  a0 00      ldy #$00         	LDY	#$00			; reset index
.98db  aa         tax              	TAX				; copy length to X
.98dc  f0 49      beq $9927        	BEQ	LAB_188C		; exit (RTS) if null string
.98de                              lab_18cd
.98de  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get next byte
.98e0  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.98e3  c8         iny              	INY				; increment index
.98e4  ca         dex              	DEX				; decrement count
.98e5  d0 f7      bne $98de        	BNE	LAB_18CD		; loop if not done yet
.98e7  60         rts              	RTS
.98e8                              lab_18e0
.98e8  a9 20      lda #$20         	LDA	#$20			; load " "

>98ea  2c                          	.byte	$2C			; change next line to BIT LAB_3FA9
.98eb                              lab_18e3

.98eb  a9 3f      lda #$3f         	LDA	#$3F			; load "?" character
.98ed                              lab_prna
.98ed  c9 20      cmp #$20         	CMP	#" "			; compare with " "
.98ef  90 19      bcc $990a        	BCC	LAB_18F9		; branch if less (non printing)
.98f1  48         pha              	PHA				; save the character
.98f2  a5 0f      lda $0f          	LDA	TWidth		; get terminal width
.98f4  d0 0a      bne $9900        	BNE	LAB_18F0		; branch if not zero (not infinite length)
.98f6  a5 0e      lda $0e          	LDA	TPos			; get position
.98f8  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
.98fa  d0 0b      bne $9907        	BNE	LAB_18F7		; skip reset if different
.98fc  85 0e      sta $0e          	STA	TPos			; else reset position
.98fe  f0 07      beq $9907        	BEQ	LAB_18F7		; go print character
.9900                              lab_18f0
.9900  c5 0e      cmp $0e          	CMP	TPos			; compare with terminal character position
.9902  d0 03      bne $9907        	BNE	LAB_18F7		; branch if not at end of line
.9904  20 92 98   jsr $9892        	JSR	LAB_CRLF		; else print CR/LF
.9907                              lab_18f7
.9907  e6 0e      inc $0e          	INC	TPos			; increment terminal position
.9909  68         pla              	PLA				; get character back
.990a                              lab_18f9
.990a  20 ed b0   jsr $b0ed        	JSR	V_OUTP		; output byte via output vector
.990d  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.990f  d0 14      bne $9925        	BNE	LAB_188A		; branch if not [CR]
.9911  86 78      stx $78          	STX	TempB			; save buffer index
.9913  a6 0d      ldx $0d          	LDX	Nullct		; get null count
.9915  f0 0a      beq $9921        	BEQ	LAB_1886		; branch if no nulls
.9917  a9 00      lda #$00         	LDA	#$00			; load [NULL]
.9919                              lab_1880
.9919  20 ed 98   jsr $98ed        	JSR	LAB_PRNA		; go print the character
.991c  ca         dex              	DEX				; decrement count
.991d  d0 fa      bne $9919        	BNE	LAB_1880		; loop if not all done
.991f  a9 0d      lda #$0d         	LDA	#$0D			; restore the character (and set the flags)
.9921                              lab_1886
.9921  86 0e      stx $0e          	STX	TPos			; clear terminal position (X always = zero when we get here)
.9923  a6 78      ldx $78          	LDX	TempB			; restore buffer index
.9925                              lab_188a
.9925  29 ff      and #$ff         	AND	#$FF			; set the flags
.9927                              lab_188c
.9927  60         rts              	RTS
.9928                              lab_1904
.9928  a5 62      lda $62          	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
.992a  10 0b      bpl $9937        	BPL	LAB_1913		; branch if INPUT (go do redo)
.992c  a5 8d      lda $8d          	LDA	Dlinel		; get current DATA line low byte
.992e  a4 8e      ldy $8e          	LDY	Dlineh		; get current DATA line high byte
.9930  85 87      sta $87          	STA	Clinel		; save current line low byte
.9932  84 88      sty $88          	STY	Clineh		; save current line high byte
.9934                              lab_1910
.9934  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.9937                              lab_1913
.9937  a9 1b      lda #$1b         	LDA	#<LAB_REDO		; point to redo message (low addr)
.9939  a0 b8      ldy #$b8         	LDY	#>LAB_REDO		; point to redo message (high addr)
.993b  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.993e  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.9940  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.9942  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.9944  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.9946  60         rts              	RTS
.9947                              lab_input
.9947  c9 22      cmp #$22         	CMP	#$22			; compare next byte with open quote
.9949  d0 0b      bne $9956        	BNE	LAB_1934		; branch if no prompt string
.994b  20 be 9b   jsr $9bbe        	JSR	LAB_1BC1		; print "..." string
.994e  a9 3b      lda #$3b         	LDA	#$3B			; load A with ";"
.9950  20 f1 9b   jsr $9bf1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.9953  20 d6 98   jsr $98d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.9956                              lab_1934
.9956  20 6a a0   jsr $a06a        	JSR	LAB_CKRN		; check not Direct, back here if ok
.9959  20 40 92   jsr $9240        	JSR	LAB_INLN		; print "? " and get BASIC input
.995c  a9 00      lda #$00         	LDA	#$00			; set mode = INPUT
.995e  cd 0d 02   cmp $020d        	CMP	Ibuffs		; test first byte in buffer
.9961  d0 0a      bne $996d        	BNE	LAB_1953		; branch if not null input
.9963  18         clc              	CLC				; was null input so clear carry to exit program
.9964  4c 2c 95   jmp $952c        	JMP	LAB_1647		; go do BREAK exit
.9967                              lab_read
.9967  a6 8f      ldx $8f          	LDX	Dptrl			; get DATA pointer low byte
.9969  a4 90      ldy $90          	LDY	Dptrh			; get DATA pointer high byte
.996b  a9 80      lda #$80         	LDA	#$80			; set mode = READ
.996d                              lab_1953
.996d  85 62      sta $62          	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
.996f  86 91      stx $91          	STX	Rdptrl		; save READ pointer low byte
.9971  84 92      sty $92          	STY	Rdptrh		; save READ pointer high byte
.9973                              lab_195b
.9973  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get (var) address
.9976  85 97      sta $97          	STA	Lvarpl		; save address low byte
.9978  84 98      sty $98          	STY	Lvarph		; save address high byte
.997a  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.997c  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.997e  85 11      sta $11          	STA	Itempl		; save as temporary integer low byte
.9980  84 12      sty $12          	STY	Itemph		; save as temporary integer high byte
.9982  a6 91      ldx $91          	LDX	Rdptrl		; get READ pointer low byte
.9984  a4 92      ldy $92          	LDY	Rdptrh		; get READ pointer high byte
.9986  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.9988  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.998a  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.998d  d0 11      bne $99a0        	BNE	LAB_1988		; branch if not null
.998f  24 62      bit $62          	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
.9991  30 65      bmi $99f8        	BMI	LAB_19DD		; branch if READ
.9993  20 eb 98   jsr $98eb        	JSR	LAB_18E3		; print "?" character (double ? for extended input)
.9996  20 40 92   jsr $9240        	JSR	LAB_INLN		; print "? " and get BASIC input
.9999  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.999b  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.999d                              lab_1985
.999d  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.99a0                              lab_1988
.99a0  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.99a2  10 24      bpl $99c8        	BPL	LAB_19B0		; branch if numeric
.99a4  85 5b      sta $5b          	STA	Srchc			; save search character
.99a6  c9 22      cmp #$22         	CMP	#$22			; was it " ?
.99a8  f0 07      beq $99b1        	BEQ	LAB_1999		; branch if so
.99aa  a9 3a      lda #$3a         	LDA	#":"			; else search character is ":"
.99ac  85 5b      sta $5b          	STA	Srchc			; set new search character
.99ae  a9 2c      lda #$2c         	LDA	#","			; other search character is ","
.99b0  18         clc              	CLC				; clear carry for add
.99b1                              lab_1999
.99b1  85 5c      sta $5c          	STA	Asrch			; set second search character
.99b3  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.99b5  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.99b7  69 00      adc #$00         	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
.99b9  90 01      bcc $99bc        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
.99bb  c8         iny              	INY				; else increment high byte
.99bc                              lab_19a4
.99bc  20 4a a1   jsr $a14a        	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
.99bf  20 cf a4   jsr $a4cf        	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
.99c2  20 d0 97   jsr $97d0        	JSR	LAB_17D5		; go do string LET
.99c5  4c ce 99   jmp $99ce        	JMP	LAB_19B6		; go check string terminator
.99c8                              lab_19b0
.99c8  20 a6 a9   jsr $a9a6        	JSR	LAB_2887		; get FAC1 from string
.99cb  20 a3 a8   jsr $a8a3        	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
.99ce                              lab_19b6
.99ce  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.99d1  f0 0a      beq $99dd        	BEQ	LAB_19C5		; branch if null (last entry)
.99d3  c9 2c      cmp #$2c         	CMP	#","			; else compare with ","
.99d5  f0 03      beq $99da        	BEQ	LAB_19C2		; branch if ","
.99d7  4c 28 99   jmp $9928        	JMP	LAB_1904		; else go handle bad input data
.99da                              lab_19c2
.99da  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.99dd                              lab_19c5
.99dd  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
.99df  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
.99e1  85 91      sta $91          	STA	Rdptrl		; save for now
.99e3  84 92      sty $92          	STY	Rdptrh		; save for now
.99e5  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
.99e7  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
.99e9  85 c3      sta $c3          	STA	Bpntrl		; set BASIC execute pointer low byte
.99eb  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.99ed  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.99f0  f0 2c      beq $9a1e        	BEQ	LAB_1A03		; if null go do extra ignored message
.99f2  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
.99f5  4c 73 99   jmp $9973        	JMP	LAB_195B		; go INPUT next variable from list
.99f8                              lab_19dd
.99f8  20 9d 96   jsr $969d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.99fb  c8         iny              	INY				; increment index
.99fc  aa         tax              	TAX				; copy character ([:] or [EOL])
.99fd  d0 12      bne $9a11        	BNE	LAB_19F6		; branch if [:]
.99ff  a2 06      ldx #$06         	LDX	#$06			; set for "Out of DATA" error
.9a01  c8         iny              	INY				; increment index, now points to next line pointer high byte
.9a02  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.9a04  f0 73      beq $9a79        	BEQ	LAB_1A54		; branch if end (eventually does error X)
.9a06  c8         iny              	INY				; increment index
.9a07  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # low byte
.9a09  85 8d      sta $8d          	STA	Dlinel		; save current DATA line low byte
.9a0b  c8         iny              	INY				; increment index
.9a0c  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # high byte
.9a0e  c8         iny              	INY				; increment index
.9a0f  85 8e      sta $8e          	STA	Dlineh		; save current DATA line high byte
.9a11                              lab_19f6
.9a11  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get byte
.9a13  c8         iny              	INY				; increment index
.9a14  aa         tax              	TAX				; copy to X
.9a15  20 8f 96   jsr $968f        	JSR	LAB_170F		; set BASIC execute pointer
.9a18  e0 83      cpx #$83         	CPX	#TK_DATA		; compare with "DATA" token
.9a1a  f0 81      beq $999d        	BEQ	LAB_1985		; was "DATA" so go do next READ
.9a1c  d0 da      bne $99f8        	BNE	LAB_19DD		; go find next statement if not "DATA"
.9a1e                              lab_1a03
.9a1e  a5 91      lda $91          	LDA	Rdptrl		; get temp READ pointer low byte
.9a20  a4 92      ldy $92          	LDY	Rdptrh		; get temp READ pointer high byte
.9a22  a6 62      ldx $62          	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
.9a24  10 03      bpl $9a29        	BPL	LAB_1A0E		; branch if INPUT
.9a26  4c 4e 95   jmp $954e        	JMP	LAB_1624		; save AY as DATA pointer and return
.9a29                              lab_1a0e
.9a29  a0 00      ldy #$00         	LDY	#$00			; clear index
.9a2b  b1 91      lda ($91),y      	LDA	(Rdptrl),Y		; get next byte
.9a2d  d0 01      bne $9a30        	BNE	LAB_1A1B		; error if not end of INPUT
.9a2f  60         rts              	RTS
.9a30                              lab_1a1b
.9a30  a9 0a      lda #$0a         	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
.9a32  a0 b8      ldy #$b8         	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
.9a34  4c d3 98   jmp $98d3        	JMP	LAB_18C3		; print null terminated string from memory and return
.9a37                              lab_11a1
.9a37  ba         tsx              	TSX				; copy stack pointer
.9a38  e8         inx              	INX				; +1 pass return address
.9a39  e8         inx              	INX				; +2 pass return address
.9a3a  e8         inx              	INX				; +3 pass calling routine return address
.9a3b  e8         inx              	INX				; +4 pass calling routine return address
.9a3c                              lab_11a6
.9a3c  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get token byte from stack
.9a3f  c9 81      cmp #$81         	CMP	#TK_FOR		; is it FOR token
.9a41  d0 21      bne $9a64        	BNE	LAB_11CE		; exit if not FOR token
.9a43  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.9a45  d0 0a      bne $9a51        	BNE	LAB_11BB		; branch if not null
.9a47  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
.9a4a  85 97      sta $97          	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
.9a4c  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
.9a4f  85 98      sta $98          	STA	Frnxth		; save var pointer for FOR/NEXT high byte
.9a51                              lab_11bb
.9a51  dd 03 01   cmp $0103,x      	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
.9a54  d0 07      bne $9a5d        	BNE	LAB_11C7		; branch if no match
.9a56  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.9a58  dd 02 01   cmp $0102,x      	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
.9a5b  f0 07      beq $9a64        	BEQ	LAB_11CE		; exit if match found
.9a5d                              lab_11c7
.9a5d  8a         txa              	TXA				; copy index
.9a5e  18         clc              	CLC				; clear carry for add
.9a5f  69 10      adc #$10         	ADC	#$10			; add FOR stack use size
.9a61  aa         tax              	TAX				; copy back to index
.9a62  d0 d8      bne $9a3c        	BNE	LAB_11A6		; loop if not at start of stack
.9a64                              lab_11ce
.9a64  60         rts              	RTS
.9a65                              lab_next
.9a65  d0 04      bne $9a6b        	BNE	LAB_1A46		; branch if NEXT var
.9a67  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.9a69  f0 03      beq $9a6e        	BEQ	LAB_1A49		; branch always (no variable to search for)
.9a6b                              lab_1a46
.9a6b  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get variable address
.9a6e                              lab_1a49
.9a6e  85 97      sta $97          	STA	Frnxtl		; store variable pointer low byte
.9a70  84 98      sty $98          	STY	Frnxth		; store variable pointer high byte
.9a72  20 37 9a   jsr $9a37        	JSR	LAB_11A1		; search the stack for FOR activity
.9a75  f0 04      beq $9a7b        	BEQ	LAB_1A56		; branch if found
.9a77  a2 00      ldx #$00         	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
.9a79                              lab_1a54
.9a79  f0 63      beq $9ade        	BEQ	LAB_1ABE		; do error #X, then warm start
.9a7b                              lab_1a56
.9a7b  9a         txs              	TXS				; set stack pointer, X set by search, dumps return addresses
.9a7c  8a         txa              	TXA				; copy stack pointer
.9a7d  38         sec              	SEC				; set carry for subtract
.9a7e  e9 f7      sbc #$f7         	SBC	#$F7			; point to TO var
.9a80  85 73      sta $73          	STA	ut2_pl		; save pointer to TO var for compare
.9a82  69 fb      adc #$fb         	ADC	#$FB			; point to STEP var
.9a84  a0 01      ldy #$01         	LDY	#>LAB_STAK		; point to stack page high byte
.9a86  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
.9a89  ba         tsx              	TSX				; get stack pointer back
.9a8a  bd 08 01   lda $0108,x      	LDA	LAB_STAK+8,X	; get step sign
.9a8d  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.9a8f  a5 97      lda $97          	LDA	Frnxtl		; get FOR variable pointer low byte
.9a91  a4 98      ldy $98          	LDY	Frnxth		; get FOR variable pointer high byte
.9a93  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (FOR variable) to FAC1
.9a96  20 a3 a8   jsr $a8a3        	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
.9a99  a0 01      ldy #$01         	LDY	#>LAB_STAK		; point to stack page high byte
.9a9b  20 19 a9   jsr $a919        	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
.9a9e  ba         tsx              	TSX				; get stack pointer back
.9a9f  dd 08 01   cmp $0108,x      	CMP	LAB_STAK+8,X	; compare step sign
.9aa2  f0 17      beq $9abb        	BEQ	LAB_1A9B		; branch if = (loop complete)
.9aa4  bd 0d 01   lda $010d,x      	LDA	LAB_STAK+$0D,X	; get FOR line low byte
.9aa7  85 87      sta $87          	STA	Clinel		; save current line low byte
.9aa9  bd 0e 01   lda $010e,x      	LDA	LAB_STAK+$0E,X	; get FOR line high byte
.9aac  85 88      sta $88          	STA	Clineh		; save current line high byte
.9aae  bd 10 01   lda $0110,x      	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
.9ab1  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.9ab3  bd 0f 01   lda $010f,x      	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
.9ab6  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.9ab8                              lab_1a98
.9ab8  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; go do interpreter inner loop
.9abb                              lab_1a9b
.9abb  8a         txa              	TXA				; stack copy to A
.9abc  69 0f      adc #$0f         	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
.9abe  aa         tax              	TAX				; copy back to index
.9abf  9a         txs              	TXS				; copy to stack pointer
.9ac0  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9ac3  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.9ac5  d0 f1      bne $9ab8        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
.9ac7  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; else increment and scan memory
.9aca  20 6b 9a   jsr $9a6b        	JSR	LAB_1A46		; do NEXT (var)
.9acd                              lab_evnm
.9acd  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate expression
.9ad0                              lab_ctnm
.9ad0  18         clc              	CLC				; destination is numeric

>9ad1  24                          	.byte	$24			; makes next line BIT $38
.9ad2                              lab_ctst

.9ad2  38         sec              	SEC				; required type is string
.9ad3                              lab_cktm
.9ad3  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.9ad5  30 03      bmi $9ada        	BMI	LAB_1ABA		; branch if data type is string
.9ad7  b0 03      bcs $9adc        	BCS	LAB_1ABC		; if required type is string do type mismatch error
.9ad9                              lab_1ab9
.9ad9  60         rts              	RTS
.9ada                              lab_1aba
.9ada  b0 fd      bcs $9ad9        	BCS	LAB_1AB9		; exit if required type is string
.9adc                              lab_1abc
.9adc  a2 18      ldx #$18         	LDX	#$18			; error code $18 ("Type mismatch" error)
.9ade                              lab_1abe
.9ade  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.9ae1                              lab_evex
.9ae1  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.9ae3  d0 02      bne $9ae7        	BNE	LAB_1AC7		; skip next if not zero
.9ae5  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.9ae7                              lab_1ac7
.9ae7  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.9ae9                              lab_evez
.9ae9  a9 00      lda #$00         	LDA	#$00			; set null precedence (flag done)
.9aeb                              lab_1acc
.9aeb  48         pha              	PHA				; push precedence byte
.9aec  a9 02      lda #$02         	LDA	#$02			; 2 bytes
.9aee  20 03 91   jsr $9103        	JSR	LAB_1212		; check room on stack for A bytes
.9af1  20 cd 9b   jsr $9bcd        	JSR	LAB_GVAL		; get value from line
.9af4  a9 00      lda #$00         	LDA	#$00			; clear A
.9af6  85 9b      sta $9b          	STA	comp_f		; clear compare function flag
.9af8                              lab_1adb
.9af8  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9afb                              lab_1ade
.9afb  38         sec              	SEC				; set carry for subtract
.9afc  e9 c1      sbc #$c1         	SBC	#TK_GT		; subtract token for > (lowest comparison function)
.9afe  90 17      bcc $9b17        	BCC	LAB_1AFA		; branch if < TK_GT
.9b00  c9 03      cmp #$03         	CMP	#$03			; compare with ">" to "<" tokens
.9b02  b0 13      bcs $9b17        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
.9b04  c9 01      cmp #$01         	CMP	#$01			; compare with token for =
.9b06  2a         rol              	ROL				; *2, b0 = carry (=1 if token was = or <)
.9b07  49 01      eor #$01         	EOR	#$01			; toggle b0
.9b09  45 9b      eor $9b          	EOR	comp_f		; EOR with compare function flag bits
.9b0b  c5 9b      cmp $9b          	CMP	comp_f		; compare with compare function flag
.9b0d  90 67      bcc $9b76        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
.9b0f  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.9b11  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.9b14  4c fb 9a   jmp $9afb        	JMP	LAB_1ADE		; go do next character
.9b17                              lab_1afa
.9b17  a6 9b      ldx $9b          	LDX	comp_f		; get compare function flag
.9b19  d0 2c      bne $9b47        	BNE	LAB_1B2A		; branch if compare function
.9b1b  b0 79      bcs $9b96        	BCS	LAB_1B78		; go do functions
.9b1d  69 0a      adc #$0a         	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
.9b1f  90 75      bcc $9b96        	BCC	LAB_1B78		; branch if < + operator
.9b21  d0 07      bne $9b2a        	BNE	LAB_1B0B		; branch if not + token
.9b23  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.9b25  10 03      bpl $9b2a        	BPL	LAB_1B0B		; branch if not string
.9b27  4c d4 a2   jmp $a2d4        	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
.9b2a                              lab_1b0b
.9b2a  85 71      sta $71          	STA	ut1_pl		; save it
.9b2c  0a         asl              	ASL				; *2
.9b2d  65 71      adc $71          	ADC	ut1_pl		; *3
.9b2f  a8         tay              	TAY				; copy to index
.9b30                              lab_1b13
.9b30  68         pla              	PLA				; pull previous precedence
.9b31  d9 eb b2   cmp $b2eb,y      	CMP	LAB_OPPT,Y		; compare with precedence byte
.9b34  b0 65      bcs $9b9b        	BCS	LAB_1B7D		; branch if A >=
.9b36  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.9b39                              lab_1b1c
.9b39  48         pha              	PHA				; save precedence
.9b3a                              lab_1b1d
.9b3a  20 62 9b   jsr $9b62        	JSR	LAB_1B43		; get vector, execute function then continue evaluation
.9b3d  68         pla              	PLA				; restore precedence
.9b3e  a4 99      ldy $99          	LDY	prstk			; get precedence stacked flag
.9b40  10 19      bpl $9b5b        	BPL	LAB_1B3C		; branch if stacked values
.9b42  aa         tax              	TAX				; copy precedence (set flags)
.9b43  f0 76      beq $9bbb        	BEQ	LAB_1B9D		; exit if done
.9b45  d0 5d      bne $9ba4        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
.9b47                              lab_1b2a
.9b47  26 5f      rol $5f          	ROL	Dtypef		; shift data type flag into Cb
.9b49  8a         txa              	TXA				; copy compare function flag
.9b4a  85 5f      sta $5f          	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
.9b4c  2a         rol              	ROL				; shift data type into compare function byte b0
.9b4d  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.9b4f  d0 02      bne $9b53        	BNE	LAB_1B34		; branch if no underflow
.9b51  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.9b53                              lab_1b34
.9b53  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.9b55  a0 24      ldy #$24         	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
.9b57  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.9b59  d0 d5      bne $9b30        	BNE	LAB_1B13		; branch always
.9b5b                              lab_1b3c
.9b5b  d9 eb b2   cmp $b2eb,y      	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
.9b5e  b0 44      bcs $9ba4        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
.9b60  90 d7      bcc $9b39        	BCC	LAB_1B1C		; branch always
.9b62                              lab_1b43
.9b62  b9 ed b2   lda $b2ed,y      	LDA	LAB_OPPT+2,Y	; get function vector high byte
.9b65  48         pha              	PHA				; onto stack
.9b66  b9 ec b2   lda $b2ec,y      	LDA	LAB_OPPT+1,Y	; get function vector low byte
.9b69  48         pha              	PHA				; onto stack
.9b6a  20 79 9b   jsr $9b79        	JSR	LAB_1B5B		; function will return here, then the next RTS will call
.9b6d  a5 9b      lda $9b          	LDA	comp_f		; get compare function flag
.9b6f  48         pha              	PHA				; push compare evaluation byte
.9b70  b9 eb b2   lda $b2eb,y      	LDA	LAB_OPPT,Y		; get precedence byte
.9b73  4c eb 9a   jmp $9aeb        	JMP	LAB_1ACC		; continue evaluating expression
.9b76                              lab_1b53
.9b76  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.9b79                              lab_1b5b
.9b79  68         pla              	PLA				; get return addr low byte
.9b7a  85 71      sta $71          	STA	ut1_pl		; save it
.9b7c  e6 71      inc $71          	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
.9b7e  68         pla              	PLA				; get return addr high byte
.9b7f  85 72      sta $72          	STA	ut1_ph		; save it
.9b81  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.9b83  48         pha              	PHA				; push sign
.9b84                              lab_1b66
.9b84  20 d9 a8   jsr $a8d9        	JSR	LAB_27BA		; round FAC1
.9b87  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.9b89  48         pha              	PHA				; push on stack
.9b8a  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9b8c  48         pha              	PHA				; push on stack
.9b8d  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.9b8f  48         pha              	PHA				; push on stack
.9b90  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9b92  48         pha              	PHA				; push on stack
.9b93  6c 71 00   jmp ($0071)      	JMP	(ut1_pl)		; return, sort of
.9b96                              lab_1b78
.9b96  a0 ff      ldy #$ff         	LDY	#$FF			; flag function
.9b98  68         pla              	PLA				; pull precedence byte
.9b99                              lab_1b7b
.9b99  f0 20      beq $9bbb        	BEQ	LAB_1B9D		; exit if done
.9b9b                              lab_1b7d
.9b9b  c9 64      cmp #$64         	CMP	#$64			; compare previous precedence with $64
.9b9d  f0 03      beq $9ba2        	BEQ	LAB_1B84		; branch if was $64 (< function)
.9b9f  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.9ba2                              lab_1b84
.9ba2  84 99      sty $99          	STY	prstk			; save precedence stacked flag
.9ba4                              lab_1b86
.9ba4  68         pla              	PLA				; pop byte
.9ba5  4a         lsr              	LSR				; shift out comparison evaluation lowest bit
.9ba6  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.9ba8  68         pla              	PLA				; pop exponent
.9ba9  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.9bab  68         pla              	PLA				; pop mantissa1
.9bac  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.9bae  68         pla              	PLA				; pop mantissa2
.9baf  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.9bb1  68         pla              	PLA				; pop mantissa3
.9bb2  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.9bb4  68         pla              	PLA				; pop sign
.9bb5  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.9bb7  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.9bb9  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.9bbb                              lab_1b9d
.9bbb  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9bbd  60         rts              	RTS
.9bbe                              lab_1bc1
.9bbe  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.9bc0  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.9bc2  69 00      adc #$00         	ADC	#$00			; add carry to low byte
.9bc4  90 01      bcc $9bc7        	BCC	LAB_1BCA		; branch if no overflow
.9bc6  c8         iny              	INY				; increment high byte
.9bc7                              lab_1bca
.9bc7  20 44 a1   jsr $a144        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.9bca  4c cf a4   jmp $a4cf        	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
.9bcd                              lab_gval
.9bcd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.9bd0  b0 03      bcs $9bd5        	BCS	LAB_1BAC		; branch if not numeric character
.9bd2                              lab_1ba9
.9bd2  4c a6 a9   jmp $a9a6        	JMP	LAB_2887		; get FAC1 from string and return
.9bd5                              lab_1bac
.9bd5  aa         tax              	TAX				; set the flags
.9bd6  30 2f      bmi $9c07        	BMI	LAB_1BD0		; if -ve go test token values
.9bd8  c9 24      cmp #$24         	CMP	#"$"			; compare with "$"
.9bda  f0 f6      beq $9bd2        	BEQ	LAB_1BA9		; branch if "$", hex number
.9bdc  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.9bde  f0 f2      beq $9bd2        	BEQ	LAB_1BA9		; branch if "%", binary number
.9be0  c9 2e      cmp #$2e         	CMP	#"."			; compare with "."
.9be2  f0 ee      beq $9bd2        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
.9be4  c9 22      cmp #$22         	CMP	#$22			; compare with "
.9be6  f0 d6      beq $9bbe        	BEQ	LAB_1BC1		; branch if open quote
.9be8  c9 28      cmp #$28         	CMP	#"("			; compare with "("
.9bea  d0 4f      bne $9c3b        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
.9bec                              lab_1bf7
.9bec  20 e9 9a   jsr $9ae9        	JSR	LAB_EVEZ		; evaluate expression, no decrement
.9bef                              lab_1bfb
.9bef  a9 29      lda #$29         	LDA	#$29			; load A with ")"
.9bf1                              lab_scca
.9bf1  a0 00      ldy #$00         	LDY	#$00			; clear index
.9bf3  d1 c3      cmp ($c3),y      	CMP	(Bpntrl),Y		; check next byte is = A
.9bf5  d0 0b      bne $9c02        	BNE	LAB_SNER		; if not do syntax error then warm start
.9bf7  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; increment and scan memory then return
.9bfa                              lab_1bfe
.9bfa  a9 28      lda #$28         	LDA	#$28			; load A with "("
.9bfc  d0 f3      bne $9bf1        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.9bfe                              lab_1c01
.9bfe  a9 2c      lda #$2c         	LDA	#$2C			; load A with ","
.9c00  d0 ef      bne $9bf1        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.9c02                              lab_sner
.9c02  a2 02      ldx #$02         	LDX	#$02			; error code $02 ("Syntax" error)
.9c04  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.9c07                              lab_1bd0
.9c07  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.9c09  f0 29      beq $9c34        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
.9c0b  c9 b7      cmp #$b7         	CMP	#TK_PLUS		; compare with token for +
.9c0d  f0 be      beq $9bcd        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
.9c0f  c9 b2      cmp #$b2         	CMP	#TK_NOT		; compare with token for NOT
.9c11  d0 13      bne $9c26        	BNE	LAB_1BE7		; branch if not token for NOT
.9c13  a0 21      ldy #$21         	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
.9c15  d0 1f      bne $9c36        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
.9c17                              lab_equal
.9c17  20 a6 9e   jsr $9ea6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.9c1a  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.9c1c  49 ff      eor #$ff         	EOR	#$FF			; invert it
.9c1e  a8         tay              	TAY				; copy it
.9c1f  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9c21  49 ff      eor #$ff         	EOR	#$FF			; invert it
.9c23  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9c26                              lab_1be7
.9c26  c9 af      cmp #$af         	CMP	#TK_FN		; compare with token for FN
.9c28  d0 03      bne $9c2d        	BNE	LAB_1BEE		; branch if not token for FN
.9c2a  4c b4 a0   jmp $a0b4        	JMP	LAB_201E		; go evaluate FNx
.9c2d                              lab_1bee
.9c2d  e9 c4      sbc #$c4         	SBC	#TK_SGN		; subtract with token for SGN
.9c2f  b0 19      bcs $9c4a        	BCS	LAB_1C27		; if a function token go do it
.9c31  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; else do syntax error
.9c34                              lab_1c11
.9c34  a0 1e      ldy #$1e         	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
.9c36                              lab_1c13
.9c36  68         pla              	PLA				; dump return address low byte
.9c37  68         pla              	PLA				; dump return address high byte
.9c38  4c 3a 9b   jmp $9b3a        	JMP	LAB_1B1D		; execute function then continue evaluation
.9c3b                              lab_1c18
.9c3b  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get (var) address
.9c3e  85 ae      sta $ae          	STA	FAC1_2		; save address low byte in FAC1 mantissa2
.9c40  84 af      sty $af          	STY	FAC1_3		; save address high byte in FAC1 mantissa3
.9c42  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.9c44  30 03      bmi $9c49        	BMI	LAB_1C25		; if string then return (does RTS)
.9c46                              lab_1c24
.9c46  4c 7d a8   jmp $a87d        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
.9c49                              lab_1c25
.9c49  60         rts              	RTS
.9c4a                              lab_1c27
.9c4a  0a         asl              	ASL				; *2 (2 bytes per function address)
.9c4b  a8         tay              	TAY				; copy to index
.9c4c  b9 a6 b2   lda $b2a6,y      	LDA	LAB_FTBM,Y		; get function jump vector high byte
.9c4f  48         pha              	PHA				; push functions jump vector high byte
.9c50  b9 a5 b2   lda $b2a5,y      	LDA	LAB_FTBL,Y		; get function jump vector low byte
.9c53  48         pha              	PHA				; push functions jump vector low byte
.9c54  b9 60 b2   lda $b260,y      	LDA	LAB_FTPM,Y		; get function pre process vector high byte
.9c57  f0 05      beq $9c5e        	BEQ	LAB_1C56		; skip pre process if null vector
.9c59  48         pha              	PHA				; push functions pre process vector high byte
.9c5a  b9 5f b2   lda $b25f,y      	LDA	LAB_FTPL,Y		; get function pre process vector low byte
.9c5d  48         pha              	PHA				; push functions pre process vector low byte
.9c5e                              lab_1c56
.9c5e  60         rts              	RTS				; do function, or pre process, call
.9c5f                              lab_ppfs
.9c5f  20 ec 9b   jsr $9bec        	JSR	LAB_1BF7		; process expression in parenthesis
.9c62  4c d2 9a   jmp $9ad2        	JMP	LAB_CTST		; check if source is string then do function,
.9c65                              lab_ppfn
.9c65  20 ec 9b   jsr $9bec        	JSR	LAB_1BF7		; process expression in parenthesis
.9c68  4c d0 9a   jmp $9ad0        	JMP	LAB_CTNM		; check if source is numeric then do function,
.9c6b                              lab_ppbi
.9c6b  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.9c6d  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; increment and scan memory then do function
.9c70                              lab_lrms
.9c70  20 e9 9a   jsr $9ae9        	JSR	LAB_EVEZ		; evaluate (should be string) expression
.9c73  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.9c76  20 d2 9a   jsr $9ad2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.9c79  68         pla              	PLA				; get function jump vector low byte
.9c7a  aa         tax              	TAX				; save functions jump vector low byte
.9c7b  68         pla              	PLA				; get function jump vector high byte
.9c7c  a8         tay              	TAY				; save functions jump vector high byte
.9c7d  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.9c7f  48         pha              	PHA				; push string pointer high byte
.9c80  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.9c82  48         pha              	PHA				; push string pointer low byte
.9c83  98         tya              	TYA				; get function jump vector high byte back
.9c84  48         pha              	PHA				; save functions jump vector high byte
.9c85  8a         txa              	TXA				; get function jump vector low byte back
.9c86  48         pha              	PHA				; save functions jump vector low byte
.9c87  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter
.9c8a  8a         txa              	TXA				; copy byte parameter to A
.9c8b  60         rts              	RTS				; go do function
.9c8c                              lab_bhss
.9c8c  20 e9 9a   jsr $9ae9        	JSR	LAB_EVEZ		; process expression
.9c8f  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.9c92  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9c94  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.9c96  b0 20      bcs $9cb8        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
.9c98  20 50 a9   jsr $a950        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.9c9b  a2 02      ldx #$02         	LDX	#$02			; 3 bytes to do
.9c9d                              lab_cfac
.9c9d  b5 ad      lda $ad,x        	LDA	FAC1_1,X		; get byte from FAC1
.9c9f  95 11      sta $11,x        	STA	nums_1,X		; save byte to temp
.9ca1  ca         dex              	DEX				; decrement index
.9ca2  10 f9      bpl $9c9d        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
.9ca4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.9ca7  a2 00      ldx #$00         	LDX	#$00			; set default to no leading "0"s
.9ca9  c9 29      cmp #$29         	CMP	#")"			; compare with close bracket
.9cab  f0 0a      beq $9cb7        	BEQ	LAB_1C54		; if ")" go do rest of function
.9cad  20 de a4   jsr $a4de        	JSR	LAB_SCGB		; scan for "," and get byte
.9cb0  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get last byte back
.9cb3  c9 29      cmp #$29         	CMP	#")"			; is next character )
.9cb5  d0 01      bne $9cb8        	BNE	LAB_BHER		; if not ")" go do error
.9cb7                              lab_1c54
.9cb7  60         rts              	RTS				; else do function
.9cb8                              lab_bher
.9cb8  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start
.9cbb                              lab_eor
.9cbb  20 e2 9c   jsr $9ce2        	JSR	GetFirst		; get first integer expression (no sign check)
.9cbe  45 5b      eor $5b          	EOR	XOAw_l		; EOR with expression 1 low byte
.9cc0  a8         tay              	TAY				; save in Y
.9cc1  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9cc3  45 5c      eor $5c          	EOR	XOAw_h		; EOR with expression 1 high byte
.9cc5  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9cc8                              lab_or
.9cc8  20 e2 9c   jsr $9ce2        	JSR	GetFirst		; get first integer expression (no sign check)
.9ccb  05 5b      ora $5b          	ORA	XOAw_l		; OR with expression 1 low byte
.9ccd  a8         tay              	TAY				; save in Y
.9cce  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9cd0  05 5c      ora $5c          	ORA	XOAw_h		; OR with expression 1 high byte
.9cd2  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9cd5                              lab_and
.9cd5  20 e2 9c   jsr $9ce2        	JSR	GetFirst		; get first integer expression (no sign check)
.9cd8  25 5b      and $5b          	AND	XOAw_l		; AND with expression 1 low byte
.9cda  a8         tay              	TAY				; save in Y
.9cdb  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9cdd  25 5c      and $5c          	AND	XOAw_h		; AND with expression 1 high byte
.9cdf  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9ce2                              getfirst
.9ce2  20 a6 9e   jsr $9ea6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.9ce5  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.9ce7  85 5c      sta $5c          	STA	XOAw_h		; save it
.9ce9  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.9ceb  85 5b      sta $5b          	STA	XOAw_l		; save it
.9ced  20 c3 a5   jsr $a5c3        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.9cf0  20 a6 9e   jsr $9ea6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.9cf3  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.9cf5                              lab_1c95
.9cf5  60         rts              	RTS
.9cf6                              lab_lthan
.9cf6  20 d3 9a   jsr $9ad3        	JSR	LAB_CKTM		; type match check, set C for string
.9cf9  b0 13      bcs $9d0e        	BCS	LAB_1CAE		; branch if string
.9cfb  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.9cfd  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.9cff  25 b4      and $b4          	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
.9d01  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.9d03  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.9d05  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.9d07  20 17 a9   jsr $a917        	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
.9d0a  aa         tax              	TAX				; copy result
.9d0b  4c 3f 9d   jmp $9d3f        	JMP	LAB_1CE1		; go evaluate result
.9d0e                              lab_1cae
.9d0e  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.9d10  c6 9b      dec $9b          	DEC	comp_f		; clear < bit in compare function flag
.9d12  20 3e a3   jsr $a33e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.9d15  85 ac      sta $ac          	STA	str_ln		; save length
.9d17  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.9d19  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.9d1b  a5 b5      lda $b5          	LDA	FAC2_2		; get descriptor pointer low byte
.9d1d  a4 b6      ldy $b6          	LDY	FAC2_3		; get descriptor pointer high byte
.9d1f  20 42 a3   jsr $a342        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.9d22  86 b5      stx $b5          	STX	FAC2_2		; save string pointer low byte
.9d24  84 b6      sty $b6          	STY	FAC2_3		; save string pointer high byte
.9d26  aa         tax              	TAX				; copy length
.9d27  38         sec              	SEC				; set carry for subtract
.9d28  e5 ac      sbc $ac          	SBC	str_ln		; subtract string 1 length
.9d2a  f0 08      beq $9d34        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
.9d2c  a9 01      lda #$01         	LDA	#$01			; set str 1 length > string 2 length
.9d2e  90 04      bcc $9d34        	BCC	LAB_1CD6		; branch if so
.9d30  a6 ac      ldx $ac          	LDX	str_ln		; get string 1 length
.9d32  a9 ff      lda #$ff         	LDA	#$FF			; set str 1 length < string 2 length
.9d34                              lab_1cd6
.9d34  85 b0      sta $b0          	STA	FAC1_s		; save length compare
.9d36  a0 ff      ldy #$ff         	LDY	#$FF			; set index
.9d38  e8         inx              	INX				; adjust for loop
.9d39                              lab_1cdb
.9d39  c8         iny              	INY				; increment index
.9d3a  ca         dex              	DEX				; decrement count
.9d3b  d0 07      bne $9d44        	BNE	LAB_1CE6		; branch if still bytes to do
.9d3d  a6 b0      ldx $b0          	LDX	FAC1_s		; get length compare back
.9d3f                              lab_1ce1
.9d3f  30 0f      bmi $9d50        	BMI	LAB_1CF2		; branch if str 1 < str 2
.9d41  18         clc              	CLC				; flag str 1 <= str 2
.9d42  90 0c      bcc $9d50        	BCC	LAB_1CF2		; go evaluate result
.9d44                              lab_1ce6
.9d44  b1 b5      lda ($b5),y      	LDA	(FAC2_2),Y		; get string 2 byte
.9d46  d1 ad      cmp ($ad),y      	CMP	(FAC1_1),Y		; compare with string 1 byte
.9d48  f0 ef      beq $9d39        	BEQ	LAB_1CDB		; loop if bytes =
.9d4a  a2 ff      ldx #$ff         	LDX	#$FF			; set str 1 < string 2
.9d4c  b0 02      bcs $9d50        	BCS	LAB_1CF2		; branch if so
.9d4e  a2 01      ldx #$01         	LDX	#$01			;  set str 1 > string 2
.9d50                              lab_1cf2
.9d50  e8         inx              	INX				; x = 0, 1 or 2
.9d51  8a         txa              	TXA				; copy to A
.9d52  2a         rol              	ROL				; *2 (1, 2 or 4)
.9d53  25 63      and $63          	AND	Cflag			; AND with comparison evaluation flag
.9d55  f0 02      beq $9d59        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
.9d57  a9 ff      lda #$ff         	LDA	#$FF			; else set result true
.9d59                              lab_1cfb
.9d59  4c fa a8   jmp $a8fa        	JMP	LAB_27DB		; save A as integer byte and return
.9d5c                              lab_1cfe
.9d5c  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.9d5f                              lab_dim
.9d5f  aa         tax              	TAX				; copy "DIM" flag to X
.9d60  20 af 9d   jsr $9daf        	JSR	LAB_1D10		; search for variable
.9d63  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9d66  d0 f4      bne $9d5c        	BNE	LAB_1CFE		; scan for "," and loop if not null
.9d68  60         rts              	RTS
.9d69                              lab_lshift
.9d69  20 9f 9d   jsr $9d9f        	JSR	GetPair		; get integer expression and byte (no sign check)
.9d6c  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.9d6e  a6 78      ldx $78          	LDX	TempB			; get shift count
.9d70  f0 22      beq $9d94        	BEQ	NoShift		; branch if zero
.9d72  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.9d74  b0 23      bcs $9d99        	BCS	TooBig		; branch if >=
.9d76                              ls_loop
.9d76  06 af      asl $af          	ASL	FAC1_3		; shift low byte
.9d78  2a         rol              	ROL				; shift high byte
.9d79  ca         dex              	DEX				; decrement bit count
.9d7a  d0 fa      bne $9d76        	BNE	Ls_loop		; loop if shift not complete
.9d7c  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.9d7e  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9d81                              lab_rshift
.9d81  20 9f 9d   jsr $9d9f        	JSR	GetPair		; get integer expression and byte (no sign check)
.9d84  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.9d86  a6 78      ldx $78          	LDX	TempB			; get shift count
.9d88  f0 0a      beq $9d94        	BEQ	NoShift		; branch if zero
.9d8a  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.9d8c  b0 0b      bcs $9d99        	BCS	TooBig		; branch if >=
.9d8e                              rs_loop
.9d8e  4a         lsr              	LSR				; shift high byte
.9d8f  66 af      ror $af          	ROR	FAC1_3		; shift low byte
.9d91  ca         dex              	DEX				; decrement bit count
.9d92  d0 fa      bne $9d8e        	BNE	Rs_loop		; loop if shift not complete
.9d94                              noshift
.9d94  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.9d96  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9d99                              toobig
.9d99  a9 00      lda #$00         	LDA	#$00			; clear high byte
.9d9b  a8         tay              	TAY				; copy to low byte
.9d9c  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.9d9f                              getpair
.9d9f  20 8f a4   jsr $a48f        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.9da2  86 78      stx $78          	STX	TempB			; save it
.9da4  20 c3 a5   jsr $a5c3        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.9da7  4c a6 9e   jmp $9ea6        	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
.9daa                              lab_gvar
.9daa  a2 00      ldx #$00         	LDX	#$00			; set DIM flag = $00
.9dac  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory (1st character)
.9daf                              lab_1d10
.9daf  86 5e      stx $5e          	STX	Defdim		; save DIM flag
.9db1                              lab_1d12
.9db1  85 93      sta $93          	STA	Varnm1		; save 1st character
.9db3  29 7f      and #$7f         	AND	#$7F			; clear FN flag bit
.9db5  20 1e 9e   jsr $9e1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.9db8  b0 03      bcs $9dbd        	BCS	LAB_1D1F		; branch if ok
.9dba  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; else syntax error then warm start
.9dbd                              lab_1d1f
.9dbd  a2 00      ldx #$00         	LDX	#$00			; clear 2nd character temp
.9dbf  86 5f      stx $5f          	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.9dc1  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (2nd character)
.9dc4  90 05      bcc $9dcb        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
.9dc6  20 1e 9e   jsr $9e1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.9dc9  90 0b      bcc $9dd6        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
.9dcb                              lab_1d2d
.9dcb  aa         tax              	TAX				; copy 2nd character
.9dcc                              lab_1d2e
.9dcc  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (3rd character)
.9dcf  90 fb      bcc $9dcc        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
.9dd1  20 1e 9e   jsr $9e1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.9dd4  b0 f6      bcs $9dcc        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
.9dd6                              lab_1d38
.9dd6  c9 24      cmp #$24         	CMP	#"$"			; compare with "$"
.9dd8  d0 0b      bne $9de5        	BNE	LAB_1D47		; branch if not string
.9dda  a9 ff      lda #$ff         	LDA	#$FF			; set data type = string
.9ddc  85 5f      sta $5f          	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
.9dde  8a         txa              	TXA				; get 2nd character back
.9ddf  09 80      ora #$80         	ORA	#$80			; set top bit (indicate string var)
.9de1  aa         tax              	TAX				; copy back to 2nd character temp
.9de2  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.9de5                              lab_1d47
.9de5  86 94      stx $94          	STX	Varnm2		; save 2nd character
.9de7  05 61      ora $61          	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
.9de9  c9 28      cmp #$28         	CMP	#"("			; compare with "("
.9deb  d0 03      bne $9df0        	BNE	LAB_1D53		; branch if not "("
.9ded  4c b8 9e   jmp $9eb8        	JMP	LAB_1E17		; go find, or make, array
.9df0                              lab_1d53
.9df0  a9 00      lda #$00         	LDA	#$00			; clear A
.9df2  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.9df4  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.9df6  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.9df8  a0 00      ldy #$00         	LDY	#$00			; clear index
.9dfa                              lab_1d5d
.9dfa  86 ab      stx $ab          	STX	Vrschh		; save search address high byte
.9dfc                              lab_1d5f
.9dfc  85 aa      sta $aa          	STA	Vrschl		; save search address low byte
.9dfe  e4 7e      cpx $7e          	CPX	Sarryh		; compare high address with var space end
.9e00  d0 04      bne $9e06        	BNE	LAB_1D69		; skip next compare if <>
.9e02  c5 7d      cmp $7d          	CMP	Sarryl		; compare low address with var space end
.9e04  f0 2c      beq $9e32        	BEQ	LAB_1D8B		; if not found go make new var
.9e06                              lab_1d69
.9e06  a5 93      lda $93          	LDA	Varnm1		; get 1st character of var to find
.9e08  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 1st character
.9e0a  d0 08      bne $9e14        	BNE	LAB_1D77		; branch if no match
.9e0c  a5 94      lda $94          	LDA	Varnm2		; get 2nd character of var to find
.9e0e  c8         iny              	INY				; index to point to variable name 2nd character
.9e0f  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 2nd character
.9e11  f0 69      beq $9e7c        	BEQ	LAB_1DD7		; branch if match (found var)
.9e13  88         dey              	DEY				; else decrement index (now = $00)
.9e14                              lab_1d77
.9e14  18         clc              	CLC				; clear carry for add
.9e15  a5 aa      lda $aa          	LDA	Vrschl		; get search address low byte
.9e17  69 06      adc #$06         	ADC	#$06			; +6 (offset to next var name)
.9e19  90 e1      bcc $9dfc        	BCC	LAB_1D5F		; loop if no overflow to high byte
.9e1b  e8         inx              	INX				; else increment high byte
.9e1c  d0 dc      bne $9dfa        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
.9e1e                              lab_casc
.9e1e  c9 61      cmp #$61         	CMP	#"a"			; compare with "a"
.9e20  b0 0a      bcs $9e2c        	BCS	LAB_1D83		; go check <"z"+1
.9e22                              lab_1d82
.9e22  c9 41      cmp #$41         	CMP	#"A"			; compare with "A"
.9e24  90 05      bcc $9e2b        	BCC	LAB_1D8A		; exit if less
.9e26  e9 5b      sbc #$5b         	SBC	#$5B			; subtract "Z"+1
.9e28  38         sec              	SEC				; set carry
.9e29  e9 a5      sbc #$a5         	SBC	#$A5			; subtract $A5 (restore byte)
.9e2b                              lab_1d8a
.9e2b  60         rts              	RTS
.9e2c                              lab_1d83
.9e2c  e9 7b      sbc #$7b         	SBC	#$7B			; subtract "z"+1
.9e2e  38         sec              	SEC				; set carry
.9e2f  e9 85      sbc #$85         	SBC	#$85			; subtract $85 (restore byte)
.9e31  60         rts              	RTS
.9e32                              lab_1d8b
.9e32  68         pla              	PLA				; pop return address low byte
.9e33  48         pha              	PHA				; push return address low byte
.9e34  c9 3d      cmp #$3d         	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
.9e36  d0 05      bne $9e3d        	BNE	LAB_1D98		; if not get (var) go create new var
.9e38  a9 e1      lda #$e1         	LDA	#<LAB_1D96		; low byte point to $00,$00
.9e3a  a0 b1      ldy #$b1         	LDY	#>LAB_1D96		; high byte point to $00,$00
.9e3c  60         rts              	RTS
.9e3d                              lab_1d98
.9e3d  a5 7d      lda $7d          	LDA	Sarryl		; get var mem end low byte
.9e3f  a4 7e      ldy $7e          	LDY	Sarryh		; get var mem end high byte
.9e41  85 aa      sta $aa          	STA	Ostrtl		; save old block start low byte
.9e43  84 ab      sty $ab          	STY	Ostrth		; save old block start high byte
.9e45  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.9e47  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.9e49  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.9e4b  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.9e4d  18         clc              	CLC				; clear carry for add
.9e4e  69 06      adc #$06         	ADC	#$06			; +6 (space for one var)
.9e50  90 01      bcc $9e53        	BCC	LAB_1DAE		; branch if no overflow to high byte
.9e52  c8         iny              	INY				; else increment high byte
.9e53                              lab_1dae
.9e53  85 a4      sta $a4          	STA	Nbendl		; set new block end low byte
.9e55  84 a5      sty $a5          	STY	Nbendh		; set new block end high byte
.9e57  20 c1 90   jsr $90c1        	JSR	LAB_11CF		; open up space in memory
.9e5a  a5 a4      lda $a4          	LDA	Nbendl		; get new start low byte
.9e5c  a4 a5      ldy $a5          	LDY	Nbendh		; get new start high byte (-$100)
.9e5e  c8         iny              	INY				; correct high byte
.9e5f  85 7d      sta $7d          	STA	Sarryl		; save new var mem end low byte
.9e61  84 7e      sty $7e          	STY	Sarryh		; save new var mem end high byte
.9e63  a0 00      ldy #$00         	LDY	#$00			; clear index
.9e65  a5 93      lda $93          	LDA	Varnm1		; get var name 1st character
.9e67  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 1st character
.9e69  c8         iny              	INY				; increment index
.9e6a  a5 94      lda $94          	LDA	Varnm2		; get var name 2nd character
.9e6c  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 2nd character
.9e6e  a9 00      lda #$00         	LDA	#$00			; clear A
.9e70  c8         iny              	INY				; increment index
.9e71  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.9e73  c8         iny              	INY				; increment index
.9e74  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.9e76  c8         iny              	INY				; increment index
.9e77  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.9e79  c8         iny              	INY				; increment index
.9e7a  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.9e7c                              lab_1dd7
.9e7c  a5 aa      lda $aa          	LDA	Vrschl		; get var address low byte
.9e7e  18         clc              	CLC				; clear carry for add
.9e7f  69 02      adc #$02         	ADC	#$02			; +2 (offset past var name bytes)
.9e81  a4 ab      ldy $ab          	LDY	Vrschh		; get var address high byte
.9e83  90 01      bcc $9e86        	BCC	LAB_1DE1		; branch if no overflow from add
.9e85  c8         iny              	INY				; else increment high byte
.9e86                              lab_1de1
.9e86  85 95      sta $95          	STA	Cvaral		; save current var address low byte
.9e88  84 96      sty $96          	STY	Cvarah		; save current var address high byte
.9e8a  60         rts              	RTS
.9e8b                              lab_1de6
.9e8b  a5 5d      lda $5d          	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
.9e8d  0a         asl              	ASL				; *2 (also clears the carry !)
.9e8e  69 05      adc #$05         	ADC	#$05			; +5 (result is 7, 9 or 11 here)
.9e90  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.9e92  a4 ab      ldy $ab          	LDY	Astrth		; get array pointer high byte
.9e94  90 01      bcc $9e97        	BCC	LAB_1DF2		; branch if no overflow
.9e96  c8         iny              	INY				; else increment high byte
.9e97                              lab_1df2
.9e97  85 a4      sta $a4          	STA	Adatal		; save array data pointer low byte
.9e99  84 a5      sty $a5          	STY	Adatah		; save array data pointer high byte
.9e9b  60         rts              	RTS
.9e9c                              lab_evin
.9e9c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.9e9f  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.9ea2                              lab_evpi
.9ea2  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.9ea4  30 0d      bmi $9eb3        	BMI	LAB_1E12		; do function call error if -ve
.9ea6                              lab_evir
.9ea6  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.9ea8  c9 90      cmp #$90         	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.9eaa  90 09      bcc $9eb5        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
.9eac  a9 e8      lda #$e8         	LDA	#<LAB_1DF7		; set pointer low byte to -32768
.9eae  a0 b1      ldy #$b1         	LDY	#>LAB_1DF7		; set pointer high byte to -32768
.9eb0  20 17 a9   jsr $a917        	JSR	LAB_27F8		; compare FAC1 with (AY)
.9eb3                              lab_1e12
.9eb3  d0 74      bne $9f29        	BNE	LAB_FCER		; if <> do function call error then warm start
.9eb5                              lab_1e14
.9eb5  4c 50 a9   jmp $a950        	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
.9eb8                              lab_1e17
.9eb8  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.9eba  48         pha              	PHA				; push it
.9ebb  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.9ebd  48         pha              	PHA				; push it
.9ebe  a0 00      ldy #$00         	LDY	#$00			; clear dimensions count
.9ec0                              lab_1e1f
.9ec0  98         tya              	TYA				; copy dimensions count
.9ec1  48         pha              	PHA				; save it
.9ec2  a5 94      lda $94          	LDA	Varnm2		; get array name 2nd byte
.9ec4  48         pha              	PHA				; save it
.9ec5  a5 93      lda $93          	LDA	Varnm1		; get array name 1st byte
.9ec7  48         pha              	PHA				; save it
.9ec8  20 9c 9e   jsr $9e9c        	JSR	LAB_EVIN		; evaluate integer expression
.9ecb  68         pla              	PLA				; pull array name 1st byte
.9ecc  85 93      sta $93          	STA	Varnm1		; restore array name 1st byte
.9ece  68         pla              	PLA				; pull array name 2nd byte
.9ecf  85 94      sta $94          	STA	Varnm2		; restore array name 2nd byte
.9ed1  68         pla              	PLA				; pull dimensions count
.9ed2  a8         tay              	TAY				; restore it
.9ed3  ba         tsx              	TSX				; copy stack pointer
.9ed4  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get DIM flag
.9ed7  48         pha              	PHA				; push it
.9ed8  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get data type flag
.9edb  48         pha              	PHA				; push it
.9edc  a5 ae      lda $ae          	LDA	FAC1_2		; get this dimension size high byte
.9ede  9d 02 01   sta $0102,x      	STA	LAB_STAK+2,X	; stack before flag bytes
.9ee1  a5 af      lda $af          	LDA	FAC1_3		; get this dimension size low byte
.9ee3  9d 01 01   sta $0101,x      	STA	LAB_STAK+1,X	; stack before flag bytes
.9ee6  c8         iny              	INY				; increment dimensions count
.9ee7  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.9eea  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.9eec  f0 d2      beq $9ec0        	BEQ	LAB_1E1F		; if found go do next dimension
.9eee  84 5d      sty $5d          	STY	Dimcnt		; store dimensions count
.9ef0  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.9ef3  68         pla              	PLA				; pull data type flag
.9ef4  85 5f      sta $5f          	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
.9ef6  68         pla              	PLA				; pull DIM flag
.9ef7  85 5e      sta $5e          	STA	Defdim		; restore DIM flag
.9ef9  a6 7d      ldx $7d          	LDX	Sarryl		; get array mem start low byte
.9efb  a5 7e      lda $7e          	LDA	Sarryh		; get array mem start high byte
.9efd                              lab_1e5c
.9efd  86 aa      stx $aa          	STX	Astrtl		; save as array start pointer low byte
.9eff  85 ab      sta $ab          	STA	Astrth		; save as array start pointer high byte
.9f01  c5 80      cmp $80          	CMP	Earryh		; compare with array mem end high byte
.9f03  d0 04      bne $9f09        	BNE	LAB_1E68		; branch if not reached array mem end
.9f05  e4 7f      cpx $7f          	CPX	Earryl		; else compare with array mem end low byte
.9f07  f0 39      beq $9f42        	BEQ	LAB_1EA1		; go build array if not found
.9f09                              lab_1e68
.9f09  a0 00      ldy #$00         	LDY	#$00			; clear index
.9f0b  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array name first byte
.9f0d  c8         iny              	INY				; increment index to second name byte
.9f0e  c5 93      cmp $93          	CMP	Varnm1		; compare with this array name first byte
.9f10  d0 06      bne $9f18        	BNE	LAB_1E77		; branch if no match
.9f12  a5 94      lda $94          	LDA	Varnm2		; else get this array name second byte
.9f14  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array name second byte
.9f16  f0 16      beq $9f2e        	BEQ	LAB_1E8D		; array found so branch
.9f18                              lab_1e77
.9f18  c8         iny              	INY				; increment index
.9f19  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size low byte
.9f1b  18         clc              	CLC				; clear carry for add
.9f1c  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.9f1e  aa         tax              	TAX				; copy low byte to X
.9f1f  c8         iny              	INY				; increment index
.9f20  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size high byte
.9f22  65 ab      adc $ab          	ADC	Astrth		; add array mem pointer high byte
.9f24  90 d7      bcc $9efd        	BCC	LAB_1E5C		; if no overflow go check next array
.9f26                              lab_1e85
.9f26  a2 10      ldx #$10         	LDX	#$10			; error code $10 ("Array bounds" error)

>9f28  2c                          	.byte	$2C			; makes next bit BIT LAB_08A2
.9f29                              lab_fcer

.9f29  a2 08      ldx #$08         	LDX	#$08			; error code $08 ("Function call" error)
.9f2b                              lab_1e8a
.9f2b  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.9f2e                              lab_1e8d
.9f2e  a2 12      ldx #$12         	LDX	#$12			; set error $12 ("Double dimension" error)
.9f30  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.9f32  d0 f7      bne $9f2b        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
.9f34  20 8b 9e   jsr $9e8b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.9f37  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.9f39  a0 04      ldy #$04         	LDY	#$04			; set index to array's # of dimensions
.9f3b  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with no of dimensions
.9f3d  d0 e7      bne $9f26        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
.9f3f  4c c5 9f   jmp $9fc5        	JMP	LAB_1F28		; found array so go get element
.9f42                              lab_1ea1
.9f42  20 8b 9e   jsr $9e8b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.9f45  20 0b 91   jsr $910b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.9f48  a0 00      ldy #$00         	LDY	#$00			; clear Y (don't need to clear A)
.9f4a  84 bb      sty $bb          	STY	Aspth			; clear array data size high byte
.9f4c  a5 93      lda $93          	LDA	Varnm1		; get variable name 1st byte
.9f4e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 1st byte
.9f50  c8         iny              	INY				; increment index
.9f51  a5 94      lda $94          	LDA	Varnm2		; get variable name 2nd byte
.9f53  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 2nd byte
.9f55  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.9f57  a0 04      ldy #$04         	LDY	#$04			; index to dimension count
.9f59  84 ba      sty $ba          	STY	Asptl			; set array data size low byte (four bytes per element)
.9f5b  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; set array's dimensions count
.9f5d  18         clc              	CLC				; clear carry for add (clear on subsequent loops)
.9f5e                              lab_1ec0
.9f5e  a2 0b      ldx #$0b         	LDX	#$0B			; set default dimension value low byte
.9f60  a9 00      lda #$00         	LDA	#$00			; set default dimension value high byte
.9f62  24 5e      bit $5e          	BIT	Defdim		; test default DIM flag
.9f64  50 07      bvc $9f6d        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
.9f66  68         pla              	PLA				; else pull dimension value low byte
.9f67  69 01      adc #$01         	ADC	#$01			; +1 (allow for zeroeth element)
.9f69  aa         tax              	TAX				; copy low byte to X
.9f6a  68         pla              	PLA				; pull dimension value high byte
.9f6b  69 00      adc #$00         	ADC	#$00			; add carry from low byte
.9f6d                              lab_1ed0
.9f6d  c8         iny              	INY				; index to dimension value high byte
.9f6e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value high byte
.9f70  c8         iny              	INY				; index to dimension value high byte
.9f71  8a         txa              	TXA				; get dimension value low byte
.9f72  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value low byte
.9f74  20 14 a0   jsr $a014        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.9f77  86 ba      stx $ba          	STX	Asptl			; save array data size low byte
.9f79  85 bb      sta $bb          	STA	Aspth			; save array data size high byte
.9f7b  a4 71      ldy $71          	LDY	ut1_pl		; restore index (saved by subroutine)
.9f7d  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.9f7f  d0 dd      bne $9f5e        	BNE	LAB_1EC0		; loop while not = 0
.9f81  65 a5      adc $a5          	ADC	Adatah		; add size high byte to first element high byte
.9f83  b0 5d      bcs $9fe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.9f85  85 a5      sta $a5          	STA	Adatah		; save end of array high byte
.9f87  a8         tay              	TAY				; copy end high byte to Y
.9f88  8a         txa              	TXA				; get array size low byte
.9f89  65 a4      adc $a4          	ADC	Adatal		; add array start low byte
.9f8b  90 03      bcc $9f90        	BCC	LAB_1EF3		; branch if no carry
.9f8d  c8         iny              	INY				; else increment end of array high byte
.9f8e  f0 52      beq $9fe2        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
.9f90                              lab_1ef3
.9f90  20 0b 91   jsr $910b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.9f93  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.9f95  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.9f97  a9 00      lda #$00         	LDA	#$00			; clear byte for array clear
.9f99  e6 bb      inc $bb          	INC	Aspth			; increment array size high byte (now block count)
.9f9b  a4 ba      ldy $ba          	LDY	Asptl			; get array size low byte (now index to block)
.9f9d  f0 05      beq $9fa4        	BEQ	LAB_1F07		; branch if low byte = $00
.9f9f                              lab_1f02
.9f9f  88         dey              	DEY				; decrement index (do 0 to n-1)
.9fa0  91 a4      sta ($a4),y      	STA	(Adatal),Y		; zero byte
.9fa2  d0 fb      bne $9f9f        	BNE	LAB_1F02		; loop until this block done
.9fa4                              lab_1f07
.9fa4  c6 a5      dec $a5          	DEC	Adatah		; decrement array pointer high byte
.9fa6  c6 bb      dec $bb          	DEC	Aspth			; decrement block count high byte
.9fa8  d0 f5      bne $9f9f        	BNE	LAB_1F02		; loop until all blocks done
.9faa  e6 a5      inc $a5          	INC	Adatah		; correct for last loop
.9fac  38         sec              	SEC				; set carry for subtract
.9fad  a0 02      ldy #$02         	LDY	#$02			; index to array size low byte
.9faf  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.9fb1  e5 aa      sbc $aa          	SBC	Astrtl		; subtract array start low byte
.9fb3  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size low byte
.9fb5  c8         iny              	INY				; index to array size high byte
.9fb6  a5 80      lda $80          	LDA	Earryh		; get array mem end high byte
.9fb8  e5 ab      sbc $ab          	SBC	Astrth		; subtract array start high byte
.9fba  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size high byte
.9fbc  a5 5e      lda $5e          	LDA	Defdim		; get default DIM flag
.9fbe  d0 53      bne $a013        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
.9fc0  c8         iny              	INY				; index to # of dimensions
.9fc1                              lab_1f24
.9fc1  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array's dimension count
.9fc3  85 5d      sta $5d          	STA	Dimcnt		; save it
.9fc5                              lab_1f28
.9fc5  a9 00      lda #$00         	LDA	#$00			; clear byte
.9fc7  85 ba      sta $ba          	STA	Asptl			; clear array data pointer low byte
.9fc9                              lab_1f2c
.9fc9  85 bb      sta $bb          	STA	Aspth			; save array data pointer high byte
.9fcb  c8         iny              	INY				; increment index (point to array bound high byte)
.9fcc  68         pla              	PLA				; pull array index low byte
.9fcd  aa         tax              	TAX				; copy to X
.9fce  85 ae      sta $ae          	STA	FAC1_2		; save index low byte to FAC1 mantissa2
.9fd0  68         pla              	PLA				; pull array index high byte
.9fd1  85 af      sta $af          	STA	FAC1_3		; save index high byte to FAC1 mantissa3
.9fd3  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound high byte
.9fd5  90 0e      bcc $9fe5        	BCC	LAB_1F48		; branch if within bounds
.9fd7  d0 06      bne $9fdf        	BNE	LAB_1F42		; if outside bounds do array bounds error
.9fd9  c8         iny              	INY				; index to array bound low byte
.9fda  8a         txa              	TXA				; get array index low byte
.9fdb  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound low byte
.9fdd  90 07      bcc $9fe6        	BCC	LAB_1F49		; branch if within bounds
.9fdf                              lab_1f42
.9fdf  4c 26 9f   jmp $9f26        	JMP	LAB_1E85		; else do array bounds error
.9fe2                              lab_1f45
.9fe2  4c 3a 91   jmp $913a        	JMP	LAB_OMER		; do "Out of memory" error then warm start
.9fe5                              lab_1f48
.9fe5  c8         iny              	INY				; index to array bound low byte
.9fe6                              lab_1f49
.9fe6  a5 bb      lda $bb          	LDA	Aspth			; get array data pointer high byte
.9fe8  05 ba      ora $ba          	ORA	Asptl			; OR with array data pointer low byte
.9fea  f0 0a      beq $9ff6        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
.9fec  20 14 a0   jsr $a014        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.9fef  8a         txa              	TXA				; get result low byte
.9ff0  65 ae      adc $ae          	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
.9ff2  aa         tax              	TAX				; save result low byte
.9ff3  98         tya              	TYA				; get result high byte
.9ff4  a4 71      ldy $71          	LDY	ut1_pl		; restore index
.9ff6                              lab_1f5a
.9ff6  65 af      adc $af          	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
.9ff8  86 ba      stx $ba          	STX	Asptl			; save array data pointer low byte
.9ffa  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.9ffc  d0 cb      bne $9fc9        	BNE	LAB_1F2C		; loop if dimensions still to do
.9ffe  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 2
.a000  2a         rol              	ROL				; array data pointer high byte * 2
.a001  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 4
.a003  2a         rol              	ROL				; array data pointer high byte * 4
.a004  a8         tay              	TAY				; copy high byte
.a005  a5 ba      lda $ba          	LDA	Asptl			; get low byte
.a007  65 a4      adc $a4          	ADC	Adatal		; add array data start pointer low byte
.a009  85 95      sta $95          	STA	Cvaral		; save as current var address low byte
.a00b  98         tya              	TYA				; get high byte back
.a00c  65 a5      adc $a5          	ADC	Adatah		; add array data start pointer high byte
.a00e  85 96      sta $96          	STA	Cvarah		; save as current var address high byte
.a010  a8         tay              	TAY				; copy high byte to Y
.a011  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.a013                              lab_1f7b
.a013  60         rts              	RTS
.a014                              lab_1f7c
.a014  84 71      sty $71          	STY	ut1_pl		; save index
.a016  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size low byte
.a018  85 76      sta $76          	STA	dims_l		; save dimension size low byte
.a01a  88         dey              	DEY				; decrement index
.a01b  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size high byte
.a01d  85 77      sta $77          	STA	dims_h		; save dimension size high byte
.a01f  a9 10      lda #$10         	LDA	#$10			; count = $10 (16 bit multiply)
.a021  85 a8      sta $a8          	STA	numbit		; save bit count
.a023  a2 00      ldx #$00         	LDX	#$00			; clear result low byte
.a025  a0 00      ldy #$00         	LDY	#$00			; clear result high byte
.a027                              lab_1f8f
.a027  8a         txa              	TXA				; get result low byte
.a028  0a         asl              	ASL				; *2
.a029  aa         tax              	TAX				; save result low byte
.a02a  98         tya              	TYA				; get result high byte
.a02b  2a         rol              	ROL				; *2
.a02c  a8         tay              	TAY				; save result high byte
.a02d  b0 b3      bcs $9fe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.a02f  06 ba      asl $ba          	ASL	Asptl			; shift multiplier low byte
.a031  26 bb      rol $bb          	ROL	Aspth			; shift multiplier high byte
.a033  90 0b      bcc $a040        	BCC	LAB_1FA8		; skip add if no carry
.a035  18         clc              	CLC				; else clear carry for add
.a036  8a         txa              	TXA				; get result low byte
.a037  65 76      adc $76          	ADC	dims_l		; add dimension size low byte
.a039  aa         tax              	TAX				; save result low byte
.a03a  98         tya              	TYA				; get result high byte
.a03b  65 77      adc $77          	ADC	dims_h		; add dimension size high byte
.a03d  a8         tay              	TAY				; save result high byte
.a03e  b0 a2      bcs $9fe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.a040                              lab_1fa8
.a040  c6 a8      dec $a8          	DEC	numbit		; decrement bit count
.a042  d0 e3      bne $a027        	BNE	LAB_1F8F		; loop until all done
.a044  60         rts              	RTS
.a045                              lab_fre
.a045  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.a047  10 03      bpl $a04c        	BPL	LAB_1FB4		; branch if numeric
.a049  20 3e a3   jsr $a33e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.a04c                              lab_1fb4
.a04c  20 df a1   jsr $a1df        	JSR	LAB_GARB		; go do garbage collection
.a04f  38         sec              	SEC				; set carry for subtract
.a050  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.a052  e5 7f      sbc $7f          	SBC	Earryl		; subtract array mem end low byte
.a054  a8         tay              	TAY				; copy result to Y
.a055  a5 82      lda $82          	LDA	Sstorh		; get bottom of string space high byte
.a057  e5 80      sbc $80          	SBC	Earryh		; subtract array mem end high byte
.a059                              lab_ayfc
.a059  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.a05b  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a05d  84 ae      sty $ae          	STY	FAC1_2		; save FAC1 mantissa2
.a05f  a2 90      ldx #$90         	LDX	#$90			; set exponent=2^16 (integer)
.a061  4c 02 a9   jmp $a902        	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
.a064                              lab_pos
.a064  a4 0e      ldy $0e          	LDY	TPos			; get terminal position
.a066                              lab_1fd0
.a066  a9 00      lda #$00         	LDA	#$00			; clear high byte
.a068  f0 ef      beq $a059        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
.a06a                              lab_ckrn
.a06a  a6 88      ldx $88          	LDX	Clineh		; get current line high byte
.a06c  e8         inx              	INX				; increment it
.a06d  d0 a4      bne $a013        	BNE	LAB_1F7B		; return if can continue not direct mode
.a06f                              lab_1fd9
.a06f  a2 16      ldx #$16         	LDX	#$16			; error code $16 ("Illegal direct" error)
.a071                              lab_1fdb
.a071  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; go do error #X, then warm start
.a074                              lab_def
.a074  20 a5 a0   jsr $a0a5        	JSR	LAB_200B		; check FNx syntax
.a077  85 9c      sta $9c          	STA	func_l		; save function pointer low byte
.a079  84 9d      sty $9d          	STY	func_h		; save function pointer high byte
.a07b  20 6a a0   jsr $a06a        	JSR	LAB_CKRN		; check not Direct (back here if ok)
.a07e  20 fa 9b   jsr $9bfa        	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
.a081  a9 80      lda #$80         	LDA	#$80			; set flag for FNx
.a083  85 61      sta $61          	STA	Sufnxf		; save subscript/FNx flag
.a085  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get (var) address
.a088  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.a08b  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.a08e  a9 c2      lda #$c2         	LDA	#TK_EQUAL		; get = token
.a090  20 f1 9b   jsr $9bf1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.a093  a5 96      lda $96          	LDA	Cvarah		; get current var address high byte
.a095  48         pha              	PHA				; push it
.a096  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.a098  48         pha              	PHA				; push it
.a099  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a09b  48         pha              	PHA				; push it
.a09c  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.a09e  48         pha              	PHA				; push it
.a09f  20 8c 96   jsr $968c        	JSR	LAB_DATA		; go perform DATA
.a0a2  4c 14 a1   jmp $a114        	JMP	LAB_207A		; put execute pointer and variable pointer into function
.a0a5                              lab_200b
.a0a5  a9 af      lda #$af         	LDA	#TK_FN		; get FN" token
.a0a7  20 f1 9b   jsr $9bf1        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.a0aa  09 80      ora #$80         	ORA	#$80			; set FN flag bit
.a0ac  85 61      sta $61          	STA	Sufnxf		; save FN flag so array variable test fails
.a0ae  20 b1 9d   jsr $9db1        	JSR	LAB_1D12		; search for FN variable
.a0b1  4c d0 9a   jmp $9ad0        	JMP	LAB_CTNM		; check if source is numeric and return, else do type
.a0b4                              lab_201e
.a0b4  20 a5 a0   jsr $a0a5        	JSR	LAB_200B		; check FNx syntax
.a0b7  48         pha              	PHA				; push function pointer low byte
.a0b8  98         tya              	TYA				; copy function pointer high byte
.a0b9  48         pha              	PHA				; push function pointer high byte
.a0ba  20 fa 9b   jsr $9bfa        	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
.a0bd  20 e1 9a   jsr $9ae1        	JSR	LAB_EVEX		; evaluate expression
.a0c0  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.a0c3  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.a0c6  68         pla              	PLA				; pop function pointer high byte
.a0c7  85 9d      sta $9d          	STA	func_h		; restore it
.a0c9  68         pla              	PLA				; pop function pointer low byte
.a0ca  85 9c      sta $9c          	STA	func_l		; restore it
.a0cc  a2 20      ldx #$20         	LDX	#$20			; error code $20 ("Undefined function" error)
.a0ce  a0 03      ldy #$03         	LDY	#$03			; index to variable pointer high byte
.a0d0  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable pointer high byte
.a0d2  f0 9d      beq $a071        	BEQ	LAB_1FDB		; if zero go do undefined function error
.a0d4  85 96      sta $96          	STA	Cvarah		; save variable address high byte
.a0d6  88         dey              	DEY				; index to variable address low byte
.a0d7  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable address low byte
.a0d9  85 95      sta $95          	STA	Cvaral		; save variable address low byte
.a0db  aa         tax              	TAX				; copy address low byte
.a0dc  c8         iny              	INY				; index to mantissa_3
.a0dd                              lab_2043
.a0dd  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from variable
.a0df  48         pha              	PHA				; stack it
.a0e0  88         dey              	DEY				; decrement index
.a0e1  10 fa      bpl $a0dd        	BPL	LAB_2043		; loop until variable stacked
.a0e3  a4 96      ldy $96          	LDY	Cvarah		; get variable address high byte
.a0e5  20 a7 a8   jsr $a8a7        	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
.a0e8  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a0ea  48         pha              	PHA				; push it
.a0eb  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.a0ed  48         pha              	PHA				; push it
.a0ee  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer low byte
.a0f0  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.a0f2  c8         iny              	INY				; index to high byte
.a0f3  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer high byte
.a0f5  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.a0f7  a5 96      lda $96          	LDA	Cvarah		; get variable address high byte
.a0f9  48         pha              	PHA				; push it
.a0fa  a5 95      lda $95          	LDA	Cvaral		; get variable address low byte
.a0fc  48         pha              	PHA				; push it
.a0fd  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a100  68         pla              	PLA				; pull variable address low byte
.a101  85 9c      sta $9c          	STA	func_l		; save variable address low byte
.a103  68         pla              	PLA				; pull variable address high byte
.a104  85 9d      sta $9d          	STA	func_h		; save variable address high byte
.a106  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a109  f0 03      beq $a10e        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
.a10b  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; else syntax error then warm start
.a10e                              lab_2074
.a10e  68         pla              	PLA				; pull BASIC execute pointer low byte
.a10f  85 c3      sta $c3          	STA	Bpntrl		; restore BASIC execute pointer low byte
.a111  68         pla              	PLA				; pull BASIC execute pointer high byte
.a112  85 c4      sta $c4          	STA	Bpntrh		; restore BASIC execute pointer high byte
.a114                              lab_207a
.a114  a0 00      ldy #$00         	LDY	#$00			; clear index
.a116  68         pla              	PLA				; pull BASIC execute pointer low byte
.a117  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.a119  c8         iny              	INY				; increment index
.a11a  68         pla              	PLA				; pull BASIC execute pointer high byte
.a11b  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.a11d  c8         iny              	INY				; increment index
.a11e  68         pla              	PLA				; pull current var address low byte
.a11f  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.a121  c8         iny              	INY				; increment index
.a122  68         pla              	PLA				; pull current var address high byte
.a123  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.a125  60         rts              	RTS
.a126                              lab_strs
.a126  20 d0 9a   jsr $9ad0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.a129  20 95 aa   jsr $aa95        	JSR	LAB_296E		; convert FAC1 to string
.a12c  a9 f0      lda #$f0         	LDA	#<Decssp1		; set result string low pointer
.a12e  a0 00      ldy #$00         	LDY	#>Decssp1		; set result string high pointer
.a130  f0 12      beq $a144        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
.a132                              lab_209c
.a132  a6 ae      ldx $ae          	LDX	des_pl		; get descriptor pointer low byte
.a134  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.a136  86 9e      stx $9e          	STX	des_2l		; save descriptor pointer low byte
.a138  84 9f      sty $9f          	STY	des_2h		; save descriptor pointer high byte
.a13a                              lab_mssp
.a13a  20 ad a1   jsr $a1ad        	JSR	LAB_2115		; make space in string memory for string A long
.a13d  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.a13f  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.a141  85 ac      sta $ac          	STA	str_ln		; save length
.a143  60         rts              	RTS
.a144                              lab_20ae
.a144  a2 22      ldx #$22         	LDX	#$22			; set terminator to "
.a146  86 5b      stx $5b          	STX	Srchc			; set search character (terminator 1)
.a148  86 5c      stx $5c          	STX	Asrch			; set terminator 2
.a14a                              lab_20b4
.a14a  85 b8      sta $b8          	STA	ssptr_l		; store string start low byte
.a14c  84 b9      sty $b9          	STY	ssptr_h		; store string start high byte
.a14e  85 ad      sta $ad          	STA	str_pl		; save string pointer low byte
.a150  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.a152  a0 ff      ldy #$ff         	LDY	#$FF			; set length to -1
.a154                              lab_20be
.a154  c8         iny              	INY				; increment length
.a155  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get byte from string
.a157  f0 0c      beq $a165        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
.a159  c5 5b      cmp $5b          	CMP	Srchc			; compare with search character (terminator 1)
.a15b  f0 04      beq $a161        	BEQ	LAB_20CB		; branch if terminator
.a15d  c5 5c      cmp $5c          	CMP	Asrch			; compare with terminator 2
.a15f  d0 f3      bne $a154        	BNE	LAB_20BE		; loop if not terminator 2
.a161                              lab_20cb
.a161  c9 22      cmp #$22         	CMP	#$22			; compare with "
.a163  f0 01      beq $a166        	BEQ	LAB_20D0		; branch if " (carry set if = !)
.a165                              lab_20cf
.a165  18         clc              	CLC				; clear carry for add (only if [EOL] terminated string)
.a166                              lab_20d0
.a166  84 ac      sty $ac          	STY	str_ln		; save length in FAC1 exponent
.a168  98         tya              	TYA				; copy length to A
.a169  65 b8      adc $b8          	ADC	ssptr_l		; add string start low byte
.a16b  85 ba      sta $ba          	STA	Sendl			; save string end low byte
.a16d  a6 b9      ldx $b9          	LDX	ssptr_h		; get string start high byte
.a16f  90 01      bcc $a172        	BCC	LAB_20DC		; branch if no low byte overflow
.a171  e8         inx              	INX				; else increment high byte
.a172                              lab_20dc
.a172  86 bb      stx $bb          	STX	Sendh			; save string end high byte
.a174  a5 b9      lda $b9          	LDA	ssptr_h		; get string start high byte
.a176  c9 04      cmp #$04         	CMP	#>Ram_base		; compare with start of program memory
.a178  b0 0b      bcs $a185        	BCS	LAB_RTST		; branch if not in utility area
.a17a  98         tya              	TYA				; copy length to A
.a17b  20 32 a1   jsr $a132        	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.a17e  a6 b8      ldx $b8          	LDX	ssptr_l		; get string start low byte
.a180  a4 b9      ldy $b9          	LDY	ssptr_h		; get string start high byte
.a182  20 1f a3   jsr $a31f        	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
.a185                              lab_rtst
.a185  a6 65      ldx $65          	LDX	next_s		; get string stack pointer
.a187  e0 71      cpx #$71         	CPX	#des_sk+$09		; compare with max+1
.a189  d0 05      bne $a190        	BNE	LAB_20F8		; branch if space on string stack
.a18b  a2 1c      ldx #$1c         	LDX	#$1C			; error code $1C ("String too complex" error)
.a18d                              lab_20f5
.a18d  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.a190                              lab_20f8
.a190  a5 ac      lda $ac          	LDA	str_ln		; get string length
.a192  95 00      sta $00,x        	STA	PLUS_0,X		; put on string stack
.a194  a5 ad      lda $ad          	LDA	str_pl		; get string pointer low byte
.a196  95 01      sta $01,x        	STA	PLUS_1,X		; put on string stack
.a198  a5 ae      lda $ae          	LDA	str_ph		; get string pointer high byte
.a19a  95 02      sta $02,x        	STA	PLUS_2,X		; put on string stack
.a19c  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a19e  86 ae      stx $ae          	STX	des_pl		; save string descriptor pointer low byte
.a1a0  84 af      sty $af          	STY	des_ph		; save string descriptor pointer high byte (always $00)
.a1a2  88         dey              	DEY				; Y = $FF
.a1a3  84 5f      sty $5f          	STY	Dtypef		; save data type flag, $FF=string
.a1a5  86 66      stx $66          	STX	last_sl		; save old stack pointer (current top item)
.a1a7  e8         inx              	INX				; update stack pointer
.a1a8  e8         inx              	INX				; update stack pointer
.a1a9  e8         inx              	INX				; update stack pointer
.a1aa  86 65      stx $65          	STX	next_s		; save new top item value
.a1ac  60         rts              	RTS
.a1ad                              lab_2115
.a1ad  46 60      lsr $60          	LSR	Gclctd		; clear garbage collected flag (b7)
.a1af                              lab_2117
.a1af  48         pha              	PHA				; save string length
.a1b0  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a1b2  38         sec              	SEC				; set carry for subtract (twos comp add)
.a1b3  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte (subtract length)
.a1b5  a4 82      ldy $82          	LDY	Sstorh		; get bottom of string space high byte
.a1b7  b0 01      bcs $a1ba        	BCS	LAB_2122		; skip decrement if no underflow
.a1b9  88         dey              	DEY				; decrement bottom of string space high byte
.a1ba                              lab_2122
.a1ba  c4 80      cpy $80          	CPY	Earryh		; compare with array mem end high byte
.a1bc  90 11      bcc $a1cf        	BCC	LAB_2137		; do out of memory error if less
.a1be  d0 04      bne $a1c4        	BNE	LAB_212C		; if not = skip next test
.a1c0  c5 7f      cmp $7f          	CMP	Earryl		; compare with array mem end low byte
.a1c2  90 0b      bcc $a1cf        	BCC	LAB_2137		; do out of memory error if less
.a1c4                              lab_212c
.a1c4  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.a1c6  84 82      sty $82          	STY	Sstorh		; save bottom of string space high byte
.a1c8  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.a1ca  84 84      sty $84          	STY	Sutilh		; save string utility ptr high byte
.a1cc  aa         tax              	TAX				; copy low byte to X
.a1cd  68         pla              	PLA				; get string length back
.a1ce  60         rts              	RTS
.a1cf                              lab_2137
.a1cf  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.a1d1  a5 60      lda $60          	LDA	Gclctd		; get garbage collected flag
.a1d3  30 b8      bmi $a18d        	BMI	LAB_20F5		; if set then do error code X
.a1d5  20 df a1   jsr $a1df        	JSR	LAB_GARB		; else go do garbage collection
.a1d8  a9 80      lda #$80         	LDA	#$80			; flag for garbage collected
.a1da  85 60      sta $60          	STA	Gclctd		; set garbage collected flag
.a1dc  68         pla              	PLA				; pull length
.a1dd  d0 d0      bne $a1af        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
.a1df                              lab_garb
.a1df  a6 85      ldx $85          	LDX	Ememl			; get end of mem low byte
.a1e1  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.a1e3                              lab_214b
.a1e3  86 81      stx $81          	STX	Sstorl		; set string storage low byte
.a1e5  85 82      sta $82          	STA	Sstorh		; set string storage high byte
.a1e7  a0 00      ldy #$00         	LDY	#$00			; clear index
.a1e9  84 9d      sty $9d          	STY	garb_h		; clear working pointer high byte (flag no strings to move)
.a1eb  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.a1ed  a6 80      ldx $80          	LDX	Earryh		; get array mem end high byte
.a1ef  85 aa      sta $aa          	STA	Histrl		; save as highest string low byte
.a1f1  86 ab      stx $ab          	STX	Histrh		; save as highest string high byte
.a1f3  a9 68      lda #$68         	LDA	#des_sk		; set descriptor stack pointer
.a1f5  85 71      sta $71          	STA	ut1_pl		; save descriptor stack pointer low byte
.a1f7  84 72      sty $72          	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
.a1f9                              lab_2161
.a1f9  c5 65      cmp $65          	CMP	next_s		; compare with descriptor stack pointer
.a1fb  f0 05      beq $a202        	BEQ	LAB_216A		; branch if =
.a1fd  20 63 a2   jsr $a263        	JSR	LAB_21D7		; go garbage collect descriptor stack
.a200  f0 f7      beq $a1f9        	BEQ	LAB_2161		; loop always
.a202                              lab_216a
.a202  06 a0      asl $a0          	ASL	g_step		; set step size = $06
.a204  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.a206  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.a208  85 71      sta $71          	STA	ut1_pl		; save as pointer low byte
.a20a  86 72      stx $72          	STX	ut1_ph		; save as pointer high byte
.a20c                              lab_2176
.a20c  e4 7e      cpx $7e          	CPX	Sarryh		; compare start of arrays high byte
.a20e  d0 04      bne $a214        	BNE	LAB_217E		; branch if no high byte match
.a210  c5 7d      cmp $7d          	CMP	Sarryl		; else compare start of arrays low byte
.a212  f0 05      beq $a219        	BEQ	LAB_2183		; branch if = var mem end
.a214                              lab_217e
.a214  20 5d a2   jsr $a25d        	JSR	LAB_21D1		; go garbage collect strings
.a217  f0 f3      beq $a20c        	BEQ	LAB_2176		; loop always
.a219                              lab_2183
.a219  85 a4      sta $a4          	STA	Nbendl		; save start of arrays low byte as working pointer
.a21b  86 a5      stx $a5          	STX	Nbendh		; save start of arrays high byte as working pointer
.a21d  a9 04      lda #$04         	LDA	#$04			; set step size
.a21f  85 a0      sta $a0          	STA	g_step		; save step size
.a221                              lab_218b
.a221  a5 a4      lda $a4          	LDA	Nbendl		; get pointer low byte
.a223  a6 a5      ldx $a5          	LDX	Nbendh		; get pointer high byte
.a225                              lab_218f
.a225  e4 80      cpx $80          	CPX	Earryh		; compare with array mem end high byte
.a227  d0 04      bne $a22d        	BNE	LAB_219A		; branch if not at end
.a229  c5 7f      cmp $7f          	CMP	Earryl		; else compare with array mem end low byte
.a22b  f0 75      beq $a2a2        	BEQ	LAB_2216		; tidy up and exit if at end
.a22d                              lab_219a
.a22d  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.a22f  86 72      stx $72          	STX	ut1_ph		; save pointer high byte
.a231  a0 02      ldy #$02         	LDY	#$02			; set index
.a233  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size low byte
.a235  65 a4      adc $a4          	ADC	Nbendl		; add start of this array low byte
.a237  85 a4      sta $a4          	STA	Nbendl		; save start of next array low byte
.a239  c8         iny              	INY				; increment index
.a23a  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size high byte
.a23c  65 a5      adc $a5          	ADC	Nbendh		; add start of this array high byte
.a23e  85 a5      sta $a5          	STA	Nbendh		; save start of next array high byte
.a240  a0 01      ldy #$01         	LDY	#$01			; set index
.a242  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get name second byte
.a244  10 db      bpl $a221        	BPL	LAB_218B		; skip if not string array
.a246  a0 04      ldy #$04         	LDY	#$04			; set index
.a248  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get # of dimensions
.a24a  0a         asl              	ASL				; *2
.a24b  69 05      adc #$05         	ADC	#$05			; +5 (array header size)
.a24d  20 95 a2   jsr $a295        	JSR	LAB_2208		; go set up for first element
.a250                              lab_21c4
.a250  e4 a5      cpx $a5          	CPX	Nbendh		; compare with start of next array high byte
.a252  d0 04      bne $a258        	BNE	LAB_21CC		; branch if <> (go do this array)
.a254  c5 a4      cmp $a4          	CMP	Nbendl		; else compare element pointer low byte with next array
.a256  f0 cd      beq $a225        	BEQ	LAB_218F		; if equal then go do next array
.a258                              lab_21cc
.a258  20 63 a2   jsr $a263        	JSR	LAB_21D7		; go defrag array strings
.a25b  f0 f3      beq $a250        	BEQ	LAB_21C4		; go do next array string (loop always)
.a25d                              lab_21d1
.a25d  c8         iny              	INY				; increment index (Y was $00)
.a25e  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get var name byte 2
.a260  10 30      bpl $a292        	BPL	LAB_2206		; if not string, step pointer to next var and return
.a262  c8         iny              	INY				; else increment index
.a263                              lab_21d7
.a263  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string length
.a265  f0 2b      beq $a292        	BEQ	LAB_2206		; if null, step pointer to next string and return
.a267  c8         iny              	INY				; else increment index
.a268  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte
.a26a  aa         tax              	TAX				; copy to X
.a26b  c8         iny              	INY				; increment index
.a26c  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte
.a26e  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.a270  90 06      bcc $a278        	BCC	LAB_21EC		; branch if less
.a272  d0 1e      bne $a292        	BNE	LAB_2206		; if greater, step pointer to next string and return
.a274  e4 81      cpx $81          	CPX	Sstorl		; compare bottom of string space low byte
.a276  b0 1a      bcs $a292        	BCS	LAB_2206		; if >=, step pointer to next string and return
.a278                              lab_21ec
.a278  c5 ab      cmp $ab          	CMP	Histrh		; compare to highest string high byte
.a27a  90 17      bcc $a293        	BCC	LAB_2207		; if <, step pointer to next string and return
.a27c  d0 04      bne $a282        	BNE	LAB_21F6		; if > update pointers, step to next and return
.a27e  e4 aa      cpx $aa          	CPX	Histrl		; compare to highest string low byte
.a280  90 11      bcc $a293        	BCC	LAB_2207		; if <, step pointer to next string and return
.a282                              lab_21f6
.a282  86 aa      stx $aa          	STX	Histrl		; save as new highest string low byte
.a284  85 ab      sta $ab          	STA	Histrh		; save as new highest string high byte
.a286  a5 71      lda $71          	LDA	ut1_pl		; get start of vars(descriptors) low byte
.a288  a6 72      ldx $72          	LDX	ut1_ph		; get start of vars(descriptors) high byte
.a28a  85 9c      sta $9c          	STA	garb_l		; save as working pointer low byte
.a28c  86 9d      stx $9d          	STX	garb_h		; save as working pointer high byte
.a28e  88         dey              	DEY				; decrement index DIFFERS
.a28f  88         dey              	DEY				; decrement index (should point to descriptor start)
.a290  84 a2      sty $a2          	STY	g_indx		; save index pointer
.a292                              lab_2206
.a292  18         clc              	CLC				; clear carry for add
.a293                              lab_2207
.a293  a5 a0      lda $a0          	LDA	g_step		; get step size
.a295                              lab_2208
.a295  65 71      adc $71          	ADC	ut1_pl		; add pointer low byte
.a297  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.a299  90 02      bcc $a29d        	BCC	LAB_2211		; branch if no overflow
.a29b  e6 72      inc $72          	INC	ut1_ph		; else increment high byte
.a29d                              lab_2211
.a29d  a6 72      ldx $72          	LDX	ut1_ph		; get pointer high byte
.a29f  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a2a1  60         rts              	RTS
.a2a2                              lab_2216
.a2a2  c6 a0      dec $a0          	DEC	g_step		; decrement step size (now $03 for descriptor stack)
.a2a4  a6 9d      ldx $9d          	LDX	garb_h		; get string to move high byte
.a2a6  f0 f5      beq $a29d        	BEQ	LAB_2211		; exit if nothing to move
.a2a8  a4 a2      ldy $a2          	LDY	g_indx		; get index byte back (points to descriptor)
.a2aa  18         clc              	CLC				; clear carry for add
.a2ab  b1 9c      lda ($9c),y      	LDA	(garb_l),Y		; get string length
.a2ad  65 aa      adc $aa          	ADC	Histrl		; add highest string low byte
.a2af  85 a6      sta $a6          	STA	Obendl		; save old block end low pointer
.a2b1  a5 ab      lda $ab          	LDA	Histrh		; get highest string high byte
.a2b3  69 00      adc #$00         	ADC	#$00			; add any carry
.a2b5  85 a7      sta $a7          	STA	Obendh		; save old block end high byte
.a2b7  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.a2b9  a6 82      ldx $82          	LDX	Sstorh		; get bottom of string space high byte
.a2bb  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte
.a2bd  86 a5      stx $a5          	STX	Nbendh		; save new block end high byte
.a2bf  20 c8 90   jsr $90c8        	JSR	LAB_11D6		; open up space in memory, don't set array end
.a2c2  a4 a2      ldy $a2          	LDY	g_indx		; get index byte
.a2c4  c8         iny              	INY				; point to descriptor low byte
.a2c5  a5 a4      lda $a4          	LDA	Nbendl		; get string pointer low byte
.a2c7  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer low byte
.a2c9  aa         tax              	TAX				; copy string pointer low byte
.a2ca  e6 a5      inc $a5          	INC	Nbendh		; correct high byte (move sets high byte -1)
.a2cc  a5 a5      lda $a5          	LDA	Nbendh		; get new string pointer high byte
.a2ce  c8         iny              	INY				; point to descriptor high byte
.a2cf  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer high byte
.a2d1  4c e3 a1   jmp $a1e3        	JMP	LAB_214B		; re-run routine from last ending
.a2d4                              lab_224d
.a2d4  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.a2d6  48         pha              	PHA				; put on stack
.a2d7  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.a2d9  48         pha              	PHA				; put on stack
.a2da  20 cd 9b   jsr $9bcd        	JSR	LAB_GVAL		; get value from line
.a2dd  20 d2 9a   jsr $9ad2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.a2e0  68         pla              	PLA				; get descriptor pointer low byte back
.a2e1  85 b8      sta $b8          	STA	ssptr_l		; set pointer low byte
.a2e3  68         pla              	PLA				; get descriptor pointer high byte back
.a2e4  85 b9      sta $b9          	STA	ssptr_h		; set pointer high byte
.a2e6  a0 00      ldy #$00         	LDY	#$00			; clear index
.a2e8  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get length_1 from descriptor
.a2ea  18         clc              	CLC				; clear carry for add
.a2eb  71 ae      adc ($ae),y      	ADC	(des_pl),Y		; add length_2
.a2ed  90 05      bcc $a2f4        	BCC	LAB_226D		; branch if no overflow
.a2ef  a2 1a      ldx #$1a         	LDX	#$1A			; else set error code $1A ("String too long" error)
.a2f1  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.a2f4                              lab_226d
.a2f4  20 32 a1   jsr $a132        	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.a2f7  20 11 a3   jsr $a311        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.a2fa  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.a2fc  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.a2fe  20 42 a3   jsr $a342        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.a301  20 23 a3   jsr $a323        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.a304  a5 b8      lda $b8          	LDA	ssptr_l		;.set descriptor pointer low byte
.a306  a4 b9      ldy $b9          	LDY	ssptr_h		;.set descriptor pointer high byte
.a308  20 42 a3   jsr $a342        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.a30b  20 85 a1   jsr $a185        	JSR	LAB_RTST		; check for space on descriptor stack then put string
.a30e  4c f8 9a   jmp $9af8        	JMP	LAB_1ADB		;.continue evaluation
.a311                              lab_228a
.a311  a0 00      ldy #$00         	LDY	#$00			; clear index
.a313  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get string length
.a315  48         pha              	PHA				; save on stack
.a316  c8         iny              	INY				; increment index
.a317  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer low byte
.a319  aa         tax              	TAX				; copy to X
.a31a  c8         iny              	INY				; increment index
.a31b  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer high byte
.a31d  a8         tay              	TAY				; copy to Y
.a31e  68         pla              	PLA				; get length back
.a31f                              lab_2298
.a31f  86 71      stx $71          	STX	ut1_pl		; save source string pointer low byte
.a321  84 72      sty $72          	STY	ut1_ph		; save source string pointer high byte
.a323                              lab_229c
.a323  aa         tax              	TAX				; copy length to index (don't count with Y)
.a324  f0 14      beq $a33a        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
.a326  a0 00      ldy #$00         	LDY	#$00			; zero pointer (copy forward)
.a328                              lab_22a0
.a328  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get source byte
.a32a  91 83      sta ($83),y      	STA	(Sutill),Y		; save destination byte
.a32c  c8         iny              	INY				; increment index
.a32d  ca         dex              	DEX				; decrement counter
.a32e  d0 f8      bne $a328        	BNE	LAB_22A0		; loop while <> 0
.a330  98         tya              	TYA				; restore length from Y
.a331                              lab_22a9
.a331  18         clc              	CLC				; clear carry for add
.a332  65 83      adc $83          	ADC	Sutill		; add string utility ptr low byte
.a334  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.a336  90 02      bcc $a33a        	BCC	LAB_22B2		; branch if no carry
.a338  e6 84      inc $84          	INC	Sutilh		; else increment string utility ptr high byte
.a33a                              lab_22b2
.a33a  60         rts              	RTS
.a33b                              lab_evst
.a33b  20 d2 9a   jsr $9ad2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.a33e                              lab_22b6
.a33e  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.a340  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.a342                              lab_22ba
.a342  85 71      sta $71          	STA	ut1_pl		; save descriptor pointer low byte
.a344  84 72      sty $72          	STY	ut1_ph		; save descriptor pointer high byte
.a346  20 73 a3   jsr $a373        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.a349  08         php              	PHP				; save status flags
.a34a  a0 00      ldy #$00         	LDY	#$00			; clear index
.a34c  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get length from string descriptor
.a34e  48         pha              	PHA				; put on stack
.a34f  c8         iny              	INY				; increment index
.a350  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
.a352  aa         tax              	TAX				; copy to X
.a353  c8         iny              	INY				; increment index
.a354  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
.a356  a8         tay              	TAY				; copy to Y
.a357  68         pla              	PLA				; get string length back
.a358  28         plp              	PLP				; restore status
.a359  d0 13      bne $a36e        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
.a35b  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string space high byte
.a35d  d0 0f      bne $a36e        	BNE	LAB_22E6		; branch if <>
.a35f  e4 81      cpx $81          	CPX	Sstorl		; else compare bottom of string space low byte
.a361  d0 0b      bne $a36e        	BNE	LAB_22E6		; branch if <>
.a363  48         pha              	PHA				; save string length
.a364  18         clc              	CLC				; clear carry for add
.a365  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte
.a367  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.a369  90 02      bcc $a36d        	BCC	LAB_22E5		; skip increment if no overflow
.a36b  e6 82      inc $82          	INC	Sstorh		; increment bottom of string space high byte
.a36d                              lab_22e5
.a36d  68         pla              	PLA				; restore string length
.a36e                              lab_22e6
.a36e  86 71      stx $71          	STX	ut1_pl		; save string pointer low byte
.a370  84 72      sty $72          	STY	ut1_ph		; save string pointer high byte
.a372  60         rts              	RTS
.a373                              lab_22eb
.a373  c4 67      cpy $67          	CPY	last_sh		; compare pointer high byte
.a375  d0 0c      bne $a383        	BNE	LAB_22FB		; exit if <>
.a377  c5 66      cmp $66          	CMP	last_sl		; compare pointer low byte
.a379  d0 08      bne $a383        	BNE	LAB_22FB		; exit if <>
.a37b  85 65      sta $65          	STA	next_s		; save descriptor stack pointer
.a37d  e9 03      sbc #$03         	SBC	#$03			; -3
.a37f  85 66      sta $66          	STA	last_sl		; save low byte -3
.a381  a0 00      ldy #$00         	LDY	#$00			; clear high byte
.a383                              lab_22fb
.a383  60         rts              	RTS
.a384                              lab_chrs
.a384  20 8f a4   jsr $a48f        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.a387  8a         txa              	TXA				; copy to A
.a388  48         pha              	PHA				; save character
.a389  a9 01      lda #$01         	LDA	#$01			; string is single byte
.a38b  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.a38e  68         pla              	PLA				; get character back
.a38f  a0 00      ldy #$00         	LDY	#$00			; clear index
.a391  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.a393  4c 85 a1   jmp $a185        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.a396                              lab_left
.a396  48         pha              	PHA				; push byte parameter
.a397  20 f7 a3   jsr $a3f7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.a39a  d1 9e      cmp ($9e),y      	CMP	(des_2l),Y		; compare byte parameter with string length
.a39c  98         tya              	TYA				; clear A
.a39d  f0 09      beq $a3a8        	BEQ	LAB_2316		; go do string copy (branch always)
.a39f                              lab_right
.a39f  48         pha              	PHA				; push byte parameter
.a3a0  20 f7 a3   jsr $a3f7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.a3a3  18         clc              	CLC				; clear carry for add-1
.a3a4  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.a3a6  49 ff      eor #$ff         	EOR	#$FF			; invert it (A=LEN(expression$)-l)
.a3a8                              lab_2316
.a3a8  90 04      bcc $a3ae        	BCC	LAB_231C		; branch if string length > byte parameter
.a3aa  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; else make parameter = length
.a3ac  aa         tax              	TAX				; copy to byte parameter copy
.a3ad  98         tya              	TYA				; clear string start offset
.a3ae                              lab_231c
.a3ae  48         pha              	PHA				; save string start offset
.a3af                              lab_231d
.a3af  8a         txa              	TXA				; copy byte parameter (or string length if <)
.a3b0                              lab_231e
.a3b0  48         pha              	PHA				; save string length
.a3b1  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.a3b4  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.a3b6  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.a3b8  20 42 a3   jsr $a342        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.a3bb  68         pla              	PLA				; get string length back
.a3bc  a8         tay              	TAY				; copy length to Y
.a3bd  68         pla              	PLA				; get string start offset back
.a3be  18         clc              	CLC				; clear carry for add
.a3bf  65 71      adc $71          	ADC	ut1_pl		; add start offset to string start pointer low byte
.a3c1  85 71      sta $71          	STA	ut1_pl		; save string start pointer low byte
.a3c3  90 02      bcc $a3c7        	BCC	LAB_2335		; branch if no overflow
.a3c5  e6 72      inc $72          	INC	ut1_ph		; else increment string start pointer high byte
.a3c7                              lab_2335
.a3c7  98         tya              	TYA				; copy length to A
.a3c8  20 23 a3   jsr $a323        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.a3cb  4c 85 a1   jmp $a185        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.a3ce                              lab_mids
.a3ce  48         pha              	PHA				; push byte parameter
.a3cf  a9 ff      lda #$ff         	LDA	#$FF			; set default length = 255
.a3d1  85 af      sta $af          	STA	mids_l		; save default length
.a3d3  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a3d6  c9 29      cmp #$29         	CMP	#")"			; compare with ")"
.a3d8  f0 06      beq $a3e0        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
.a3da  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.a3dd  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
.a3e0                              lab_2358
.a3e0  20 f7 a3   jsr $a3f7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.a3e3  ca         dex              	DEX				; decrement start index
.a3e4  8a         txa              	TXA				; copy to A
.a3e5  48         pha              	PHA				; save string start offset
.a3e6  18         clc              	CLC				; clear carry for sub-1
.a3e7  a2 00      ldx #$00         	LDX	#$00			; clear output string length
.a3e9  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.a3eb  b0 c2      bcs $a3af        	BCS	LAB_231D		; if start>string length go do null string
.a3ed  49 ff      eor #$ff         	EOR	#$FF			; complement -length
.a3ef  c5 af      cmp $af          	CMP	mids_l		; compare byte parameter
.a3f1  90 bd      bcc $a3b0        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
.a3f3  a5 af      lda $af          	LDA	mids_l		; get length byte
.a3f5  b0 b9      bcs $a3b0        	BCS	LAB_231E		; go do string copy (branch always)
.a3f7                              lab_236f
.a3f7  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.a3fa  68         pla              	PLA				; pull return address low byte (return address)
.a3fb  85 a2      sta $a2          	STA	Fnxjpl		; save functions jump vector low byte
.a3fd  68         pla              	PLA				; pull return address high byte (return address)
.a3fe  85 a3      sta $a3          	STA	Fnxjph		; save functions jump vector high byte
.a400  68         pla              	PLA				; pull byte parameter
.a401  aa         tax              	TAX				; copy byte parameter to X
.a402  68         pla              	PLA				; pull string pointer low byte
.a403  85 9e      sta $9e          	STA	des_2l		; save it
.a405  68         pla              	PLA				; pull string pointer high byte
.a406  85 9f      sta $9f          	STA	des_2h		; save it
.a408  a0 00      ldy #$00         	LDY	#$00			; clear index
.a40a  8a         txa              	TXA				; copy byte parameter
.a40b  f0 79      beq $a486        	BEQ	LAB_23A8		; if null do function call error then warm start
.a40d  e6 a2      inc $a2          	INC	Fnxjpl		; increment function jump vector low byte
.a40f  6c a2 00   jmp ($00a2)      	JMP	(Fnxjpl)		; in effect, RTS
.a412                              lab_lcase
.a412  20 3b a3   jsr $a33b        	JSR	LAB_EVST		; evaluate string
.a415  85 ac      sta $ac          	STA	str_ln		; set string length
.a417  a8         tay              	TAY				; copy length to Y
.a418  f0 38      beq $a452        	BEQ	NoString		; branch if null string
.a41a  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long A=length,
.a41d  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.a41f  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.a421  a8         tay              	TAY				; get string length back
.a422                              lc_loop
.a422  88         dey              	DEY				; decrement index
.a423  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.a425  20 22 9e   jsr $9e22        	JSR	LAB_1D82		; is character "A" to "Z"
.a428  90 02      bcc $a42c        	BCC	NoUcase		; branch if not upper case alpha
.a42a  09 20      ora #$20         	ORA	#$20			; convert upper to lower case
.a42c                              noucase
.a42c  91 83      sta ($83),y      	STA	(Sutill),Y		; save byte back to string
.a42e  98         tya              	TYA				; test index
.a42f  d0 f1      bne $a422        	BNE	LC_loop		; loop if not all done
.a431  f0 1f      beq $a452        	BEQ	NoString		; tidy up and exit, branch always
.a433                              lab_ucase
.a433  20 3b a3   jsr $a33b        	JSR	LAB_EVST		; evaluate string
.a436  85 ac      sta $ac          	STA	str_ln		; set string length
.a438  a8         tay              	TAY				; copy length to Y
.a439  f0 17      beq $a452        	BEQ	NoString		; branch if null string
.a43b  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long A=length,
.a43e  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.a440  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.a442  a8         tay              	TAY				; get string length back
.a443                              uc_loop
.a443  88         dey              	DEY				; decrement index
.a444  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.a446  20 1e 9e   jsr $9e1e        	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
.a449  90 02      bcc $a44d        	BCC	NoLcase		; branch if not alpha
.a44b  29 df      and #$df         	AND	#$DF			; convert lower to upper case
.a44d                              nolcase
.a44d  91 83      sta ($83),y      	STA	(Sutill),Y		; save byte back to string
.a44f  98         tya              	TYA				; test index
.a450  d0 f1      bne $a443        	BNE	UC_loop		; loop if not all done
.a452                              nostring
.a452  4c 85 a1   jmp $a185        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.a455                              lab_sadd
.a455  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.a458  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var address
.a45b  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.a45e  20 d2 9a   jsr $9ad2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.a461  a0 02      ldy #$02         	LDY	#$02			; index to string pointer high byte
.a463  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get string pointer high byte
.a465  aa         tax              	TAX				; copy string pointer high byte to X
.a466  88         dey              	DEY				; index to string pointer low byte
.a467  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get string pointer low byte
.a469  a8         tay              	TAY				; copy string pointer low byte to Y
.a46a  8a         txa              	TXA				; copy string pointer high byte to A
.a46b  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.a46e                              lab_lens
.a46e  20 74 a4   jsr $a474        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.a471  4c 66 a0   jmp $a066        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.a474                              lab_esgl
.a474  20 3b a3   jsr $a33b        	JSR	LAB_EVST		; evaluate string
.a477  a8         tay              	TAY				; copy length to Y
.a478  60         rts              	RTS
.a479                              lab_asc
.a479  20 74 a4   jsr $a474        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.a47c  f0 08      beq $a486        	BEQ	LAB_23A8		; if null do function call error then warm start
.a47e  a0 00      ldy #$00         	LDY	#$00			; set index to first character
.a480  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.a482  a8         tay              	TAY				; copy to Y
.a483  4c 66 a0   jmp $a066        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.a486                              lab_23a8
.a486  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start
.a489                              lab_sgby
.a489  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.a48c                              lab_gtby
.a48c  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a48f                              lab_evby
.a48f  20 a2 9e   jsr $9ea2        	JSR	LAB_EVPI		; evaluate integer expression (no check)
.a492  a4 ae      ldy $ae          	LDY	FAC1_2		; get FAC1 mantissa2
.a494  d0 f0      bne $a486        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
.a496  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.a498  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.a49b                              lab_val
.a49b  20 74 a4   jsr $a474        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.a49e  d0 03      bne $a4a3        	BNE	LAB_23C5		; branch if not null string
.a4a0  4c 50 a6   jmp $a650        	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.a4a3                              lab_23c5
.a4a3  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.a4a5  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.a4a7  86 ba      stx $ba          	STX	Btmpl			; save BASIC execute pointer low byte
.a4a9  84 bb      sty $bb          	STY	Btmph			; save BASIC execute pointer high byte
.a4ab  a6 71      ldx $71          	LDX	ut1_pl		; get string pointer low byte
.a4ad  86 c3      stx $c3          	STX	Bpntrl		; save as BASIC execute pointer low byte
.a4af  18         clc              	CLC				; clear carry
.a4b0  65 71      adc $71          	ADC	ut1_pl		; add string length
.a4b2  85 73      sta $73          	STA	ut2_pl		; save string end low byte
.a4b4  a5 72      lda $72          	LDA	ut1_ph		; get string pointer high byte
.a4b6  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.a4b8  69 00      adc #$00         	ADC	#$00			; add carry to high byte
.a4ba  85 74      sta $74          	STA	ut2_ph		; save string end high byte
.a4bc  a0 00      ldy #$00         	LDY	#$00			; set index to $00
.a4be  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get string end +1 byte
.a4c0  48         pha              	PHA				; push it
.a4c1  98         tya              	TYA				; clear A
.a4c2  91 73      sta ($73),y      	STA	(ut2_pl),Y		; terminate string with $00
.a4c4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a4c7  20 a6 a9   jsr $a9a6        	JSR	LAB_2887		; get FAC1 from string
.a4ca  68         pla              	PLA				; restore string end +1 byte
.a4cb  a0 00      ldy #$00         	LDY	#$00			; set index to zero
.a4cd  91 73      sta ($73),y      	STA	(ut2_pl),Y		; put string end byte back
.a4cf                              lab_23f3
.a4cf  a6 ba      ldx $ba          	LDX	Btmpl			; get BASIC execute pointer low byte back
.a4d1  a4 bb      ldy $bb          	LDY	Btmph			; get BASIC execute pointer high byte back
.a4d3  86 c3      stx $c3          	STX	Bpntrl		; save BASIC execute pointer low byte
.a4d5  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.a4d7  60         rts              	RTS
.a4d8                              lab_gadb
.a4d8  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a4db  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.a4de                              lab_scgb
.a4de  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.a4e1  a5 12      lda $12          	LDA	Itemph		; save temporary integer high byte
.a4e3  48         pha              	PHA				; on stack
.a4e4  a5 11      lda $11          	LDA	Itempl		; save temporary integer low byte
.a4e6  48         pha              	PHA				; on stack
.a4e7  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter
.a4ea  68         pla              	PLA				; pull low byte
.a4eb  85 11      sta $11          	STA	Itempl		; restore temporary integer low byte
.a4ed  68         pla              	PLA				; pull high byte
.a4ee  85 12      sta $12          	STA	Itemph		; restore temporary integer high byte
.a4f0  60         rts              	RTS
.a4f1                              lab_f2fx
.a4f1  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a4f3  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.a4f5  b0 8f      bcs $a486        	BCS	LAB_23A8		; if >= do function call error then warm start
.a4f7                              lab_f2fu
.a4f7  20 50 a9   jsr $a950        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.a4fa  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.a4fc  a4 af      ldy $af          	LDY	FAC1_3		; get FAC1 mantissa3
.a4fe  84 11      sty $11          	STY	Itempl		; save temporary integer low byte
.a500  85 12      sta $12          	STA	Itemph		; save temporary integer high byte
.a502  60         rts              	RTS
.a503                              lab_peek
.a503  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.a506  a2 00      ldx #$00         	LDX	#$00			; clear index
.a508  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; get byte via temporary integer (addr)
.a50a  a8         tay              	TAY				; copy byte to Y
.a50b  4c 66 a0   jmp $a066        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.a50e                              lab_poke
.a50e  20 d8 a4   jsr $a4d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.a511  8a         txa              	TXA				; copy byte argument to A
.a512  a2 00      ldx #$00         	LDX	#$00			; clear index
.a514  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.a516  60         rts              	RTS
.a517                              lab_deek
.a517  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.a51a  a2 00      ldx #$00         	LDX	#$00			; clear index
.a51c  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK low byte
.a51e  a8         tay              	TAY				; copy to Y
.a51f  e6 11      inc $11          	INC	Itempl		; increment pointer low byte
.a521  d0 02      bne $a525        	BNE	Deekh			; skip high increment if no rollover
.a523  e6 12      inc $12          	INC	Itemph		; increment pointer high byte
.a525                              deekh
.a525  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK high byte
.a527  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.a52a                              lab_doke
.a52a  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a52d  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.a530  84 97      sty $97          	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
.a532  85 98      sta $98          	STA	Frnxth		; save pointer high byte
.a534  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.a537  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a53a  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.a53d  98         tya              	TYA				; copy value low byte (float to fixed returns word in AY)
.a53e  a2 00      ldx #$00         	LDX	#$00			; clear index
.a540  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE low byte
.a542  e6 97      inc $97          	INC	Frnxtl		; increment pointer low byte
.a544  d0 02      bne $a548        	BNE	Dokeh			; skip high increment if no rollover
.a546  e6 98      inc $98          	INC	Frnxth		; increment pointer high byte
.a548                              dokeh
.a548  a5 12      lda $12          	LDA	Itemph		; get value high byte
.a54a  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE high byte
.a54c  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.a54f                              lab_swap
.a54f  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var1 address
.a552  85 97      sta $97          	STA	Lvarpl		; save var1 address low byte
.a554  84 98      sty $98          	STY	Lvarph		; save var1 address high byte
.a556  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.a558  48         pha              	PHA				; save data type flag
.a559  20 fe 9b   jsr $9bfe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.a55c  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
.a55f  68         pla              	PLA				; pull var1 data type flag
.a560  45 5f      eor $5f          	EOR	Dtypef		; compare with var2 data type
.a562  10 10      bpl $a574        	BPL	SwapErr		; exit if not both the same type
.a564  a0 03      ldy #$03         	LDY	#$03			; four bytes to swap (either value or descriptor+1)
.a566                              swaplp
.a566  b1 97      lda ($97),y      	LDA	(Lvarpl),Y		; get byte from var1
.a568  aa         tax              	TAX				; save var1 byte
.a569  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from var2
.a56b  91 97      sta ($97),y      	STA	(Lvarpl),Y		; save byte to var1
.a56d  8a         txa              	TXA				; restore var1 byte
.a56e  91 95      sta ($95),y      	STA	(Cvaral),Y		; save byte to var2
.a570  88         dey              	DEY				; decrement index
.a571  10 f3      bpl $a566        	BPL	SwapLp		; loop until done
.a573  60         rts              	RTS
.a574                              swaperr
.a574  4c dc 9a   jmp $9adc        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.a577                              lab_call
.a577  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.a57a  20 f1 a4   jsr $a4f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.a57d  a9 a5      lda #$a5         	LDA	#>CallExit		; set return address high byte
.a57f  48         pha              	PHA				; put on stack
.a580  a9 85      lda #$85         	LDA	#<CallExit-1	; set return address low byte
.a582  48         pha              	PHA				; put on stack
.a583  6c 11 00   jmp ($0011)      	JMP	(Itempl)		; do indirect jump to user routine
.a586                              callexit
.a586  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.a589                              lab_wait
.a589  20 d8 a4   jsr $a4d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.a58c  86 97      stx $97          	STX	Frnxtl		; save byte
.a58e  a2 00      ldx #$00         	LDX	#$00			; clear mask
.a590  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a593  f0 03      beq $a598        	BEQ	LAB_2441		; skip if no third argument
.a595  20 de a4   jsr $a4de        	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
.a598                              lab_2441
.a598  86 98      stx $98          	STX	Frnxth		; save EOR argument
.a59a                              lab_2445
.a59a  b1 11      lda ($11),y      	LDA	(Itempl),Y		; get byte via temporary integer (addr)
.a59c  45 98      eor $98          	EOR	Frnxth		; EOR with second argument (mask)
.a59e  25 97      and $97          	AND	Frnxtl		; AND with first argument (byte)
.a5a0  f0 f8      beq $a59a        	BEQ	LAB_2445		; loop if result is zero
.a5a2                              lab_244d
.a5a2  60         rts              	RTS
.a5a3                              lab_2455
.a5a3  20 8b a7   jsr $a78b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.a5a6                              lab_subtract
.a5a6  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a5a8  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a5aa  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a5ac  45 b7      eor $b7          	EOR	FAC2_s		; EOR with FAC2 sign (b7)
.a5ae  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.a5b0  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a5b2  4c c1 a5   jmp $a5c1        	JMP	LAB_ADD		; go add FAC2 to FAC1
.a5b5                              lab_2467
.a5b5  20 da a6   jsr $a6da        	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
.a5b8  90 4d      bcc $a607        	BCC	LAB_24A8		;.go subtract mantissas
.a5ba                              lab_244e
.a5ba  a9 e9      lda #$e9         	LDA	#<LAB_2A96		; set 0.5 pointer low byte
.a5bc  a0 b1      ldy #$b1         	LDY	#>LAB_2A96		; set 0.5 pointer high byte
.a5be                              lab_246c
.a5be  20 8b a7   jsr $a78b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.a5c1                              lab_add
.a5c1  d0 10      bne $a5d3        	BNE	LAB_2474		; branch if FAC1 was not zero
.a5c3                              lab_279b
.a5c3  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.a5c5                              lab_279d
.a5c5  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a5c7  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to copy
.a5c9                              lab_27a1
.a5c9  b5 b2      lda $b2,x        	LDA	FAC1_o,X		; get byte from FAC2,X
.a5cb  95 ab      sta $ab,x        	STA	FAC1_e-1,X		; save byte at FAC1,X
.a5cd  ca         dex              	DEX				; decrement count
.a5ce  d0 f9      bne $a5c9        	BNE	LAB_27A1		; loop if not all done
.a5d0  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.a5d2  60         rts              	RTS
.a5d3                              lab_2474
.a5d3  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.a5d5  86 a3      stx $a3          	STX	FAC2_r		; save as FAC2 rounding byte
.a5d7  a2 b3      ldx #$b3         	LDX	#FAC2_e		; set index to FAC2 exponent addr
.a5d9  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.a5db                              lab_247c
.a5db  a8         tay              	TAY				; copy exponent
.a5dc  f0 c4      beq $a5a2        	BEQ	LAB_244D		; exit if zero
.a5de  38         sec              	SEC				; set carry for subtract
.a5df  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.a5e1  f0 24      beq $a607        	BEQ	LAB_24A8		; branch if = (go add mantissa)
.a5e3  90 12      bcc $a5f7        	BCC	LAB_2498		; branch if <
.a5e5  84 ac      sty $ac          	STY	FAC1_e		; save FAC1 exponent
.a5e7  a4 b7      ldy $b7          	LDY	FAC2_s		; get FAC2 sign (b7)
.a5e9  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.a5eb  49 ff      eor #$ff         	EOR	#$FF			; complement A
.a5ed  69 00      adc #$00         	ADC	#$00			; +1 (twos complement, carry is set)
.a5ef  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a5f1  84 a3      sty $a3          	STY	FAC2_r		; clear FAC2 rounding byte
.a5f3  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1 exponent addr
.a5f5  d0 04      bne $a5fb        	BNE	LAB_249C		; branch always
.a5f7                              lab_2498
.a5f7  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a5f9  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.a5fb                              lab_249c
.a5fb  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent diff with $F9
.a5fd  30 b6      bmi $a5b5        	BMI	LAB_2467		; branch if range $79-$F8
.a5ff  a8         tay              	TAY				; copy exponent difference to Y
.a600  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.a602  56 01      lsr $01,x        	LSR	PLUS_1,X		; shift FAC? mantissa1
.a604  20 f1 a6   jsr $a6f1        	JSR	LAB_2592		; shift FACX Y times right
.a607                              lab_24a8
.a607  24 b8      bit $b8          	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
.a609  10 4c      bpl $a657        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
.a60b  a0 ac      ldy #$ac         	LDY	#FAC1_e		; set index to FAC1 exponent addr
.a60d  e0 b3      cpx #$b3         	CPX	#FAC2_e		; compare X to FAC2 exponent addr
.a60f  f0 02      beq $a613        	BEQ	LAB_24B4		; branch if =
.a611  a0 b3      ldy #$b3         	LDY	#FAC2_e		; else set index to FAC2 exponent addr
.a613                              lab_24b4
.a613  38         sec              	SEC				; set carry for subtract
.a614  49 ff      eor #$ff         	EOR	#$FF			; ones complement A
.a616  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.a618  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.a61a  b9 03 00   lda $0003,y      	LDA	PLUS_3,Y		; get FACY mantissa3
.a61d  f5 03      sbc $03,x        	SBC	PLUS_3,X		; subtract FACX mantissa3
.a61f  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.a621  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get FACY mantissa2
.a624  f5 02      sbc $02,x        	SBC	PLUS_2,X		; subtract FACX mantissa2
.a626  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.a628  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get FACY mantissa1
.a62b  f5 01      sbc $01,x        	SBC	PLUS_1,X		; subtract FACX mantissa1
.a62d  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a62f                              lab_24d0
.a62f  b0 03      bcs $a634        	BCS	LAB_24D5		; branch if number is +ve
.a631  20 96 a6   jsr $a696        	JSR	LAB_2537		; negate FAC1
.a634                              lab_24d5
.a634  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a636  98         tya              	TYA				; clear A
.a637  18         clc              	CLC				; clear carry for add
.a638                              lab_24d9
.a638  a6 ad      ldx $ad          	LDX	FAC1_1		; get FAC1 mantissa1
.a63a  d0 3e      bne $a67a        	BNE	LAB_251B		; if not zero normalise FAC1
.a63c  a6 ae      ldx $ae          	LDX	FAC1_2		; get FAC1 mantissa2
.a63e  86 ad      stx $ad          	STX	FAC1_1		; save FAC1 mantissa1
.a640  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.a642  86 ae      stx $ae          	STX	FAC1_2		; save FAC1 mantissa2
.a644  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.a646  86 af      stx $af          	STX	FAC1_3		; save FAC1 mantissa3
.a648  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.a64a  69 08      adc #$08         	ADC	#$08			; add x to exponent offset
.a64c  c9 18      cmp #$18         	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
.a64e  d0 e8      bne $a638        	BNE	LAB_24D9		; loop if not max
.a650                              lab_24f1
.a650  a9 00      lda #$00         	LDA	#$00			; clear A
.a652                              lab_24f3
.a652  85 ac      sta $ac          	STA	FAC1_e		; set FAC1 exponent
.a654                              lab_24f5
.a654  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a656  60         rts              	RTS
.a657                              lab_24f8
.a657  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.a659  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.a65b  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.a65d  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.a65f  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.a661  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.a663  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.a665  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.a667  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.a669  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.a66b  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a66d  b0 1a      bcs $a689        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
.a66f  60         rts              	RTS				; else just exit
.a670                              lab_2511
.a670  69 01      adc #$01         	ADC	#$01			; add 1 to exponent offset
.a672  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.a674  26 af      rol $af          	ROL	FAC1_3		; shift FAC1 mantissa3
.a676  26 ae      rol $ae          	ROL	FAC1_2		; shift FAC1 mantissa2
.a678  26 ad      rol $ad          	ROL	FAC1_1		; shift FAC1 mantissa1
.a67a                              lab_251b
.a67a  10 f4      bpl $a670        	BPL	LAB_2511		; loop if not normalised
.a67c  38         sec              	SEC				; set carry for subtract
.a67d  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.a67f  b0 cf      bcs $a650        	BCS	LAB_24F1		; branch if underflow (set result = $0)
.a681  49 ff      eor #$ff         	EOR	#$FF			; complement exponent
.a683  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.a685  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a687                              lab_2528
.a687  90 0c      bcc $a695        	BCC	LAB_2536		; exit if no overflow
.a689                              lab_252a
.a689  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.a68b  f0 36      beq $a6c3        	BEQ	LAB_2564		; if zero do overflow error and warm start
.a68d  66 ad      ror $ad          	ROR	FAC1_1		; shift FAC1 mantissa1
.a68f  66 ae      ror $ae          	ROR	FAC1_2		; shift FAC1 mantissa2
.a691  66 af      ror $af          	ROR	FAC1_3		; shift FAC1 mantissa3
.a693  66 b9      ror $b9          	ROR	FAC1_r		; shift FAC1 rounding byte
.a695                              lab_2536
.a695  60         rts              	RTS
.a696                              lab_2537
.a696  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a698  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a69a  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a69c                              lab_253d
.a69c  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.a69e  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a6a0  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a6a2  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.a6a4  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a6a6  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.a6a8  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.a6aa  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a6ac  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.a6ae  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.a6b0  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a6b2  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.a6b4  e6 b9      inc $b9          	INC	FAC1_r		; increment FAC1 rounding byte
.a6b6  d0 0a      bne $a6c2        	BNE	LAB_2563		; exit if no overflow
.a6b8                              lab_2559
.a6b8  e6 af      inc $af          	INC	FAC1_3		; increment FAC1 mantissa3
.a6ba  d0 06      bne $a6c2        	BNE	LAB_2563		; finished if no rollover
.a6bc  e6 ae      inc $ae          	INC	FAC1_2		; increment FAC1 mantissa2
.a6be  d0 02      bne $a6c2        	BNE	LAB_2563		; finished if no rollover
.a6c0  e6 ad      inc $ad          	INC	FAC1_1		; increment FAC1 mantissa1
.a6c2                              lab_2563
.a6c2  60         rts              	RTS
.a6c3                              lab_2564
.a6c3  a2 0a      ldx #$0a         	LDX	#$0A			; error code $0A ("Overflow" error)
.a6c5  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.a6c8                              lab_2569
.a6c8  a2 74      ldx #$74         	LDX	#FACt_1-1		; set offset to FACtemp
.a6ca                              lab_256b
.a6ca  b4 03      ldy $03,x        	LDY	PLUS_3,X		; get FACX mantissa3
.a6cc  84 b9      sty $b9          	STY	FAC1_r		; save as FAC1 rounding byte
.a6ce  b4 02      ldy $02,x        	LDY	PLUS_2,X		; get FACX mantissa2
.a6d0  94 03      sty $03,x        	STY	PLUS_3,X		; save FACX mantissa3
.a6d2  b4 01      ldy $01,x        	LDY	PLUS_1,X		; get FACX mantissa1
.a6d4  94 02      sty $02,x        	STY	PLUS_2,X		; save FACX mantissa2
.a6d6  a4 b2      ldy $b2          	LDY	FAC1_o		; get FAC1 overflow byte
.a6d8  94 01      sty $01,x        	STY	PLUS_1,X		; save FACX mantissa1
.a6da                              lab_257b
.a6da  69 08      adc #$08         	ADC	#$08			; add 8 to shift count
.a6dc  30 ec      bmi $a6ca        	BMI	LAB_256B		; go do 8 shift if still -ve
.a6de  f0 ea      beq $a6ca        	BEQ	LAB_256B		; go do 8 shift if zero
.a6e0  e9 08      sbc #$08         	SBC	#$08			; else subtract 8 again
.a6e2  a8         tay              	TAY				; save count to Y
.a6e3  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.a6e5  b0 12      bcs $a6f9        	BCS	LAB_259A		;.
.a6e7                              lab_2588
.a6e7  16 01      asl $01,x        	ASL	PLUS_1,X		; shift FACX mantissa1
.a6e9  90 02      bcc $a6ed        	BCC	LAB_258E		; branch if +ve
.a6eb  f6 01      inc $01,x        	INC	PLUS_1,X		; this sets b7 eventually
.a6ed                              lab_258e
.a6ed  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
.a6ef  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
.a6f1                              lab_2592
.a6f1  76 02      ror $02,x        	ROR	PLUS_2,X		; shift FACX mantissa2
.a6f3  76 03      ror $03,x        	ROR	PLUS_3,X		; shift FACX mantissa3
.a6f5  6a         ror              	ROR				; shift FACX rounding byte
.a6f6  c8         iny              	INY				; increment exponent diff
.a6f7  d0 ee      bne $a6e7        	BNE	LAB_2588		; branch if range adjust not complete
.a6f9                              lab_259a
.a6f9  18         clc              	CLC				; just clear it
.a6fa  60         rts              	RTS
.a6fb                              lab_log
.a6fb  20 e9 a8   jsr $a8e9        	JSR	LAB_27CA		; test sign and zero
.a6fe  f0 02      beq $a702        	BEQ	LAB_25C4		; if zero do function call error then warm start
.a700  10 03      bpl $a705        	BPL	LAB_25C7		; skip error if +ve
.a702                              lab_25c4
.a702  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start (-ve)
.a705                              lab_25c7
.a705  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a707  e9 7f      sbc #$7f         	SBC	#$7F			; normalise it
.a709  48         pha              	PHA				; save it
.a70a  a9 80      lda #$80         	LDA	#$80			; set exponent to zero
.a70c  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a70e  a9 69      lda #$69         	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
.a710  a0 b1      ldy #$b1         	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
.a712  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
.a715  a9 6d      lda #$6d         	LDA	#<LAB_25B1		; set root2 pointer low byte
.a717  a0 b1      ldy #$b1         	LDY	#>LAB_25B1		; set root2 pointer high byte
.a719  20 01 a8   jsr $a801        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
.a71c  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.a71e  a0 b1      ldy #$b1         	LDY	#>LAB_259C		; set 1 pointer high byte
.a720  20 a3 a5   jsr $a5a3        	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
.a723  a9 5c      lda #$5c         	LDA	#<LAB_25A0		; set pointer low byte to counter
.a725  a0 b1      ldy #$b1         	LDY	#>LAB_25A0		; set pointer high byte to counter
.a727  20 51 ac   jsr $ac51        	JSR	LAB_2B6E		; ^2 then series evaluation
.a72a  a9 71      lda #$71         	LDA	#<LAB_25B5		; set -0.5 pointer low byte
.a72c  a0 b1      ldy #$b1         	LDY	#>LAB_25B5		; set -0.5 pointer high byte
.a72e  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1
.a731  68         pla              	PLA				; restore FAC1 exponent
.a732  20 45 aa   jsr $aa45        	JSR	LAB_2912		; evaluate new ASCII digit
.a735  a9 75      lda #$75         	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
.a737  a0 b1      ldy #$b1         	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
.a739                              lab_25fb
.a739  20 8b a7   jsr $a78b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.a73c                              lab_multiply
.a73c  f0 4c      beq $a78a        	BEQ	LAB_264C		; exit if zero
.a73e  20 b1 a7   jsr $a7b1        	JSR	LAB_2673		; test and adjust accumulators
.a741  a9 00      lda #$00         	LDA	#$00			; clear A
.a743  85 75      sta $75          	STA	FACt_1		; clear temp mantissa1
.a745  85 76      sta $76          	STA	FACt_2		; clear temp mantissa2
.a747  85 77      sta $77          	STA	FACt_3		; clear temp mantissa3
.a749  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.a74b  20 60 a7   jsr $a760        	JSR	LAB_2622		; go do shift/add FAC2
.a74e  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.a750  20 60 a7   jsr $a760        	JSR	LAB_2622		; go do shift/add FAC2
.a753  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.a755  20 60 a7   jsr $a760        	JSR	LAB_2622		; go do shift/add FAC2
.a758  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.a75a  20 65 a7   jsr $a765        	JSR	LAB_2627		; go do shift/add FAC2
.a75d  4c 6e a8   jmp $a86e        	JMP	LAB_273C		; copy temp to FAC1, normalise and return
.a760                              lab_2622
.a760  d0 03      bne $a765        	BNE	LAB_2627		; branch if byte <> zero
.a762  4c c8 a6   jmp $a6c8        	JMP	LAB_2569		; shift FCAtemp << A+8 times
.a765                              lab_2627
.a765  4a         lsr              	LSR				; shift byte
.a766  09 80      ora #$80         	ORA	#$80			; set top bit (mark for 8 times)
.a768                              lab_262a
.a768  a8         tay              	TAY				; copy result
.a769  90 13      bcc $a77e        	BCC	LAB_2640		; skip next if bit was zero
.a76b  18         clc              	CLC				; clear carry for add
.a76c  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.a76e  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.a770  85 77      sta $77          	STA	FACt_3		; save temp mantissa3
.a772  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.a774  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.a776  85 76      sta $76          	STA	FACt_2		; save temp mantissa2
.a778  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.a77a  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.a77c  85 75      sta $75          	STA	FACt_1		; save temp mantissa1
.a77e                              lab_2640
.a77e  66 75      ror $75          	ROR	FACt_1		; shift temp mantissa1
.a780  66 76      ror $76          	ROR	FACt_2		; shift temp mantissa2
.a782  66 77      ror $77          	ROR	FACt_3		; shift temp mantissa3
.a784  66 b9      ror $b9          	ROR	FAC1_r		; shift temp rounding byte
.a786  98         tya              	TYA				; get byte back
.a787  4a         lsr              	LSR				; shift byte
.a788  d0 de      bne $a768        	BNE	LAB_262A		; loop if all bits not done
.a78a                              lab_264c
.a78a  60         rts              	RTS
.a78b                              lab_264d
.a78b  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.a78d  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.a78f  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to get (0-3)
.a791  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa3
.a793  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.a795  88         dey              	DEY				; decrement index
.a796  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa2
.a798  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.a79a  88         dey              	DEY				; decrement index
.a79b  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa1+sign
.a79d  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.a79f  45 b0      eor $b0          	EOR	FAC1_s		; EOR with FAC1 sign (b7)
.a7a1  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.a7a3  a5 b7      lda $b7          	LDA	FAC2_s		; recover FAC2 sign (b7)
.a7a5  09 80      ora #$80         	ORA	#$80			; set 1xxx xxx (set normal bit)
.a7a7  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.a7a9  88         dey              	DEY				; decrement index
.a7aa  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get exponent byte
.a7ac  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.a7ae  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a7b0  60         rts              	RTS
.a7b1                              lab_2673
.a7b1  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.a7b3                              lab_2675
.a7b3  f0 1d      beq $a7d2        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
.a7b5  18         clc              	CLC				; clear carry for add
.a7b6  65 ac      adc $ac          	ADC	FAC1_e		; add FAC1 exponent
.a7b8  90 04      bcc $a7be        	BCC	LAB_2680		; branch if sum of exponents <$0100
.a7ba  30 31      bmi $a7ed        	BMI	LAB_269B		; do overflow error
.a7bc  18         clc              	CLC				; clear carry for the add

>a7bd  2c                          	.byte	$2C			; makes next line BIT $1410
.a7be                              lab_2680

.a7be  10 12      bpl $a7d2        	BPL	LAB_2696		; if +ve go handle underflow
.a7c0  69 80      adc #$80         	ADC	#$80			; adjust exponent
.a7c2  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a7c4  d0 03      bne $a7c9        	BNE	LAB_268B		; branch if not zero
.a7c6  4c 54 a6   jmp $a654        	JMP	LAB_24F5		; save FAC1 sign and return
.a7c9                              lab_268b
.a7c9  a5 b8      lda $b8          	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
.a7cb  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a7cd                              lab_268f
.a7cd  60         rts              	RTS
.a7ce                              lab_2690
.a7ce  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a7d0  10 1b      bpl $a7ed        	BPL	LAB_269B		; do overflow error
.a7d2                              lab_2696
.a7d2  68         pla              	PLA				; pop return address low byte
.a7d3  68         pla              	PLA				; pop return address high byte
.a7d4  4c 50 a6   jmp $a650        	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.a7d7                              lab_269e
.a7d7  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.a7da  aa         tax              	TAX				; copy exponent (set the flags)
.a7db  f0 f0      beq $a7cd        	BEQ	LAB_268F		; exit if zero
.a7dd  18         clc              	CLC				; clear carry for add
.a7de  69 02      adc #$02         	ADC	#$02			; add two to exponent (*4)
.a7e0  b0 0b      bcs $a7ed        	BCS	LAB_269B		; do overflow error if > $FF
.a7e2  a2 00      ldx #$00         	LDX	#$00			; clear byte
.a7e4  86 b8      stx $b8          	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.a7e6  20 db a5   jsr $a5db        	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
.a7e9  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*10)
.a7eb  d0 e0      bne $a7cd        	BNE	LAB_268F		; if non zero just do RTS
.a7ed                              lab_269b
.a7ed  4c c3 a6   jmp $a6c3        	JMP	LAB_2564		; do overflow error and warm start
.a7f0                              lab_26b9
.a7f0  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.a7f3  a9 f1      lda #$f1         	LDA	#<LAB_26B5		; set pointer to 10d low addr
.a7f5  a0 b1      ldy #$b1         	LDY	#>LAB_26B5		; set pointer to 10d high addr
.a7f7  a2 00      ldx #$00         	LDX	#$00			; clear sign
.a7f9                              lab_26c2
.a7f9  86 b8      stx $b8          	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.a7fb  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.a7fe  4c 04 a8   jmp $a804        	JMP	LAB_DIVIDE		; do FAC2/FAC1
.a801                              lab_26ca
.a801  20 8b a7   jsr $a78b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.a804                              lab_divide
.a804  f0 63      beq $a869        	BEQ	LAB_2737		; if zero go do /0 error
.a806  20 d9 a8   jsr $a8d9        	JSR	LAB_27BA		; round FAC1
.a809  a9 00      lda #$00         	LDA	#$00			; clear A
.a80b  38         sec              	SEC				; set carry for subtract
.a80c  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
.a80e  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a810  20 b1 a7   jsr $a7b1        	JSR	LAB_2673		; test and adjust accumulators
.a813  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.a815  f0 d6      beq $a7ed        	BEQ	LAB_269B		; if zero do overflow error
.a817  a2 ff      ldx #$ff         	LDX	#$FF			; set index for pre increment
.a819  a9 01      lda #$01         	LDA	#$01			; set bit to flag byte save
.a81b                              lab_26e4
.a81b  a4 b4      ldy $b4          	LDY	FAC2_1		; get FAC2 mantissa1
.a81d  c4 ad      cpy $ad          	CPY	FAC1_1		; compare FAC1 mantissa1
.a81f  d0 0a      bne $a82b        	BNE	LAB_26F4		; branch if <>
.a821  a4 b5      ldy $b5          	LDY	FAC2_2		; get FAC2 mantissa2
.a823  c4 ae      cpy $ae          	CPY	FAC1_2		; compare FAC1 mantissa2
.a825  d0 04      bne $a82b        	BNE	LAB_26F4		; branch if <>
.a827  a4 b6      ldy $b6          	LDY	FAC2_3		; get FAC2 mantissa3
.a829  c4 af      cpy $af          	CPY	FAC1_3		; compare FAC1 mantissa3
.a82b                              lab_26f4
.a82b  08         php              	PHP				; save FAC2-FAC1 compare status
.a82c  2a         rol              	ROL				; shift the result byte
.a82d  90 0e      bcc $a83d        	BCC	LAB_2702		; if no carry skip the byte save
.a82f  a0 01      ldy #$01         	LDY	#$01			; set bit to flag byte save
.a831  e8         inx              	INX				; else increment the index to FACt
.a832  e0 02      cpx #$02         	CPX	#$02			; compare with the index to FACt_3
.a834  30 04      bmi $a83a        	BMI	LAB_2701		; if not last byte just go save it
.a836  d0 28      bne $a860        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
.a838  a0 40      ldy #$40         	LDY	#$40			; set bit to flag byte save for the rounding byte
.a83a                              lab_2701
.a83a  95 75      sta $75,x        	STA	FACt_1,X		; write result byte to FACt_1 + index
.a83c  98         tya              	TYA				; copy the next save byte flag
.a83d                              lab_2702
.a83d  28         plp              	PLP				; restore FAC2-FAC1 compare status
.a83e  90 14      bcc $a854        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
.a840  a8         tay              	TAY				; save FAC2-FAC1 compare status
.a841  a5 b6      lda $b6          	LDA	FAC2_3		; get FAC2 mantissa3
.a843  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.a845  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.a847  a5 b5      lda $b5          	LDA	FAC2_2		; get FAC2 mantissa2
.a849  e5 ae      sbc $ae          	SBC	FAC1_2		; subtract FAC1 mantissa2
.a84b  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.a84d  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.a84f  e5 ad      sbc $ad          	SBC	FAC1_1		; subtract FAC1 mantissa1
.a851  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.a853  98         tya              	TYA				; restore FAC2-FAC1 compare status
.a854                              lab_2704
.a854  06 b6      asl $b6          	ASL	FAC2_3		; shift FAC2 mantissa3
.a856  26 b5      rol $b5          	ROL	FAC2_2		; shift FAC2 mantissa2
.a858  26 b4      rol $b4          	ROL	FAC2_1		; shift FAC2 mantissa1
.a85a  b0 cf      bcs $a82b        	BCS	LAB_26F4		; loop with no compare
.a85c  30 bd      bmi $a81b        	BMI	LAB_26E4		; loop with compare
.a85e  10 cb      bpl $a82b        	BPL	LAB_26F4		; loop always with no compare
.a860                              lab_272b
.a860  4a         lsr              	LSR				; shift b1 - b0 ..
.a861  6a         ror              	ROR				; ..
.a862  6a         ror              	ROR				; .. to b7 - b6
.a863  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.a865  28         plp              	PLP				; dump FAC2-FAC1 compare status
.a866  4c 6e a8   jmp $a86e        	JMP	LAB_273C		; copy temp to FAC1, normalise and return
.a869                              lab_2737
.a869  a2 14      ldx #$14         	LDX	#$14			; error code $14 ("Divide by zero" error)
.a86b  4c 3c 91   jmp $913c        	JMP	LAB_XERR		; do error #X, then warm start
.a86e                              lab_273c
.a86e  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.a870  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a872  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.a874  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.a876  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.a878  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.a87a  4c 34 a6   jmp $a634        	JMP	LAB_24D5		; normalise FAC1 and return
.a87d                              lab_ufac
.a87d  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.a87f  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.a881  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to do
.a883  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last byte
.a885  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.a887  88         dey              	DEY				; decrement index
.a888  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last-1 byte
.a88a  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.a88c  88         dey              	DEY				; decrement index
.a88d  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get second byte
.a88f  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.a891  09 80      ora #$80         	ORA	#$80			; set 1xxx xxxx (add normal bit)
.a893  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a895  88         dey              	DEY				; decrement index
.a896  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get first byte (exponent)
.a898  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a89a  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.a89c  60         rts              	RTS
.a89d                              lab_276e
.a89d  a2 a4      ldx #$a4         	LDX	#<Adatal		; set pointer low byte
.a89f                              lab_2770
.a89f  a0 00      ldy #$00         	LDY	#>Adatal		; set pointer high byte
.a8a1  f0 04      beq $a8a7        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
.a8a3                              lab_pfac
.a8a3  a6 97      ldx $97          	LDX	Lvarpl		; get destination pointer low byte
.a8a5  a4 98      ldy $98          	LDY	Lvarph		; get destination pointer high byte
.a8a7                              lab_2778
.a8a7  20 d9 a8   jsr $a8d9        	JSR	LAB_27BA		; round FAC1
.a8aa  86 71      stx $71          	STX	ut1_pl		; save pointer low byte
.a8ac  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.a8ae  a0 03      ldy #$03         	LDY	#$03			; set index
.a8b0  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.a8b2  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.a8b4  88         dey              	DEY				; decrement index
.a8b5  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.a8b7  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.a8b9  88         dey              	DEY				; decrement index
.a8ba  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a8bc  09 7f      ora #$7f         	ORA	#$7F			; set bits x111 1111
.a8be  25 ad      and $ad          	AND	FAC1_1		; AND in FAC1 mantissa1
.a8c0  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.a8c2  88         dey              	DEY				; decrement index
.a8c3  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a8c5  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.a8c7  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.a8c9  60         rts              	RTS
.a8ca                              lab_27ab
.a8ca  20 d9 a8   jsr $a8d9        	JSR	LAB_27BA		; round FAC1
.a8cd                              lab_27ae
.a8cd  a2 05      ldx #$05         	LDX	#$05			; 5 bytes to copy
.a8cf                              lab_27b0
.a8cf  b5 ab      lda $ab,x        	LDA	FAC1_e-1,X		; get byte from FAC1,X
.a8d1  95 b2      sta $b2,x        	STA	FAC1_o,X		; save byte at FAC2,X
.a8d3  ca         dex              	DEX				; decrement count
.a8d4  d0 f9      bne $a8cf        	BNE	LAB_27B0		; loop if not all done
.a8d6  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.a8d8                              lab_27b9
.a8d8  60         rts              	RTS
.a8d9                              lab_27ba
.a8d9  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a8db  f0 fb      beq $a8d8        	BEQ	LAB_27B9		; exit if zero
.a8dd  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.a8df  90 f7      bcc $a8d8        	BCC	LAB_27B9		; exit if no overflow
.a8e1                              lab_27c2
.a8e1  20 b8 a6   jsr $a6b8        	JSR	LAB_2559		; increment FAC1 mantissa
.a8e4  d0 f2      bne $a8d8        	BNE	LAB_27B9		; branch if no overflow
.a8e6  4c 89 a6   jmp $a689        	JMP	LAB_252A		; normalise FAC1 for C=1 and return
.a8e9                              lab_27ca
.a8e9  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a8eb  f0 09      beq $a8f6        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
.a8ed                              lab_27ce
.a8ed  a5 b0      lda $b0          	LDA	FAC1_s		; else get FAC1 sign (b7)
.a8ef                              lab_27d0
.a8ef  2a         rol              	ROL				; move sign bit to carry
.a8f0  a9 ff      lda #$ff         	LDA	#$FF			; set byte for -ve result
.a8f2  b0 02      bcs $a8f6        	BCS	LAB_27D7		; return if sign was set (-ve)
.a8f4  a9 01      lda #$01         	LDA	#$01			; else set byte for +ve result
.a8f6                              lab_27d7
.a8f6  60         rts              	RTS
.a8f7                              lab_sgn
.a8f7  20 e9 a8   jsr $a8e9        	JSR	LAB_27CA		; get FAC1 sign
.a8fa                              lab_27db
.a8fa  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a8fc  a9 00      lda #$00         	LDA	#$00			; clear A
.a8fe  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.a900  a2 88      ldx #$88         	LDX	#$88			; set exponent
.a902                              lab_27e3
.a902  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.a904  49 ff      eor #$ff         	EOR	#$FF			; complement it
.a906  2a         rol              	ROL				; sign bit into carry
.a907                              lab_stfa
.a907  a9 00      lda #$00         	LDA	#$00			; clear A
.a909  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.a90b  86 ac      stx $ac          	STX	FAC1_e		; set FAC1 exponent
.a90d  85 b9      sta $b9          	STA	FAC1_r		; clear FAC1 rounding byte
.a90f  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.a911  4c 2f a6   jmp $a62f        	JMP	LAB_24D0		; do ABS and normalise FAC1
.a914                              lab_abs
.a914  46 b0      lsr $b0          	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
.a916  60         rts              	RTS
.a917                              lab_27f8
.a917  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.a919                              lab_27fa
.a919  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.a91b  a0 00      ldy #$00         	LDY	#$00			; clear index
.a91d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get exponent
.a91f  c8         iny              	INY				; increment index
.a920  aa         tax              	TAX				; copy (AY) exponent to X
.a921  f0 c6      beq $a8e9        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
.a923  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.a925  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.a927  30 c4      bmi $a8ed        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
.a929  e4 ac      cpx $ac          	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
.a92b  d0 1a      bne $a947        	BNE	LAB_2828		; branch if different
.a92d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.a92f  09 80      ora #$80         	ORA	#$80			; normalise top bit
.a931  c5 ad      cmp $ad          	CMP	FAC1_1		; compare with FAC1 mantissa1
.a933  d0 12      bne $a947        	BNE	LAB_2828		; branch if different
.a935  c8         iny              	INY				; increment index
.a936  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa2
.a938  c5 ae      cmp $ae          	CMP	FAC1_2		; compare with FAC1 mantissa2
.a93a  d0 0b      bne $a947        	BNE	LAB_2828		; branch if different
.a93c  c8         iny              	INY				; increment index
.a93d  a9 7f      lda #$7f         	LDA	#$7F			; set for 1/2 value rounding byte
.a93f  c5 b9      cmp $b9          	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
.a941  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa3
.a943  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.a945  f0 28      beq $a96f        	BEQ	LAB_2850		; exit if mantissa3 equal
.a947                              lab_2828
.a947  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a949  90 02      bcc $a94d        	BCC	LAB_282E		; branch if FAC1 > (AY)
.a94b  49 ff      eor #$ff         	EOR	#$FF			; else toggle FAC1 sign
.a94d                              lab_282e
.a94d  4c ef a8   jmp $a8ef        	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
.a950                              lab_2831
.a950  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a952  f0 4a      beq $a99e        	BEQ	LAB_287F		; if zero go clear FAC1 and return
.a954  38         sec              	SEC				; set carry for subtract
.a955  e9 98      sbc #$98         	SBC	#$98			; subtract maximum integer range exponent
.a957  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.a959  10 09      bpl $a964        	BPL	LAB_2845		; branch if FAC1 +ve
.a95b  aa         tax              	TAX				; copy subtracted exponent
.a95c  a9 ff      lda #$ff         	LDA	#$FF			; overflow for -ve number
.a95e  85 b2      sta $b2          	STA	FAC1_o		; set FAC1 overflow byte
.a960  20 9c a6   jsr $a69c        	JSR	LAB_253D		; twos complement FAC1 mantissa
.a963  8a         txa              	TXA				; restore subtracted exponent
.a964                              lab_2845
.a964  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1
.a966  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent result
.a968  10 06      bpl $a970        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
.a96a  20 da a6   jsr $a6da        	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
.a96d  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.a96f                              lab_2850
.a96f  60         rts              	RTS
.a970                              lab_2851
.a970  a8         tay              	TAY				; copy shift count
.a971  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a973  29 80      and #$80         	AND	#$80			; mask sign bit only (x000 0000)
.a975  46 ad      lsr $ad          	LSR	FAC1_1		; shift FAC1 mantissa1
.a977  05 ad      ora $ad          	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
.a979  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a97b  20 f1 a6   jsr $a6f1        	JSR	LAB_2592		; shift FAC1 Y times right
.a97e  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.a980  60         rts              	RTS
.a981                              lab_int
.a981  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a983  c9 98      cmp #$98         	CMP	#$98			; compare with max int
.a985  b0 1e      bcs $a9a5        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
.a987  20 50 a9   jsr $a950        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.a98a  84 b9      sty $b9          	STY	FAC1_r		; save FAC1 rounding byte
.a98c  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a98e  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.a990  49 80      eor #$80         	EOR	#$80			; toggle FAC1 sign
.a992  2a         rol              	ROL				; shift into carry
.a993  a9 98      lda #$98         	LDA	#$98			; set new exponent
.a995  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.a997  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.a999  85 5b      sta $5b          	STA	Temp3			; save for EXP() function
.a99b  4c 2f a6   jmp $a62f        	JMP	LAB_24D0		; do ABS and normalise FAC1
.a99e                              lab_287f
.a99e  85 ad      sta $ad          	STA	FAC1_1		; clear FAC1 mantissa1
.a9a0  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.a9a2  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.a9a4  a8         tay              	TAY				; clear Y
.a9a5                              lab_2886
.a9a5  60         rts              	RTS
.a9a6                              lab_2887
.a9a6  a0 00      ldy #$00         	LDY	#$00			; clear Y
.a9a8  84 5f      sty $5f          	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
.a9aa  a2 09      ldx #$09         	LDX	#$09			; set index
.a9ac                              lab_288b
.a9ac  94 a8      sty $a8,x        	STY	numexp,X		; clear byte
.a9ae  ca         dex              	DEX				; decrement index
.a9af  10 fb      bpl $a9ac        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
.a9b1  90 7f      bcc $aa32        	BCC	LAB_28FE		; branch if 1st character numeric
.a9b3  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.a9b5  d0 04      bne $a9bb        	BNE	LAB_289A		; branch if not "-"
.a9b7  86 b1      stx $b1          	STX	negnum		; set flag for -ve number (X = $FF)
.a9b9  f0 04      beq $a9bf        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
.a9bb                              lab_289a
.a9bb  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.a9bd  d0 05      bne $a9c4        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
.a9bf                              lab_289c
.a9bf  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.a9c2  90 6e      bcc $aa32        	BCC	LAB_28FE		; branch if numeric character
.a9c4                              lab_289d
.a9c4  c9 24      cmp #$24         	CMP	#"$"			; else compare with "$"
.a9c6  d0 03      bne $a9cb        	BNE	LAB_NHEX		; branch if not "$"
.a9c8  4c 6e ae   jmp $ae6e        	JMP	LAB_CHEX		; branch if "$"
.a9cb                              lab_nhex
.a9cb  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.a9cd  d0 08      bne $a9d7        	BNE	LAB_28A3		; branch if not "%" (continue original code)
.a9cf  4c 9c ae   jmp $ae9c        	JMP	LAB_CBIN		; branch if "%"
.a9d2                              lab_289e
.a9d2  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
.a9d5                              lab_28a1
.a9d5  90 5b      bcc $aa32        	BCC	LAB_28FE		; branch if numeric character
.a9d7                              lab_28a3
.a9d7  c9 2e      cmp #$2e         	CMP	#"."			; else compare with "."
.a9d9  f0 2e      beq $aa09        	BEQ	LAB_28D5		; branch if "."
.a9db  c9 45      cmp #$45         	CMP	#"E"			; else compare with "E"
.a9dd  d0 30      bne $aa0f        	BNE	LAB_28DB		; branch if not "E"
.a9df  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.a9e2  90 17      bcc $a9fb        	BCC	LAB_28C7		; branch if numeric character
.a9e4  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; else compare with token for -
.a9e6  f0 0e      beq $a9f6        	BEQ	LAB_28C2		; branch if token for -
.a9e8  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.a9ea  f0 0a      beq $a9f6        	BEQ	LAB_28C2		; branch if "-"
.a9ec  c9 b7      cmp #$b7         	CMP	#TK_PLUS		; else compare with token for +
.a9ee  f0 08      beq $a9f8        	BEQ	LAB_28C4		; branch if token for +
.a9f0  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.a9f2  f0 04      beq $a9f8        	BEQ	LAB_28C4		; branch if "+"
.a9f4  d0 07      bne $a9fd        	BNE	LAB_28C9		; branch always
.a9f6                              lab_28c2
.a9f6  66 ab      ror $ab          	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
.a9f8                              lab_28c4
.a9f8  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.a9fb                              lab_28c7
.a9fb  90 5b      bcc $aa58        	BCC	LAB_2925		; branch if numeric character
.a9fd                              lab_28c9
.a9fd  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.a9ff  10 0e      bpl $aa0f        	BPL	LAB_28DB		; if +ve go evaluate exponent
.aa01  a9 00      lda #$00         	LDA	#$00			; clear result
.aa03  38         sec              	SEC				; set carry for subtract
.aa04  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent byte
.aa06  4c 11 aa   jmp $aa11        	JMP	LAB_28DD		; go evaluate exponent
.aa09                              lab_28d5
.aa09  66 aa      ror $aa          	ROR	numdpf		; set decimal point flag
.aa0b  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.aa0d  50 c3      bvc $a9d2        	BVC	LAB_289E		; branch if only one decimal point so far
.aa0f                              lab_28db
.aa0f  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.aa11                              lab_28dd
.aa11  38         sec              	SEC				; set carry for subtract
.aa12  e5 a8      sbc $a8          	SBC	numexp		; subtract numerator exponent
.aa14  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.aa16  f0 12      beq $aa2a        	BEQ	LAB_28F6		; branch if no adjustment
.aa18  10 09      bpl $aa23        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
.aa1a                              lab_28e6
.aa1a  20 f0 a7   jsr $a7f0        	JSR	LAB_26B9		; divide by 10
.aa1d  e6 a9      inc $a9          	INC	expcnt		; increment exponent count byte
.aa1f  d0 f9      bne $aa1a        	BNE	LAB_28E6		; loop until all done
.aa21  f0 07      beq $aa2a        	BEQ	LAB_28F6		; branch always
.aa23                              lab_28ef
.aa23  20 d7 a7   jsr $a7d7        	JSR	LAB_269E		; multiply by 10
.aa26  c6 a9      dec $a9          	DEC	expcnt		; decrement exponent count byte
.aa28  d0 f9      bne $aa23        	BNE	LAB_28EF		; loop until all done
.aa2a                              lab_28f6
.aa2a  a5 b1      lda $b1          	LDA	negnum		; get -ve flag
.aa2c  30 01      bmi $aa2f        	BMI	LAB_28FB		; if -ve do - FAC1 and return
.aa2e  60         rts              	RTS
.aa2f                              lab_28fb
.aa2f  4c f4 ab   jmp $abf4        	JMP	LAB_GTHAN		; do - FAC1 and return
.aa32                              lab_28fe
.aa32  48         pha              	PHA				; save character
.aa33  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.aa35  10 02      bpl $aa39        	BPL	LAB_2905		; skip exponent increment if not set
.aa37  e6 a8      inc $a8          	INC	numexp		; else increment number exponent
.aa39                              lab_2905
.aa39  20 d7 a7   jsr $a7d7        	JSR	LAB_269E		; multiply FAC1 by 10
.aa3c  68         pla              	PLA				; restore character
.aa3d  29 0f      and #$0f         	AND	#$0F			; convert to binary
.aa3f  20 45 aa   jsr $aa45        	JSR	LAB_2912		; evaluate new ASCII digit
.aa42  4c d2 a9   jmp $a9d2        	JMP	LAB_289E		; go do next character
.aa45                              lab_2912
.aa45  48         pha              	PHA				; save digit
.aa46  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.aa49  68         pla              	PLA				; restore digit
.aa4a  20 fa a8   jsr $a8fa        	JSR	LAB_27DB		; save A as integer byte
.aa4d  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.aa4f  45 b0      eor $b0          	EOR	FAC1_s		; toggle with FAC1 sign (b7)
.aa51  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.aa53  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.aa55  4c c1 a5   jmp $a5c1        	JMP	LAB_ADD		; add FAC2 to FAC1 and return
.aa58                              lab_2925
.aa58  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.aa5a  c9 0a      cmp #$0a         	CMP	#$0A			; compare with 10 decimal
.aa5c  90 09      bcc $aa67        	BCC	LAB_2934		; branch if less
.aa5e  a9 64      lda #$64         	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.aa60  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.aa62  30 0e      bmi $aa72        	BMI	LAB_2942		; branch if -ve
.aa64  4c c3 a6   jmp $a6c3        	JMP	LAB_2564		; else do overflow error
.aa67                              lab_2934
.aa67  0a         asl              	ASL				; * 2
.aa68  0a         asl              	ASL				; * 4
.aa69  65 a9      adc $a9          	ADC	expcnt		; * 5
.aa6b  0a         asl              	ASL				; * 10
.aa6c  a0 00      ldy #$00         	LDY	#$00			; set index
.aa6e  71 c3      adc ($c3),y      	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
.aa70  e9 2f      sbc #$2f         	SBC	#"0"-1		; convert character to binary
.aa72                              lab_2942
.aa72  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.aa74  4c f8 a9   jmp $a9f8        	JMP	LAB_28C4		; go get next character
.aa77                              lab_2953
.aa77  a9 f6      lda #$f6         	LDA	#<LAB_LMSG		; point to " in line " message low byte
.aa79  a0 b7      ldy #$b7         	LDY	#>LAB_LMSG		; point to " in line " message high byte
.aa7b  20 d3 98   jsr $98d3        	JSR	LAB_18C3		; print null terminated string from memory
.aa7e  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.aa80  a6 87      ldx $87          	LDX	Clinel		; get current line low byte
.aa82                              lab_295e
.aa82  85 ad      sta $ad          	STA	FAC1_1		; save low byte as FAC1 mantissa1
.aa84  86 ae      stx $ae          	STX	FAC1_2		; save high byte as FAC1 mantissa2
.aa86  a2 90      ldx #$90         	LDX	#$90			; set exponent to 16d bits
.aa88  38         sec              	SEC				; set integer is +ve flag
.aa89  20 07 a9   jsr $a907        	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
.aa8c  a0 00      ldy #$00         	LDY	#$00			; clear index
.aa8e  98         tya              	TYA				; clear A
.aa8f  20 a2 aa   jsr $aaa2        	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
.aa92  4c d3 98   jmp $98d3        	JMP	LAB_18C3		; print null terminated string from memory and return
.aa95                              lab_296e
.aa95  a0 01      ldy #$01         	LDY	#$01			; set index = 1
.aa97  a9 20      lda #$20         	LDA	#$20			; character = " " (assume +ve)
.aa99  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.aa9b  10 02      bpl $aa9f        	BPL	LAB_2978		; branch if +ve
.aa9d  a9 2d      lda #$2d         	LDA	#$2D			; else character = "-"
.aa9f                              lab_2978
.aa9f  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save leading character (" " or "-")
.aaa2                              lab_297b
.aaa2  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.aaa4  84 ba      sty $ba          	STY	Sendl			; save index
.aaa6  c8         iny              	INY				; increment index
.aaa7  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.aaa9  d0 05      bne $aab0        	BNE	LAB_2989		; branch if FAC1<>0
.aaab  a9 30      lda #$30         	LDA	#"0"			; set character = "0"
.aaad  4c ae ab   jmp $abae        	JMP	LAB_2A89		; save last character, [EOT] and exit
.aab0                              lab_2989
.aab0  a9 00      lda #$00         	LDA	#$00			; clear (number exponent count)
.aab2  e0 81      cpx #$81         	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
.aab4  b0 09      bcs $aabf        	BCS	LAB_299A		; branch if FAC1=>1
.aab6  a9 81      lda #$81         	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
.aab8  a0 b1      ldy #$b1         	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
.aaba  20 39 a7   jsr $a739        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.aabd  a9 fa      lda #$fa         	LDA	#$FA			; set number exponent count (-6)
.aabf                              lab_299a
.aabf  85 a8      sta $a8          	STA	numexp		; save number exponent count
.aac1                              lab_299c
.aac1  a9 7d      lda #$7d         	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
.aac3  a0 b1      ldy #$b1         	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
.aac5  20 17 a9   jsr $a917        	JSR	LAB_27F8		; compare FAC1 with (AY)
.aac8  f0 1e      beq $aae8        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
.aaca  10 12      bpl $aade        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
.aacc                              lab_29a7
.aacc  a9 79      lda #$79         	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
.aace  a0 b1      ldy #$b1         	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
.aad0  20 17 a9   jsr $a917        	JSR	LAB_27F8		; compare FAC1 with (AY)
.aad3  f0 02      beq $aad7        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
.aad5  10 0e      bpl $aae5        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
.aad7                              lab_29b2
.aad7  20 d7 a7   jsr $a7d7        	JSR	LAB_269E		; multiply by 10
.aada  c6 a8      dec $a8          	DEC	numexp		; decrement number exponent count
.aadc  d0 ee      bne $aacc        	BNE	LAB_29A7		; go test again (branch always)
.aade                              lab_29b9
.aade  20 f0 a7   jsr $a7f0        	JSR	LAB_26B9		; divide by 10
.aae1  e6 a8      inc $a8          	INC	numexp		; increment number exponent count
.aae3  d0 dc      bne $aac1        	BNE	LAB_299C		; go test again (branch always)
.aae5                              lab_29c0
.aae5  20 ba a5   jsr $a5ba        	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
.aae8                              lab_29c3
.aae8  20 50 a9   jsr $a950        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.aaeb  a2 01      ldx #$01         	LDX	#$01			; set default digits before dp = 1
.aaed  a5 a8      lda $a8          	LDA	numexp		; get number exponent count
.aaef  18         clc              	CLC				; clear carry for add
.aaf0  69 07      adc #$07         	ADC	#$07			; up to 6 digits before point
.aaf2  30 09      bmi $aafd        	BMI	LAB_29D8		; if -ve then 1 digit before dp
.aaf4  c9 08      cmp #$08         	CMP	#$08			; A>=8 if n>=1E6
.aaf6  b0 06      bcs $aafe        	BCS	LAB_29D9		; branch if >= $08
.aaf8  69 ff      adc #$ff         	ADC	#$FF			; take 1 from digit count
.aafa  aa         tax              	TAX				; copy to A
.aafb  a9 02      lda #$02         	LDA	#$02			;.set exponent adjust
.aafd                              lab_29d8
.aafd  38         sec              	SEC				; set carry for subtract
.aafe                              lab_29d9
.aafe  e9 02      sbc #$02         	SBC	#$02			; -2
.ab00  85 a9      sta $a9          	STA	expcnt		;.save exponent adjust
.ab02  86 a8      stx $a8          	STX	numexp		; save digits before dp count
.ab04  8a         txa              	TXA				; copy to A
.ab05  f0 02      beq $ab09        	BEQ	LAB_29E4		; branch if no digits before dp
.ab07  10 13      bpl $ab1c        	BPL	LAB_29F7		; branch if digits before dp
.ab09                              lab_29e4
.ab09  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.ab0b  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.ab0d  c8         iny              	INY				; increment index
.ab0e  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.ab11  8a         txa              	TXA				;.
.ab12  f0 06      beq $ab1a        	BEQ	LAB_29F5		;.
.ab14  a9 30      lda #$30         	LDA	#"0"			; character "0"
.ab16  c8         iny              	INY				; increment index
.ab17  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.ab1a                              lab_29f5
.ab1a  84 ba      sty $ba          	STY	Sendl			; save output string index
.ab1c                              lab_29f7
.ab1c  a0 00      ldy #$00         	LDY	#$00			; clear index (point to 100,000)
.ab1e  a2 80      ldx #$80         	LDX	#$80			; 
.ab20                              lab_29fb
.ab20  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.ab22  18         clc              	CLC				; clear carry for add
.ab23  79 f7 b1   adc $b1f7,y      	ADC	LAB_2A9C,Y		; add -ve LSB
.ab26  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.ab28  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.ab2a  79 f6 b1   adc $b1f6,y      	ADC	LAB_2A9B,Y		; add -ve NMSB
.ab2d  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.ab2f  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.ab31  79 f5 b1   adc $b1f5,y      	ADC	LAB_2A9A,Y		; add -ve MSB
.ab34  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.ab36  e8         inx              	INX				; 
.ab37  b0 04      bcs $ab3d        	BCS	LAB_2A18		; 
.ab39  10 e5      bpl $ab20        	BPL	LAB_29FB		; not -ve so try again
.ab3b  30 02      bmi $ab3f        	BMI	LAB_2A1A		; 
.ab3d                              lab_2a18
.ab3d  30 e1      bmi $ab20        	BMI	LAB_29FB		; 
.ab3f                              lab_2a1a
.ab3f  8a         txa              	TXA				; 
.ab40  90 04      bcc $ab46        	BCC	LAB_2A21		; 
.ab42  49 ff      eor #$ff         	EOR	#$FF			; 
.ab44  69 0a      adc #$0a         	ADC	#$0A			; 
.ab46                              lab_2a21
.ab46  69 2f      adc #$2f         	ADC	#"0"-1		; add "0"-1 to result
.ab48  c8         iny              	INY				; increment index ..
.ab49  c8         iny              	INY				; .. to next less ..
.ab4a  c8         iny              	INY				; .. power of ten
.ab4b  84 95      sty $95          	STY	Cvaral		; save as current var address low byte
.ab4d  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.ab4f  c8         iny              	INY				; increment output string index
.ab50  aa         tax              	TAX				; copy character to X
.ab51  29 7f      and #$7f         	AND	#$7F			; mask out top bit
.ab53  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.ab56  c6 a8      dec $a8          	DEC	numexp		; decrement # of characters before the dp
.ab58  d0 06      bne $ab60        	BNE	LAB_2A3B		; branch if still characters to do
.ab5a  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.ab5c  c8         iny              	INY				; increment output string index
.ab5d  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.ab60                              lab_2a3b
.ab60  84 ba      sty $ba          	STY	Sendl			; save output string index
.ab62  a4 95      ldy $95          	LDY	Cvaral		; get current var address low byte
.ab64  8a         txa              	TXA				; get character back
.ab65  49 ff      eor #$ff         	EOR	#$FF			; 
.ab67  29 80      and #$80         	AND	#$80			; 
.ab69  aa         tax              	TAX				; 
.ab6a  c0 12      cpy #$12         	CPY	#$12			; compare index with max
.ab6c  d0 b2      bne $ab20        	BNE	LAB_29FB		; loop if not max
.ab6e  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.ab70                              lab_2a4b
.ab70  b9 ef 00   lda $00ef,y      	LDA	Decss,Y		; get character from output string
.ab73  88         dey              	DEY				; decrement output string index
.ab74  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.ab76  f0 f8      beq $ab70        	BEQ	LAB_2A4B		; loop until non "0" character found
.ab78  c9 2e      cmp #$2e         	CMP	#"."			; compare with "."
.ab7a  f0 01      beq $ab7d        	BEQ	LAB_2A58		; branch if was dp
.ab7c  c8         iny              	INY				; increment output string index
.ab7d                              lab_2a58
.ab7d  a9 2b      lda #$2b         	LDA	#$2B			; character "+"
.ab7f  a6 a9      ldx $a9          	LDX	expcnt		; get exponent count
.ab81  f0 2e      beq $abb1        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
.ab83  10 08      bpl $ab8d        	BPL	LAB_2A68		; branch if exponent count +ve
.ab85  a9 00      lda #$00         	LDA	#$00			; clear A
.ab87  38         sec              	SEC				; set carry for subtract
.ab88  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
.ab8a  aa         tax              	TAX				; copy exponent count to X
.ab8b  a9 2d      lda #$2d         	LDA	#"-"			; character "-"
.ab8d                              lab_2a68
.ab8d  99 f1 00   sta $00f1,y      	STA	Decss+2,Y		; save to output string
.ab90  a9 45      lda #$45         	LDA	#$45			; character "E"
.ab92  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save exponent sign to output string
.ab95  8a         txa              	TXA				; get exponent count back
.ab96  a2 2f      ldx #$2f         	LDX	#"0"-1		; one less than "0" character
.ab98  38         sec              	SEC				; set carry for subtract
.ab99                              lab_2a74
.ab99  e8         inx              	INX				; increment 10's character
.ab9a  e9 0a      sbc #$0a         	SBC	#$0A			;.subtract 10 from exponent count
.ab9c  b0 fb      bcs $ab99        	BCS	LAB_2A74		; loop while still >= 0
.ab9e  69 3a      adc #$3a         	ADC	#":"			; add character ":" ($30+$0A, result is 10 less that value)
.aba0  99 f3 00   sta $00f3,y      	STA	Decss+4,Y		; save to output string
.aba3  8a         txa              	TXA				; copy 10's character
.aba4  99 f2 00   sta $00f2,y      	STA	Decss+3,Y		; save to output string
.aba7  a9 00      lda #$00         	LDA	#$00			; set null terminator
.aba9  99 f4 00   sta $00f4,y      	STA	Decss+5,Y		; save to output string
.abac  f0 08      beq $abb6        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
.abae                              lab_2a89
.abae  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save last character to output string
.abb1                              lab_2a8c
.abb1  a9 00      lda #$00         	LDA	#$00			; set null terminator
.abb3  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save after last character
.abb6                              lab_2a91
.abb6  a9 f0      lda #$f0         	LDA	#<Decssp1		; set result string low pointer
.abb8  a0 00      ldy #$00         	LDY	#>Decssp1		; set result string high pointer
.abba  60         rts              	RTS
.abbb                              lab_power
.abbb  f0 42      beq $abff        	BEQ	LAB_EXP		; go do  EXP()
.abbd  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.abbf  d0 03      bne $abc4        	BNE	LAB_2ABF		; branch if FAC2<>0
.abc1  4c 52 a6   jmp $a652        	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
.abc4                              lab_2abf
.abc4  a2 9c      ldx #$9c         	LDX	#<func_l		; set destination pointer low byte
.abc6  a0 00      ldy #$00         	LDY	#>func_l		; set destination pointer high byte
.abc8  20 a7 a8   jsr $a8a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.abcb  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.abcd  10 0f      bpl $abde        	BPL	LAB_2AD9		; branch if FAC2>0
.abcf  20 81 a9   jsr $a981        	JSR	LAB_INT		; perform INT
.abd2  a9 9c      lda #$9c         	LDA	#<func_l		; set source pointer low byte
.abd4  a0 00      ldy #$00         	LDY	#>func_l		; set source pointer high byte
.abd6  20 17 a9   jsr $a917        	JSR	LAB_27F8		; compare FAC1 with (AY)
.abd9  d0 03      bne $abde        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
.abdb  98         tya              	TYA				; clear sign b7
.abdc  a4 5b      ldy $5b          	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
.abde                              lab_2ad9
.abde  20 c5 a5   jsr $a5c5        	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
.abe1  98         tya              	TYA				; copy sign back ..
.abe2  48         pha              	PHA				; .. and save it
.abe3  20 fb a6   jsr $a6fb        	JSR	LAB_LOG		; do LOG(n)
.abe6  a9 9c      lda #$9c         	LDA	#<garb_l		; set pointer low byte
.abe8  a0 00      ldy #$00         	LDY	#>garb_l		; set pointer high byte
.abea  20 39 a7   jsr $a739        	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
.abed  20 ff ab   jsr $abff        	JSR	LAB_EXP		; go do EXP(n)
.abf0  68         pla              	PLA				; pull sign from stack
.abf1  4a         lsr              	LSR				; b0 is to be tested, shift to Cb
.abf2  90 0a      bcc $abfe        	BCC	LAB_2AF9		; if no bit then exit
.abf4                              lab_gthan
.abf4  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.abf6  f0 06      beq $abfe        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
.abf8  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.abfa  49 ff      eor #$ff         	EOR	#$FF			; complement it
.abfc  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.abfe                              lab_2af9
.abfe  60         rts              	RTS
.abff                              lab_exp
.abff  a9 85      lda #$85         	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
.ac01  a0 b1      ldy #$b1         	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
.ac03  20 39 a7   jsr $a739        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.ac06  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.ac08  69 50      adc #$50         	ADC	#$50			; +$50/$100
.ac0a  90 03      bcc $ac0f        	BCC	LAB_2B2B		; skip rounding if no carry
.ac0c  20 e1 a8   jsr $a8e1        	JSR	LAB_27C2		; round FAC1 (no check)
.ac0f                              lab_2b2b
.ac0f  85 a3      sta $a3          	STA	FAC2_r		; save FAC2 rounding byte
.ac11  20 cd a8   jsr $a8cd        	JSR	LAB_27AE		; copy FAC1 to FAC2
.ac14  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ac16  c9 88      cmp #$88         	CMP	#$88			; compare with EXP limit (256d)
.ac18  90 03      bcc $ac1d        	BCC	LAB_2B39		; branch if less
.ac1a                              lab_2b36
.ac1a  20 ce a7   jsr $a7ce        	JSR	LAB_2690		; handle overflow and underflow
.ac1d                              lab_2b39
.ac1d  20 81 a9   jsr $a981        	JSR	LAB_INT		; perform INT
.ac20  a5 5b      lda $5b          	LDA	Temp3			; get mantissa 3 from INT() function
.ac22  18         clc              	CLC				; clear carry for add
.ac23  69 81      adc #$81         	ADC	#$81			; normalise +1
.ac25  f0 f3      beq $ac1a        	BEQ	LAB_2B36		; if $00 go handle overflow
.ac27  38         sec              	SEC				; set carry for subtract
.ac28  e9 01      sbc #$01         	SBC	#$01			; now correct for exponent
.ac2a  48         pha              	PHA				; save FAC2 exponent
.ac2b  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to do
.ac2d                              lab_2b49
.ac2d  b5 b3      lda $b3,x        	LDA	FAC2_e,X		; get FAC2,X
.ac2f  b4 ac      ldy $ac,x        	LDY	FAC1_e,X		; get FAC1,X
.ac31  95 ac      sta $ac,x        	STA	FAC1_e,X		; save FAC1,X
.ac33  94 b3      sty $b3,x        	STY	FAC2_e,X		; save FAC2,X
.ac35  ca         dex              	DEX				; decrement count/index
.ac36  10 f5      bpl $ac2d        	BPL	LAB_2B49		; loop if not all done
.ac38  a5 a3      lda $a3          	LDA	FAC2_r		; get FAC2 rounding byte
.ac3a  85 b9      sta $b9          	STA	FAC1_r		; save as FAC1 rounding byte
.ac3c  20 a6 a5   jsr $a5a6        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.ac3f  20 f4 ab   jsr $abf4        	JSR	LAB_GTHAN		; do - FAC1
.ac42  a9 89      lda #$89         	LDA	#<LAB_2AFE		; set counter pointer low byte
.ac44  a0 b1      ldy #$b1         	LDY	#>LAB_2AFE		; set counter pointer high byte
.ac46  20 67 ac   jsr $ac67        	JSR	LAB_2B84		; go do series evaluation
.ac49  a9 00      lda #$00         	LDA	#$00			; clear A
.ac4b  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.ac4d  68         pla              	PLA				;.get saved FAC2 exponent
.ac4e  4c b3 a7   jmp $a7b3        	JMP	LAB_2675		; test and adjust accumulators and return
.ac51                              lab_2b6e
.ac51  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.ac53  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.ac55  20 9d a8   jsr $a89d        	JSR	LAB_276E		; pack FAC1 into Adatal
.ac58  a9 a4      lda #$a4         	LDA	#<Adatal		; set pointer low byte (Y already $00)
.ac5a  20 39 a7   jsr $a739        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.ac5d  20 6b ac   jsr $ac6b        	JSR	LAB_2B88		; go do series evaluation
.ac60  a9 a4      lda #$a4         	LDA	#<Adatal		; pointer to original # low byte
.ac62  a0 00      ldy #$00         	LDY	#>Adatal		; pointer to original # high byte
.ac64  4c 39 a7   jmp $a739        	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
.ac67                              lab_2b84
.ac67  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.ac69  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.ac6b                              lab_2b88
.ac6b  a2 a8      ldx #$a8         	LDX	#<numexp		; set pointer low byte
.ac6d  20 9f a8   jsr $a89f        	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
.ac70  b1 ba      lda ($ba),y      	LDA	(Cptrl),Y		; get constants count
.ac72  85 b1      sta $b1          	STA	numcon		; save constants count
.ac74  a4 ba      ldy $ba          	LDY	Cptrl			; get count pointer low byte
.ac76  c8         iny              	INY				; increment it (now constants pointer)
.ac77  98         tya              	TYA				; copy it
.ac78  d0 02      bne $ac7c        	BNE	LAB_2B97		; skip next if no overflow
.ac7a  e6 bb      inc $bb          	INC	Cptrh			; else increment high byte
.ac7c                              lab_2b97
.ac7c  85 ba      sta $ba          	STA	Cptrl			; save low byte
.ac7e  a4 bb      ldy $bb          	LDY	Cptrh			; get high byte
.ac80                              lab_2b9b
.ac80  20 39 a7   jsr $a739        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.ac83  a5 ba      lda $ba          	LDA	Cptrl			; get constants pointer low byte
.ac85  a4 bb      ldy $bb          	LDY	Cptrh			; get constants pointer high byte
.ac87  18         clc              	CLC				; clear carry for add
.ac88  69 04      adc #$04         	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
.ac8a  90 01      bcc $ac8d        	BCC	LAB_2BA8		; skip next if no overflow
.ac8c  c8         iny              	INY				; increment high byte
.ac8d                              lab_2ba8
.ac8d  85 ba      sta $ba          	STA	Cptrl			; save pointer low byte
.ac8f  84 bb      sty $bb          	STY	Cptrh			; save pointer high byte
.ac91  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1
.ac94  a9 a8      lda #$a8         	LDA	#<numexp		; set pointer low byte to partial @ numexp
.ac96  a0 00      ldy #$00         	LDY	#>numexp		; set pointer high byte to partial @ numexp
.ac98  c6 b1      dec $b1          	DEC	numcon		; decrement constants count
.ac9a  d0 e4      bne $ac80        	BNE	LAB_2B9B		; loop until all done
.ac9c  60         rts              	RTS
.ac9d                              lab_rnd
.ac9d  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ac9f  f0 07      beq $aca8        	BEQ	NextPRN		; do next random # if zero
.aca1  a2 d8      ldx #$d8         	LDX	#Rbyte4		; set PRNG pointer low byte
.aca3  a0 00      ldy #$00         	LDY	#$00			; set PRNG pointer high byte
.aca5  20 a7 a8   jsr $a8a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.aca8                              nextprn
.aca8  a2 af      ldx #$af         	LDX	#$AF			; set EOR byte
.acaa  a0 13      ldy #$13         	LDY	#$13			; do this nineteen times
.acac                              loopprn
.acac  06 d9      asl $d9          	ASL	Rbyte1		; shift PRNG most significant byte
.acae  26 da      rol $da          	ROL	Rbyte2		; shift PRNG middle byte
.acb0  26 db      rol $db          	ROL	Rbyte3		; shift PRNG least significant byte
.acb2  26 d8      rol $d8          	ROL	Rbyte4		; shift PRNG extra byte
.acb4  90 05      bcc $acbb        	BCC	Ninc1			; branch if bit 32 clear
.acb6  8a         txa              	TXA				; set EOR byte
.acb7  45 d9      eor $d9          	EOR	Rbyte1		; EOR PRNG extra byte
.acb9  85 d9      sta $d9          	STA	Rbyte1		; save new PRNG extra byte
.acbb                              ninc1
.acbb  88         dey              	DEY				; decrement loop count
.acbc  d0 ee      bne $acac        	BNE	LoopPRN		; loop if not all done
.acbe  a2 02      ldx #$02         	LDX	#$02			; three bytes to copy
.acc0                              copyprng
.acc0  b5 d9      lda $d9,x        	LDA	Rbyte1,X		; get PRNG byte
.acc2  95 ad      sta $ad,x        	STA	FAC1_1,X		; save FAC1 byte
.acc4  ca         dex              	DEX
.acc5  10 f9      bpl $acc0        	BPL	CopyPRNG		; loop if not complete
.acc7  a9 80      lda #$80         	LDA	#$80			; set the exponent
.acc9  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.accb  0a         asl              	ASL				; clear A
.accc  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign
.acce  4c 34 a6   jmp $a634        	JMP	LAB_24D5		; normalise FAC1 and return
.acd1                              lab_cos
.acd1  a9 a6      lda #$a6         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.acd3  a0 b1      ldy #$b1         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.acd5  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1
.acd8                              lab_sin
.acd8  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.acdb  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.acdd  a0 b1      ldy #$b1         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.acdf  a6 b7      ldx $b7          	LDX	FAC2_s		; get FAC2 sign (b7)
.ace1  20 f9 a7   jsr $a7f9        	JSR	LAB_26C2		; divide by (AY) (X=sign)
.ace4  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.ace7  20 81 a9   jsr $a981        	JSR	LAB_INT		; perform INT
.acea  a9 00      lda #$00         	LDA	#$00			; clear byte
.acec  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.acee  20 a6 a5   jsr $a5a6        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.acf1  a9 ed      lda #$ed         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.acf3  a0 b1      ldy #$b1         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.acf5  20 a3 a5   jsr $a5a3        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.acf8  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.acfa  48         pha              	PHA				; save FAC1 sign
.acfb  10 0d      bpl $ad0a        	BPL	LAB_2C35		; branch if +ve
.acfd  20 ba a5   jsr $a5ba        	JSR	LAB_244E		; add 0.5 to FAC1
.ad00  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.ad02  30 09      bmi $ad0d        	BMI	LAB_2C38		; branch if -ve
.ad04  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.ad06  49 ff      eor #$ff         	EOR	#$FF			; toggle flag
.ad08  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.ad0a                              lab_2c35
.ad0a  20 f4 ab   jsr $abf4        	JSR	LAB_GTHAN		; do - FAC1
.ad0d                              lab_2c38
.ad0d  a9 ed      lda #$ed         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.ad0f  a0 b1      ldy #$b1         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.ad11  20 be a5   jsr $a5be        	JSR	LAB_246C		; add (AY) to FAC1
.ad14  68         pla              	PLA				; restore FAC1 sign
.ad15  10 03      bpl $ad1a        	BPL	LAB_2C45		; branch if was +ve
.ad17  20 f4 ab   jsr $abf4        	JSR	LAB_GTHAN		; do - FAC1
.ad1a                              lab_2c45
.ad1a  a9 aa      lda #$aa         	LDA	#<LAB_2C84		; set pointer low byte to counter
.ad1c  a0 b1      ldy #$b1         	LDY	#>LAB_2C84		; set pointer high byte to counter
.ad1e  4c 51 ac   jmp $ac51        	JMP	LAB_2B6E		; ^2 then series evaluation and return
.ad21                              lab_tan
.ad21  20 9d a8   jsr $a89d        	JSR	LAB_276E		; pack FAC1 into Adatal
.ad24  a9 00      lda #$00         	LDA	#$00			; clear byte
.ad26  85 63      sta $63          	STA	Cflag			; clear comparison evaluation flag
.ad28  20 d8 ac   jsr $acd8        	JSR	LAB_SIN		; go do SIN(n)
.ad2b  a2 9c      ldx #$9c         	LDX	#<func_l		; set sin(n) pointer low byte
.ad2d  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.ad2f  20 a7 a8   jsr $a8a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.ad32  a9 a4      lda #$a4         	LDA	#<Adatal		; set n pointer low addr
.ad34  a0 00      ldy #$00         	LDY	#>Adatal		; set n pointer high addr
.ad36  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.ad39  a9 00      lda #$00         	LDA	#$00			; clear byte
.ad3b  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.ad3d  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.ad3f  20 49 ad   jsr $ad49        	JSR	LAB_2C74		; save flag and go do series evaluation
.ad42  a9 9c      lda #$9c         	LDA	#<func_l		; set sin(n) pointer low byte
.ad44  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.ad46  4c 01 a8   jmp $a801        	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
.ad49                              lab_2c74
.ad49  48         pha              	PHA				; save comparison evaluation flag
.ad4a  4c 0a ad   jmp $ad0a        	JMP	LAB_2C35		; go do series evaluation
.ad4d                              lab_usr
.ad4d  20 0a 00   jsr $000a        	JSR	Usrjmp		; call user code
.ad50  4c ef 9b   jmp $9bef        	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
.ad53                              lab_atn
.ad53  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.ad55  48         pha              	PHA				; save sign
.ad56  10 03      bpl $ad5b        	BPL	LAB_2CA1		; branch if +ve
.ad58  20 f4 ab   jsr $abf4        	JSR	LAB_GTHAN		; else do - FAC1
.ad5b                              lab_2ca1
.ad5b  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ad5d  48         pha              	PHA				; push exponent
.ad5e  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.ad60  90 07      bcc $ad69        	BCC	LAB_2CAF		; branch if FAC1<1
.ad62  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.ad64  a0 b1      ldy #$b1         	LDY	#>LAB_259C		; set 1 pointer high byte
.ad66  20 01 a8   jsr $a801        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
.ad69                              lab_2caf
.ad69  a9 bf      lda #$bf         	LDA	#<LAB_2CC9		; set pointer low byte to counter
.ad6b  a0 b1      ldy #$b1         	LDY	#>LAB_2CC9		; set pointer high byte to counter
.ad6d  20 51 ac   jsr $ac51        	JSR	LAB_2B6E		; ^2 then series evaluation
.ad70  68         pla              	PLA				; restore old FAC1 exponent
.ad71  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.ad73  90 07      bcc $ad7c        	BCC	LAB_2CC2		; branch if FAC1<1
.ad75  a9 a6      lda #$a6         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.ad77  a0 b1      ldy #$b1         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.ad79  20 a3 a5   jsr $a5a3        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.ad7c                              lab_2cc2
.ad7c  68         pla              	PLA				; restore FAC1 sign
.ad7d  10 16      bpl $ad95        	BPL	LAB_2D04		; exit if was +ve
.ad7f  4c f4 ab   jmp $abf4        	JMP	LAB_GTHAN		; else do - FAC1 and return
.ad82                              lab_bitset
.ad82  20 d8 a4   jsr $a4d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.ad85  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.ad87  b0 20      bcs $ada9        	BCS	FCError		; branch if > 7
.ad89  a9 00      lda #$00         	LDA	#$00			; clear A
.ad8b  38         sec              	SEC				; set the carry
.ad8c                              s_bits
.ad8c  2a         rol              	ROL				; shift bit
.ad8d  ca         dex              	DEX				; decrement bit number
.ad8e  10 fc      bpl $ad8c        	BPL	S_Bits		; loop if still +ve
.ad90  e8         inx              	INX				; make X = $00
.ad91  01 11      ora ($11,x)      	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
.ad93  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.ad95                              lab_2d04
.ad95  60         rts              	RTS
.ad96                              lab_bitclr
.ad96  20 d8 a4   jsr $a4d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.ad99  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.ad9b  b0 0c      bcs $ada9        	BCS	FCError		; branch if > 7
.ad9d  a9 ff      lda #$ff         	LDA	#$FF			; set A
.ad9f                              s_bitc
.ad9f  2a         rol              	ROL				; shift bit
.ada0  ca         dex              	DEX				; decrement bit number
.ada1  10 fc      bpl $ad9f        	BPL	S_Bitc		; loop if still +ve
.ada3  e8         inx              	INX				; make X = $00
.ada4  21 11      and ($11,x)      	AND	(Itempl,X)		; and with byte via temporary integer (addr)
.ada6  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.ada8  60         rts              	RTS
.ada9                              fcerror
.ada9  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start
.adac                              lab_btst
.adac  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment BASIC pointer
.adaf  20 d8 a4   jsr $a4d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.adb2  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.adb4  b0 f3      bcs $ada9        	BCS	FCError		; branch if > 7
.adb6  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.adb9  c9 29      cmp #$29         	CMP	#")"			; is next character ")"
.adbb  f0 03      beq $adc0        	BEQ	TST_OK		; if ")" go do rest of function
.adbd  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.adc0                              tst_ok
.adc0  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.adc3  a9 00      lda #$00         	LDA	#$00			; clear A
.adc5  38         sec              	SEC				; set the carry
.adc6                              t_bits
.adc6  2a         rol              	ROL				; shift bit
.adc7  ca         dex              	DEX				; decrement bit number
.adc8  10 fc      bpl $adc6        	BPL	T_Bits		; loop if still +ve
.adca  e8         inx              	INX				; make X = $00
.adcb  21 11      and ($11,x)      	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
.adcd  f0 02      beq $add1        	BEQ	LAB_NOTT		; branch if zero (already correct)
.adcf  a9 ff      lda #$ff         	LDA	#$FF			; set for -1 result
.add1                              lab_nott
.add1  4c fa a8   jmp $a8fa        	JMP	LAB_27DB		; go do SGN tail
.add4                              lab_bins
.add4  e0 19      cpx #$19         	CPX	#$19			; max + 1
.add6  b0 48      bcs $ae20        	BCS	BinFErr		; exit if too big ( > or = )
.add8  86 78      stx $78          	STX	TempB			; save # of characters ($00 = leading zero remove)
.adda  a9 18      lda #$18         	LDA	#$18			; need A byte long space
.addc  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long
.addf  a0 17      ldy #$17         	LDY	#$17			; set index
.ade1  a2 18      ldx #$18         	LDX	#$18			; character count
.ade3                              nextb1
.ade3  46 11      lsr $11          	LSR	nums_1		; shift highest byte
.ade5  66 12      ror $12          	ROR	nums_2		; shift middle byte
.ade7  66 13      ror $13          	ROR	nums_3		; shift lowest byte bit 0 to carry
.ade9  8a         txa              	TXA				; load with "0"/2
.adea  2a         rol              	ROL				; shift in carry
.adeb  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string + index
.aded  88         dey              	DEY				; decrement index
.adee  10 f3      bpl $ade3        	BPL	NextB1		; loop if not done
.adf0  a5 78      lda $78          	LDA	TempB			; get # of characters
.adf2  f0 0a      beq $adfe        	BEQ	EndBHS		; branch if truncate
.adf4  aa         tax              	TAX				; copy length to X
.adf5  38         sec              	SEC				; set carry for add !
.adf6  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.adf8  69 18      adc #$18         	ADC	#$18			; add 24d
.adfa  f0 1c      beq $ae18        	BEQ	GoPr2			; if zero print whole string
.adfc  d0 0f      bne $ae0d        	BNE	GoPr1			; else go make output string
.adfe                              endbhs
.adfe  a8         tay              	TAY				; clear index (A=0, X=length here)
.adff                              nextb2
.adff  b1 ad      lda ($ad),y      	LDA	(str_pl),Y		; get character from string
.ae01  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.ae03  d0 07      bne $ae0c        	BNE	GoPr			; if not "0" then go print string from here
.ae05  ca         dex              	DEX				; decrement character count
.ae06  f0 03      beq $ae0b        	BEQ	GoPr3			; if zero then end of string so go print it
.ae08  c8         iny              	INY				; else increment index
.ae09  10 f4      bpl $adff        	BPL	NextB2		; loop always
.ae0b                              gopr3
.ae0b  e8         inx              	INX				; need at least 1 character
.ae0c                              gopr
.ae0c  98         tya              	TYA				; copy result
.ae0d                              gopr1
.ae0d  18         clc              	CLC				; clear carry for add
.ae0e  65 ad      adc $ad          	ADC	str_pl		; add low address
.ae10  85 ad      sta $ad          	STA	str_pl		; save low address
.ae12  a9 00      lda #$00         	LDA	#$00			; do high byte
.ae14  65 ae      adc $ae          	ADC	str_ph		; add high address
.ae16  85 ae      sta $ae          	STA	str_ph		; save high address
.ae18                              gopr2
.ae18  86 ac      stx $ac          	STX	str_ln		; X holds string length
.ae1a  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.ae1d  4c 85 a1   jmp $a185        	JMP	LAB_RTST		; check for space on descriptor stack then put address
.ae20                              binferr
.ae20  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start
.ae23                              lab_hexs
.ae23  e0 07      cpx #$07         	CPX	#$07			; max + 1
.ae25  b0 f9      bcs $ae20        	BCS	BinFErr		; exit if too big ( > or = )
.ae27  86 78      stx $78          	STX	TempB			; save # of characters
.ae29  a9 06      lda #$06         	LDA	#$06			; need 6 bytes for string
.ae2b  20 3a a1   jsr $a13a        	JSR	LAB_MSSP		; make string space A bytes long
.ae2e  a0 05      ldy #$05         	LDY	#$05			; set string index
.ae30  f8         sed              	SED				; need decimal mode for nibble convert
.ae31  a5 13      lda $13          	LDA	nums_3		; get lowest byte
.ae33  20 51 ae   jsr $ae51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ae36  a5 12      lda $12          	LDA	nums_2		; get middle byte
.ae38  20 51 ae   jsr $ae51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ae3b  a5 11      lda $11          	LDA	nums_1		; get highest byte
.ae3d  20 51 ae   jsr $ae51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ae40  d8         cld              	CLD				; back to binary
.ae41  a2 06      ldx #$06         	LDX	#$06			; character count
.ae43  a5 78      lda $78          	LDA	TempB			; get # of characters
.ae45  f0 b7      beq $adfe        	BEQ	EndBHS		; branch if truncate
.ae47  aa         tax              	TAX				; copy length to X
.ae48  38         sec              	SEC				; set carry for add !
.ae49  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.ae4b  69 06      adc #$06         	ADC	#$06			; add 6d
.ae4d  f0 c9      beq $ae18        	BEQ	GoPr2			; if zero print whole string
.ae4f  d0 bc      bne $ae0d        	BNE	GoPr1			; else go make output string (branch always)
.ae51                              lab_a2hx
.ae51  aa         tax              	TAX				; save byte
.ae52  29 0f      and #$0f         	AND	#$0F			; mask off top bits
.ae54  20 5c ae   jsr $ae5c        	JSR	LAB_AL2X		; convert low nibble to ASCII and output
.ae57  8a         txa              	TXA				; get byte back
.ae58  4a         lsr              	LSR				; /2	shift high nibble to low nibble
.ae59  4a         lsr              	LSR				; /4
.ae5a  4a         lsr              	LSR				; /8
.ae5b  4a         lsr              	LSR				; /16
.ae5c                              lab_al2x
.ae5c  c9 0a      cmp #$0a         	CMP	#$0A			; set carry for +1 if >9
.ae5e  69 30      adc #$30         	ADC	#"0"			; add ASCII "0"
.ae60  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string
.ae62  88         dey              	DEY				; decrement counter
.ae63  60         rts              	RTS
.ae64                              lab_nlto
.ae64  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.ae66  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.ae68                              lab_mlte
.ae68  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.ae6a  8a         txa              	TXA				; restore character
.ae6b  20 45 aa   jsr $aa45        	JSR	LAB_2912		; evaluate new ASCII digit
.ae6e                              lab_chex
.ae6e  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.ae71  90 0a      bcc $ae7d        	BCC	LAB_ISHN		; branch if numeric character
.ae73  09 20      ora #$20         	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
.ae75  e9 61      sbc #$61         	SBC	#"a"			; subtract "a" (carry set here)
.ae77  c9 06      cmp #$06         	CMP	#$06			; compare normalised with $06 (max+1)
.ae79  b0 2a      bcs $aea5        	BCS	LAB_EXCH		; exit if >"f" or <"0"
.ae7b  69 0a      adc #$0a         	ADC	#$0A			; convert to nibble
.ae7d                              lab_ishn
.ae7d  29 0f      and #$0f         	AND	#$0F			; convert to binary
.ae7f  aa         tax              	TAX				; save nibble
.ae80  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ae82  f0 e4      beq $ae68        	BEQ	LAB_MLTE		; skip multiply if zero
.ae84  69 04      adc #$04         	ADC	#$04			; add four to exponent (*16 - carry clear here)
.ae86  90 dc      bcc $ae64        	BCC	LAB_NLTO		; if no overflow do evaluate digit
.ae88                              lab_mlto
.ae88  4c c3 a6   jmp $a6c3        	JMP	LAB_2564		; do overflow error and warm start
.ae8b                              lab_nxch
.ae8b  aa         tax              	TAX				; save bit
.ae8c  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ae8e  f0 06      beq $ae96        	BEQ	LAB_MLBT		; skip multiply if zero
.ae90  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*2)
.ae92  f0 f4      beq $ae88        	BEQ	LAB_MLTO		; do overflow error if = $00
.ae94  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.ae96                              lab_mlbt
.ae96  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.ae98  8a         txa              	TXA				; restore bit
.ae99  20 45 aa   jsr $aa45        	JSR	LAB_2912		; evaluate new ASCII digit
.ae9c                              lab_cbin
.ae9c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.ae9f  49 30      eor #$30         	EOR	#"0"			; convert "0" to 0 etc.
.aea1  c9 02      cmp #$02         	CMP	#$02			; compare with max+1
.aea3  90 e6      bcc $ae8b        	BCC	LAB_NXCH		; branch exit if < 2
.aea5                              lab_exch
.aea5  4c 2a aa   jmp $aa2a        	JMP	LAB_28F6		; evaluate -ve flag and return
.aea8                              ctrlc
.aea8  ad 00 02   lda $0200        	LDA	ccflag		; get [CTRL-C] check flag
.aeab  d0 18      bne $aec5        	BNE	LAB_FBA2		; exit if inhibited
.aead  20 ea b0   jsr $b0ea        	JSR	V_INPT		; scan input device
.aeb0  90 0b      bcc $aebd        	BCC	LAB_FBA0		; exit if buffer empty
.aeb2  8d 01 02   sta $0201        	STA	ccbyte		; save received byte
.aeb5  a2 20      ldx #$20         	LDX	#$20			; "life" timer for bytes
.aeb7  8e 02 02   stx $0202        	STX	ccnull		; set countdown
.aeba  4c 17 95   jmp $9517        	JMP	LAB_1636		; return to BASIC
.aebd                              lab_fba0
.aebd  ae 02 02   ldx $0202        	LDX	ccnull		; get countdown byte
.aec0  f0 03      beq $aec5        	BEQ	LAB_FBA2		; exit if finished
.aec2  ce 02 02   dec $0202        	DEC	ccnull		; else decrement countdown
.aec5                              lab_fba2
.aec5  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.aec7  20 d0 ae   jsr $aed0        	JSR	LAB_CKIN		; go check interrupt
.aeca  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values
.aecc  20 d0 ae   jsr $aed0        	JSR	LAB_CKIN		; go check interrupt
.aecf                              lab_crts
.aecf  60         rts              	RTS
.aed0                              lab_ckin
.aed0  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt flag byte
.aed2  10 fb      bpl $aecf        	BPL	LAB_CRTS		; branch if interrupt not enabled
.aed4  0a         asl              	ASL				; move happened bit to setup bit
.aed5  29 40      and #$40         	AND	#$40			; mask happened bits
.aed7  f0 f6      beq $aecf        	BEQ	LAB_CRTS		; if no interrupt then exit
.aed9  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.aedb  8a         txa              	TXA				; copy index ..
.aedc  a8         tay              	TAY				; .. to Y
.aedd  68         pla              	PLA				; dump return address low byte, call from CTRL-C
.aede  68         pla              	PLA				; dump return address high byte
.aedf  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.aee1  20 03 91   jsr $9103        	JSR	LAB_1212		; check room on stack for A bytes
.aee4  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.aee6  48         pha              	PHA				; push on stack
.aee7  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.aee9  48         pha              	PHA				; push on stack
.aeea  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.aeec  48         pha              	PHA				; push on stack
.aeed  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.aeef  48         pha              	PHA				; push on stack
.aef0  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.aef2  48         pha              	PHA				; push on stack
.aef3  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get interrupt code pointer low byte
.aef6  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.aef8  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get interrupt code pointer high byte
.aefb  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.aefd  4c bc 94   jmp $94bc        	JMP	LAB_15C2		; go do interpreter inner loop
.af00                              inget
.af00  20 ea b0   jsr $b0ea        	JSR	V_INPT		; call scan input device
.af03  b0 09      bcs $af0e        	BCS	LAB_FB95		; if byte go reset timer
.af05  ad 02 02   lda $0202        	LDA	ccnull		; get countdown
.af08  f0 09      beq $af13        	BEQ	LAB_FB96		; exit if empty
.af0a  ad 01 02   lda $0201        	LDA	ccbyte		; get last received byte
.af0d  38         sec              	SEC				; flag we got a byte
.af0e                              lab_fb95
.af0e  a2 00      ldx #$00         	LDX	#$00			; clear X
.af10  8e 02 02   stx $0202        	STX	ccnull		; clear timer because we got a byte
.af13                              lab_fb96
.af13  60         rts              	RTS
.af14                              lab_irq
.af14  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values

>af16  2c                          	.byte	$2C			; make next line BIT abs.
.af17                              lab_nmi

.af17  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.af19  c9 93      cmp #$93         	CMP	#TK_ON		; compare with token for ON
.af1b  f0 11      beq $af2e        	BEQ	LAB_INON		; go turn on interrupt
.af1d  c9 b6      cmp #$b6         	CMP	#TK_OFF		; compare with token for OFF
.af1f  f0 07      beq $af28        	BEQ	LAB_IOFF		; go turn off interrupt
.af21  49 a2      eor #$a2         	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
.af23  f0 0e      beq $af33        	BEQ	LAB_INEX		; go clear interrupt flags and return
.af25  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.af28                              lab_ioff
.af28  a9 7f      lda #$7f         	LDA	#$7F			; clear A
.af2a  35 00      and $00,x        	AND	PLUS_0,X		; AND with interrupt setup flag
.af2c  10 05      bpl $af33        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
.af2e                              lab_inon
.af2e  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt setup flag
.af30  0a         asl              	ASL				; Shift bit to enabled flag
.af31  15 00      ora $00,x        	ORA	PLUS_0,X		; OR with flag byte
.af33                              lab_inex
.af33  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.af35  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer and return
.af38                              lab_sirq
.af38  58         cli              	CLI				; enable interrupts
.af39  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values

>af3b  2c                          	.byte	$2C			; make next line BIT abs.
.af3c                              lab_snmi

.af3c  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.af3e  86 78      stx $78          	STX	TempB			; save interrupt pointer
.af40  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (past token)
.af43  20 55 97   jsr $9755        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.af46  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.af48  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.af4a  20 28 93   jsr $9328        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.af4d  b0 03      bcs $af52        	BCS	LAB_LFND		; if carry set go set-up interrupt
.af4f  4c 72 96   jmp $9672        	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
.af52                              lab_lfnd
.af52  a6 78      ldx $78          	LDX	TempB			; get interrupt pointer
.af54  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.af56  e9 01      sbc #$01         	SBC	#$01			; -1 (carry already set for subtract)
.af58  95 01      sta $01,x        	STA	PLUS_1,X		; save as interrupt pointer low byte
.af5a  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.af5c  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.af5e  95 02      sta $02,x        	STA	PLUS_2,X		; save as interrupt pointer high byte
.af60  a9 c0      lda #$c0         	LDA	#$C0			; set interrupt enabled/setup bits
.af62  95 00      sta $00,x        	STA	PLUS_0,X		; set interrupt flags
.af64                              lab_irts
.af64  60         rts              	RTS
.af65                              lab_retirq
.af65  d0 fd      bne $af64        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.af67  a5 df      lda $df          	LDA	IrqBase		; get interrupt flags
.af69  0a         asl              	ASL				; copy setup to enabled (b7)
.af6a  05 df      ora $df          	ORA	IrqBase		; OR in setup flag
.af6c  85 df      sta $df          	STA	IrqBase		; save enabled flag
.af6e  4c 79 96   jmp $9679        	JMP	LAB_16E8		; go do rest of RETURN
.af71                              lab_retnmi
.af71  d0 f1      bne $af64        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.af73  a5 dc      lda $dc          	LDA	NmiBase		; get set-up flag
.af75  0a         asl              	ASL				; copy setup to enabled (b7)
.af76  05 dc      ora $dc          	ORA	NmiBase		; OR in setup flag
.af78  85 dc      sta $dc          	STA	NmiBase		; save enabled flag
.af7a  4c 79 96   jmp $9679        	JMP	LAB_16E8		; go do rest of RETURN
.af7d                              lab_mmpp
.af7d  20 e9 9a   jsr $9ae9        	JSR	LAB_EVEZ		; process expression
.af80  4c d0 9a   jmp $9ad0        	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
.af83                              lab_max
.af83  20 b1 af   jsr $afb1        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.af86  10 fb      bpl $af83        	BPL	LAB_MAX		; branch if no swap to do
.af88  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.af8a  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.af8c  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.af8e  20 c3 a5   jsr $a5c3        	JSR	LAB_279B		; copy FAC2 to FAC1
.af91  f0 f0      beq $af83        	BEQ	LAB_MAX		; go do next (branch always)
.af93                              lab_min
.af93  20 b1 af   jsr $afb1        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.af96  30 fb      bmi $af93        	BMI	LAB_MIN		; branch if no swap to do
.af98  f0 f9      beq $af93        	BEQ	LAB_MIN		; branch if no swap to do
.af9a  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.af9c  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.af9e  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.afa0  20 c3 a5   jsr $a5c3        	JSR	LAB_279B		; copy FAC2 to FAC1
.afa3  f0 ee      beq $af93        	BEQ	LAB_MIN		; go do next (branch always)
.afa5                              lab_mmec
.afa5  c9 29      cmp #$29         	CMP	#")"			; is it end of function?
.afa7  d0 05      bne $afae        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
.afa9  68         pla              	PLA				; dump return address low byte
.afaa  68         pla              	PLA				; dump return address high byte
.afab  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
.afae                              lab_mmse
.afae  4c 02 9c   jmp $9c02        	JMP	LAB_SNER		; do syntax error then warm start
.afb1                              lab_phfa
.afb1  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.afb4  c9 2c      cmp #$2c         	CMP	#","			; is there more ?
.afb6  d0 ed      bne $afa5        	BNE	LAB_MMEC		; if not go do end check
.afb8  20 d9 a8   jsr $a8d9        	JSR	LAB_27BA		; round FAC1
.afbb  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.afbd  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.afbf  25 ad      and $ad          	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
.afc1  48         pha              	PHA				; push on stack
.afc2  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.afc4  48         pha              	PHA				; push on stack
.afc5  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.afc7  48         pha              	PHA				; push on stack
.afc8  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.afca  48         pha              	PHA				; push on stack
.afcb  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
.afce  20 cd 9a   jsr $9acd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.afd1  68         pla              	PLA				; pop exponent
.afd2  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.afd4  68         pla              	PLA				; pop mantissa3
.afd5  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.afd7  68         pla              	PLA				; pop mantissa1
.afd8  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.afda  68         pla              	PLA				; pop sign/mantissa1
.afdb  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 sign/mantissa1
.afdd  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign
.afdf  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.afe1  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.afe3  4c 17 a9   jmp $a917        	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
.afe6                              lab_wdth
.afe6  c9 2c      cmp #$2c         	CMP	#","			; is next byte ","
.afe8  f0 1b      beq $b005        	BEQ	LAB_TBSZ		; if so do tab size
.afea  20 8c a4   jsr $a48c        	JSR	LAB_GTBY		; get byte parameter
.afed  8a         txa              	TXA				; copy width to A
.afee  f0 0a      beq $affa        	BEQ	LAB_NSTT		; branch if set for infinite line
.aff0  e0 10      cpx #$10         	CPX	#$10			; else make min width = 16d
.aff2  90 45      bcc $b039        	BCC	TabErr		; if less do function call error and exit
.aff4  e4 64      cpx $64          	CPX	TabSiz		; compare with tab size
.aff6  b0 02      bcs $affa        	BCS	LAB_NSTT		; branch if >= tab size
.aff8  86 64      stx $64          	STX	TabSiz		; else make tab size = terminal width
.affa                              lab_nstt
.affa  86 0f      stx $0f          	STX	TWidth		; set the terminal width
.affc  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get BASIC byte back
.afff  f0 1a      beq $b01b        	BEQ	WExit			; exit if no following
.b001  c9 2c      cmp #$2c         	CMP	#","			; else is it ","
.b003  d0 a9      bne $afae        	BNE	LAB_MMSE		; if not do syntax error
.b005                              lab_tbsz
.b005  20 89 a4   jsr $a489        	JSR	LAB_SGBY		; scan and get byte parameter
.b008  8a         txa              	TXA				; copy TAB size
.b009  30 2e      bmi $b039        	BMI	TabErr		; if >127 do function call error and exit
.b00b  e0 01      cpx #$01         	CPX	#$01			; compare with min-1
.b00d  90 2a      bcc $b039        	BCC	TabErr		; if <=1 do function call error and exit
.b00f  a5 0f      lda $0f          	LDA	TWidth		; set flags for width
.b011  f0 06      beq $b019        	BEQ	LAB_SVTB		; skip check if infinite line
.b013  e4 0f      cpx $0f          	CPX	TWidth		; compare TAB with width
.b015  f0 02      beq $b019        	BEQ	LAB_SVTB		; ok if =
.b017  b0 20      bcs $b039        	BCS	TabErr		; branch if too big
.b019                              lab_svtb
.b019  86 64      stx $64          	STX	TabSiz		; save TAB size
.b01b                              wexit
.b01b  a5 0f      lda $0f          	LDA	TWidth		; get width
.b01d  f0 06      beq $b025        	BEQ	LAB_SULP		; branch if infinite line
.b01f  c5 64      cmp $64          	CMP	TabSiz		; compare with tab size
.b021  b0 03      bcs $b026        	BCS	LAB_WDLP		; branch if >= tab size
.b023  85 64      sta $64          	STA	TabSiz		; else make tab size = terminal width
.b025                              lab_sulp
.b025  38         sec              	SEC				; set carry for subtract
.b026                              lab_wdlp
.b026  e5 64      sbc $64          	SBC	TabSiz		; subtract tab size
.b028  b0 fc      bcs $b026        	BCS	LAB_WDLP		; loop while no borrow
.b02a  65 64      adc $64          	ADC	TabSiz		; add tab size back
.b02c  18         clc              	CLC				; clear carry for add
.b02d  65 64      adc $64          	ADC	TabSiz		; add tab size back again
.b02f  85 10      sta $10          	STA	Iclim			; save for now
.b031  a5 0f      lda $0f          	LDA	TWidth		; get width back
.b033  38         sec              	SEC				; set carry for subtract
.b034  e5 10      sbc $10          	SBC	Iclim			; subtract remainder
.b036  85 10      sta $10          	STA	Iclim			; save tab column limit
.b038                              lab_nosq
.b038  60         rts              	RTS
.b039                              taberr
.b039  4c 29 9f   jmp $9f29        	JMP	LAB_FCER		; do function call error then warm start
.b03c                              lab_sqr
.b03c  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.b03e  30 f9      bmi $b039        	BMI	TabErr		; if -ve do function call error
.b040  a5 ac      lda $ac          	LDA	FAC1_e		; get exponent
.b042  f0 f4      beq $b038        	BEQ	LAB_NOSQ		; if zero just return
.b044  20 ca a8   jsr $a8ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.b047  a9 00      lda #$00         	LDA	#$00			; clear A
.b049  85 77      sta $77          	STA	FACt_3		; clear remainder
.b04b  85 76      sta $76          	STA	FACt_2		; ..
.b04d  85 75      sta $75          	STA	FACt_1		; ..
.b04f  85 78      sta $78          	STA	TempB			; ..
.b051  85 af      sta $af          	STA	FAC1_3		; clear root
.b053  85 ae      sta $ae          	STA	FAC1_2		; ..
.b055  85 ad      sta $ad          	STA	FAC1_1		; ..
.b057  a2 18      ldx #$18         	LDX	#$18			; 24 pairs of bits to do
.b059  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.b05b  4a         lsr              	LSR				; check odd/even
.b05c  b0 0e      bcs $b06c        	BCS	LAB_SQE2		; if odd only 1 shift first time
.b05e                              lab_sqe1
.b05e  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.b060  26 b5      rol $b5          	ROL	FAC2_2		; ..
.b062  26 b4      rol $b4          	ROL	FAC2_1		; ..
.b064  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.b066  26 76      rol $76          	ROL	FACt_2		; ..
.b068  26 75      rol $75          	ROL	FACt_1		; ..
.b06a  26 78      rol $78          	ROL	TempB			; .. never overflows
.b06c                              lab_sqe2
.b06c  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.b06e  26 b5      rol $b5          	ROL	FAC2_2		; ..
.b070  26 b4      rol $b4          	ROL	FAC2_1		; ..
.b072  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.b074  26 76      rol $76          	ROL	FACt_2		; ..
.b076  26 75      rol $75          	ROL	FACt_1		; ..
.b078  26 78      rol $78          	ROL	TempB			; .. never overflows
.b07a  06 af      asl $af          	ASL	FAC1_3		; root = root * 2
.b07c  26 ae      rol $ae          	ROL	FAC1_2		; ..
.b07e  26 ad      rol $ad          	ROL	FAC1_1		; .. never overflows
.b080  a5 af      lda $af          	LDA	FAC1_3		; get root low byte
.b082  2a         rol              	ROL				; *2
.b083  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.b085  a5 ae      lda $ae          	LDA	FAC1_2		; get root low mid byte
.b087  2a         rol              	ROL				; *2
.b088  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.b08a  a5 ad      lda $ad          	LDA	FAC1_1		; get root high mid byte
.b08c  2a         rol              	ROL				; *2
.b08d  85 5d      sta $5d          	STA	Temp3+2		; save partial high mid byte
.b08f  a9 00      lda #$00         	LDA	#$00			; get root high byte (always $00)
.b091  2a         rol              	ROL				; *2
.b092  85 5e      sta $5e          	STA	Temp3+3		; save partial high byte
.b094  a5 77      lda $77          	LDA	FACt_3		; get remainder low byte
.b096  e5 5b      sbc $5b          	SBC	Temp3			; subtract partial low byte
.b098  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.b09a  a5 76      lda $76          	LDA	FACt_2		; get remainder low mid byte
.b09c  e5 5c      sbc $5c          	SBC	Temp3+1		; subtract partial low mid byte
.b09e  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.b0a0  a5 75      lda $75          	LDA	FACt_1		; get remainder high mid byte
.b0a2  e5 5d      sbc $5d          	SBC	Temp3+2		; subtract partial high mid byte
.b0a4  a8         tay              	TAY				; copy partial high mid byte
.b0a5  a5 78      lda $78          	LDA	TempB			; get remainder high byte
.b0a7  e5 5e      sbc $5e          	SBC	Temp3+3		; subtract partial high byte
.b0a9  90 0e      bcc $b0b9        	BCC	LAB_SQNS		; skip sub if remainder smaller
.b0ab  85 78      sta $78          	STA	TempB			; save remainder high byte
.b0ad  84 75      sty $75          	STY	FACt_1		; save remainder high mid byte
.b0af  a5 5c      lda $5c          	LDA	Temp3+1		; get remainder low mid byte
.b0b1  85 76      sta $76          	STA	FACt_2		; save remainder low mid byte
.b0b3  a5 5b      lda $5b          	LDA	Temp3			; get partial low byte
.b0b5  85 77      sta $77          	STA	FACt_3		; save remainder low byte
.b0b7  e6 af      inc $af          	INC	FAC1_3		; increment root low byte (never any rollover)
.b0b9                              lab_sqns
.b0b9  ca         dex              	DEX				; decrement bit pair count
.b0ba  d0 a2      bne $b05e        	BNE	LAB_SQE1		; loop if not all done
.b0bc  38         sec              	SEC				; set carry for subtract
.b0bd  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.b0bf  e9 80      sbc #$80         	SBC	#$80			; normalise
.b0c1  6a         ror              	ROR				; /2 and re-bias to $80
.b0c2  69 00      adc #$00         	ADC	#$00			; add bit zero back in (allow for half shift)
.b0c4  85 ac      sta $ac          	STA	FAC1_e		; save it
.b0c6  4c 34 a6   jmp $a634        	JMP	LAB_24D5		; normalise FAC1 and return
.b0c9                              lab_varptr
.b0c9  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.b0cc  20 aa 9d   jsr $9daa        	JSR	LAB_GVAR		; get var address
.b0cf  20 ef 9b   jsr $9bef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.b0d2  a4 95      ldy $95          	LDY	Cvaral		; get var address low byte
.b0d4  a5 96      lda $96          	LDA	Cvarah		; get var address high byte
.b0d6  4c 59 a0   jmp $a059        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.b0d9                              lab_pi
.b0d9  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.b0db  a0 b1      ldy #$b1         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.b0dd  20 7d a8   jsr $a87d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.b0e0  c6 ac      dec $ac          	DEC	FAC1_e		; make result = PI
.b0e2  60         rts              	RTS
.b0e3                              lab_twopi
.b0e3  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.b0e5  a0 b1      ldy #$b1         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.b0e7  4c 7d a8   jmp $a87d        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
.b0ea                              v_inpt
.b0ea  6c 05 02   jmp ($0205)      	JMP	(VEC_IN)		; non halting scan input device
.b0ed                              v_outp
.b0ed  6c 07 02   jmp ($0207)      	JMP	(VEC_OUT)		; send byte to output device
.b0f0                              v_load
.b0f0  6c 09 02   jmp ($0209)      	JMP	(VEC_LD)		; load BASIC program
.b0f3                              v_save
.b0f3  6c 0b 02   jmp ($020b)      	JMP	(VEC_SV)		; save BASIC program
.b0f6                              pg2_tabs

>b0f6  00                          	.byte	$00			; ctrl-c flag		-	$00 = enabled
>b0f7  00                          	.byte	$00			; ctrl-c byte		-	GET needs this
>b0f8  00                          	.byte	$00			; ctrl-c byte timeout	-	GET needs this
>b0f9  a8 ae                       	.word	CTRLC			; ctrl c check vector
.b0fb                              pg2_tabe
.b0fb                              lab_2cee

.b0fb  e6 c3      inc $c3          	INC	Bpntrl		; increment BASIC execute pointer low byte
.b0fd  d0 02      bne $b101        	BNE	LAB_2CF4		; branch if no carry
.b0ff  e6 c4      inc $c4          	INC	Bpntrh		; increment BASIC execute pointer high byte
.b101                              lab_2cf4
.b101  ad ff ff   lda $ffff        	LDA	$FFFF			; get byte to scan (addr set by call routine)
.b104  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare with the token for ELSE
.b106  f0 0e      beq $b116        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
.b108  c9 3a      cmp #$3a         	CMP	#":"			; compare with ":"
.b10a  b0 0a      bcs $b116        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
.b10c  c9 20      cmp #$20         	CMP	#" "			; compare with " "
.b10e  f0 eb      beq $b0fb        	BEQ	LAB_2CEE		; if " " go do next
.b110  38         sec              	SEC				; set carry for SBC
.b111  e9 30      sbc #$30         	SBC	#"0"			; subtract "0"
.b113  38         sec              	SEC				; set carry for SBC
.b114  e9 d0      sbc #$d0         	SBC	#$D0			; subtract -"0"
.b116                              lab_2d05
.b116  60         rts              	RTS
.b117                              strtab

>b117  4c                          	.byte	$4C			; JMP opcode
>b118  00 90                       	.word LAB_COLD		; initial warm start vector (cold start)
>b11a  00                          	.byte	$00			; these bytes are not used by BASIC
>b11b  00 00                       	.word	$0000			; 
>b11d  00 00                       	.word	$0000			; 
>b11f  00 00                       	.word	$0000			; 
>b121  4c                          	.byte	$4C			; JMP opcode
>b122  29 9f                       	.word	LAB_FCER		; initial user function vector ("Function call" error)
>b124  00                          	.byte	$00			; default NULL count
>b125  00                          	.byte	$00			; clear terminal position
>b126  00                          	.byte	$00			; default terminal width byte
>b127  f2                          	.byte	$F2			; default limit for TAB = 14
>b128  00 04                       	.word	Ram_base		; start of user RAM
.b12a                              endtab
.b12a                              lab_mszm
>b12a  0d 0a 4d 65 6d 6f 72 79 20 73 69 7a 65 20 00  	.byte	$0D,$0A,"Memory size ",$00
.b139                              lab_smsg
>b139  20 42 79 74 65 73 20 66 72 65 65 0d 0a 0a  	.byte	" Bytes free",$0D,$0A,$0A
>b147  45 6e 68 61 6e 63 65 64 20 42 41 53 49 43 20 32 2e 32 32 0a 00  	.byte	"Enhanced BASIC 2.22",$0A,$00
.b15c                              lab_25a0
>b15c  02                          	.byte	$02			; counter
>b15d  80 19 56 62                 	.byte	$80,$19,$56,$62	; 0.59898
>b161  80 76 22 f3                 	.byte	$80,$76,$22,$F3	; 0.96147
>b165  82 38 aa 40                 	.byte	$82,$38,$AA,$40	; 2.88539
.b169                              lab_25ad
>b169  80 35 04 f3                 	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
.b16d                              lab_25b1
>b16d  81 35 04 f3                 	.byte	$81,$35,$04,$F3	; 1.41421	root 2
.b171                              lab_25b5
>b171  80 80 00 00                 	.byte	$80,$80,$00,$00	; -0.5
.b175                              lab_25b9
>b175  80 31 72 18                 	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
.b179                              lab_2947
>b179  91 43 4f f8                 	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
.b17d                              lab_294b
>b17d  94 74 23 f7                 	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
.b181                              lab_294f
>b181  94 74 24 00                 	.byte	$94,$74,$24,$00	; 1000000
.b185                              lab_2afa
>b185  81 38 aa 3b                 	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
.b189                              lab_2afe
>b189  06                          	.byte	$06			; counter
>b18a  74 63 90 8c                 	.byte	$74,$63,$90,$8C	; 2.17023e-4
>b18e  77 23 0c ab                 	.byte	$77,$23,$0C,$AB	; 0.00124
>b192  7a 1e 94 00                 	.byte	$7A,$1E,$94,$00	; 0.00968
>b196  7c 63 42 80                 	.byte	$7C,$63,$42,$80	; 0.05548
>b19a  7e 75 fe d0                 	.byte	$7E,$75,$FE,$D0	; 0.24023
>b19e  80 31 72 15                 	.byte	$80,$31,$72,$15	; 0.69315
>b1a2  81 00 00 00                 	.byte	$81,$00,$00,$00	; 1.00000
.b1a6                              lab_2c78
>b1a6  81 49 0f db                 	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
.b1aa                              lab_2c84
>b1aa  04                          	.byte	$04			; counter
>b1ab  86 1e d7 fb                 	.byte	$86,$1E,$D7,$FB	; 39.7109
>b1af  87 99 26 65                 	.byte	$87,$99,$26,$65	;-76.575
>b1b3  87 23 34 58                 	.byte	$87,$23,$34,$58	; 81.6022
>b1b7  86 a5 5d e1                 	.byte	$86,$A5,$5D,$E1	;-41.3417
.b1bb                              lab_2c7c
>b1bb  83 49 0f db                 	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
.b1bf                              lab_2cc9
>b1bf  08                          	.byte	$08			; counter
>b1c0  78 3a c5 37                 	.byte	$78,$3A,$C5,$37	; 0.00285
>b1c4  7b 83 a2 5c                 	.byte	$7B,$83,$A2,$5C	;-0.0160686
>b1c8  7c 2e dd 4d                 	.byte	$7C,$2E,$DD,$4D	; 0.0426915
>b1cc  7d 99 b0 1e                 	.byte	$7D,$99,$B0,$1E	;-0.0750429
>b1d0  7d 59 ed 24                 	.byte	$7D,$59,$ED,$24	; 0.106409
>b1d4  7e 91 72 00                 	.byte	$7E,$91,$72,$00	;-0.142036
>b1d8  7e 4c b9 73                 	.byte	$7E,$4C,$B9,$73	; 0.199926
>b1dc  7f aa aa 53                 	.byte	$7F,$AA,$AA,$53	;-0.333331
.b1e0                              lab_259c
>b1e0  81 00 00 00                 	.byte	$81,$00,$00,$00	; 1.000000, used for INC
.b1e4                              lab_2afd
>b1e4  81 80 00 00                 	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
.b1e8                              lab_1df7
>b1e8  90                          	.byte	$90			;-32768 (uses first three bytes from 0.5)
.b1e9                              lab_2a96
>b1e9  80 00 00 00                 	.byte	$80,$00,$00,$00	; 0.5
.b1ed                              lab_2c80
>b1ed  7f 00 00 00                 	.byte	$7F,$00,$00,$00	; 0.25
.b1f1                              lab_26b5
>b1f1  84 20 00 00                 	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
.b1f5                              lab_2a9a
>b1f5  fe 79 60                    	.byte	$FE,$79,$60		; -100000
>b1f8  00 27 10                    	.byte	$00,$27,$10		; 10000
>b1fb  ff fc 18                    	.byte	$FF,$FC,$18		; -1000
>b1fe  00 00 64                    	.byte	$00,$00,$64		; 100
>b201  ff ff f6                    	.byte	$FF,$FF,$F6		; -10
>b204  00 00 01                    	.byte	$00,$00,$01		; 1
.b207                              lab_ctbl
>b207  1a 95                       	.word	LAB_END-1		; END
>b209  57 94                       	.word	LAB_FOR-1		; FOR
>b20b  64 9a                       	.word	LAB_NEXT-1		; NEXT
>b20d  8b 96                       	.word	LAB_DATA-1		; DATA
>b20f  46 99                       	.word	LAB_INPUT-1		; INPUT
>b211  5e 9d                       	.word	LAB_DIM-1		; DIM
>b213  66 99                       	.word	LAB_READ-1		; READ
>b215  b3 97                       	.word	LAB_LET-1		; LET
>b217  85 97                       	.word	LAB_DEC-1		; DEC			new command
>b219  ea 95                       	.word	LAB_GOTO-1		; GOTO
>b21b  a9 95                       	.word	LAB_RUN-1		; RUN
>b21d  b9 96                       	.word	LAB_IF-1		; IF
>b21f  41 95                       	.word	LAB_RESTORE-1	; RESTORE		modified command
>b221  cd 95                       	.word	LAB_GOSUB-1		; GOSUB
>b223  64 af                       	.word	LAB_RETIRQ-1	; RETIRQ		new command
>b225  70 af                       	.word	LAB_RETNMI-1	; RETNMI		new command
>b227  76 96                       	.word	LAB_RETURN-1	; RETURN
>b229  1d 97                       	.word	LAB_REM-1		; REM
>b22b  18 95                       	.word	LAB_STOP-1		; STOP
>b22d  26 97                       	.word	LAB_ON-1		; ON			modified command
>b22f  7f 95                       	.word	LAB_NULL-1		; NULL		modified command
>b231  88 97                       	.word	LAB_INC-1		; INC			new command
>b233  88 a5                       	.word	LAB_WAIT-1		; WAIT
>b235  ef b0                       	.word	V_LOAD-1		; LOAD
>b237  f2 b0                       	.word	V_SAVE-1		; SAVE
>b239  73 a0                       	.word	LAB_DEF-1		; DEF
>b23b  0d a5                       	.word	LAB_POKE-1		; POKE
>b23d  29 a5                       	.word	LAB_DOKE-1		; DOKE		new command
>b23f  76 a5                       	.word	LAB_CALL-1		; CALL		new command
>b241  b3 95                       	.word	LAB_DO-1		; DO			new command
>b243  1c 96                       	.word	LAB_LOOP-1		; LOOP		new command
>b245  54 98                       	.word	LAB_PRINT-1		; PRINT
>b247  85 95                       	.word	LAB_CONT-1		; CONT
>b249  a2 93                       	.word	LAB_LIST-1		; LIST
>b24b  9f 93                       	.word	LAB_CLEAR-1		; CLEAR
>b24d  4d 93                       	.word	LAB_NEW-1		; NEW
>b24f  e5 af                       	.word	LAB_WDTH-1		; WIDTH		new command
>b251  23 98                       	.word	LAB_GET-1		; GET			new command
>b253  4e a5                       	.word	LAB_SWAP-1		; SWAP		new command
>b255  81 ad                       	.word	LAB_BITSET-1	; BITSET		new command
>b257  95 ad                       	.word	LAB_BITCLR-1	; BITCLR		new command
>b259  13 af                       	.word	LAB_IRQ-1		; IRQ			new command
>b25b  16 af                       	.word	LAB_NMI-1		; NMI			new command
>b25d  48 e2                       	.word   SYSjmp-1                ; SYS         *** added for SBC-2
.b25f                              lab_ftpl
>b25f  64 9c                       	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
>b261  64 9c                       	.word	LAB_PPFN-1		; INT(n)		"
>b263  64 9c                       	.word	LAB_PPFN-1		; ABS(n)		"
>b265  e8 9a                       	.word	LAB_EVEZ-1		; USR(x)	process any expression
>b267  eb 9b                       	.word	LAB_1BF7-1		; FRE(x)		"
>b269  eb 9b                       	.word	LAB_1BF7-1		; POS(x)		"
>b26b  64 9c                       	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
>b26d  64 9c                       	.word	LAB_PPFN-1		; RND(n)		"
>b26f  64 9c                       	.word	LAB_PPFN-1		; LOG(n)		"
>b271  64 9c                       	.word	LAB_PPFN-1		; EXP(n)		"
>b273  64 9c                       	.word	LAB_PPFN-1		; COS(n)		"
>b275  64 9c                       	.word	LAB_PPFN-1		; SIN(n)		"
>b277  64 9c                       	.word	LAB_PPFN-1		; TAN(n)		"
>b279  64 9c                       	.word	LAB_PPFN-1		; ATN(n)		"
>b27b  64 9c                       	.word	LAB_PPFN-1		; PEEK(n)		"
>b27d  64 9c                       	.word	LAB_PPFN-1		; DEEK(n)		"
>b27f  00 00                       	.word	$0000			; SADD()	none
>b281  5e 9c                       	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
>b283  64 9c                       	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
>b285  5e 9c                       	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
>b287  5e 9c                       	.word	LAB_PPFS-1		; ASC($)		"
>b289  5e 9c                       	.word	LAB_PPFS-1		; UCASE$($)		"
>b28b  5e 9c                       	.word	LAB_PPFS-1		; LCASE$($)		"
>b28d  64 9c                       	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
>b28f  8b 9c                       	.word	LAB_BHSS-1		; HEX$(n)		"
>b291  8b 9c                       	.word	LAB_BHSS-1		; BIN$(n)		"
>b293  00 00                       	.word	$0000			; BITTST()	none
>b295  7c af                       	.word	LAB_MMPP-1		; MAX()	process numeric expression
>b297  7c af                       	.word	LAB_MMPP-1		; MIN()		"
>b299  6a 9c                       	.word	LAB_PPBI-1		; PI		advance pointer
>b29b  6a 9c                       	.word	LAB_PPBI-1		; TWOPI		"
>b29d  00 00                       	.word	$0000			; VARPTR()	none
>b29f  6f 9c                       	.word	LAB_LRMS-1		; LEFT$()	process string expression
>b2a1  6f 9c                       	.word	LAB_LRMS-1		; RIGHT$()		"
>b2a3  6f 9c                       	.word	LAB_LRMS-1		; MID$()		"
.b2a5                              lab_ftbl
>b2a5  f6 a8                       	.word	LAB_SGN-1		; SGN()
>b2a7  80 a9                       	.word	LAB_INT-1		; INT()
>b2a9  13 a9                       	.word	LAB_ABS-1		; ABS()
>b2ab  4c ad                       	.word	LAB_USR-1		; USR()
>b2ad  44 a0                       	.word	LAB_FRE-1		; FRE()
>b2af  63 a0                       	.word	LAB_POS-1		; POS()
>b2b1  3b b0                       	.word	LAB_SQR-1		; SQR()
>b2b3  9c ac                       	.word	LAB_RND-1		; RND()		modified function
>b2b5  fa a6                       	.word	LAB_LOG-1		; LOG()
>b2b7  fe ab                       	.word	LAB_EXP-1		; EXP()
>b2b9  d0 ac                       	.word	LAB_COS-1		; COS()
>b2bb  d7 ac                       	.word	LAB_SIN-1		; SIN()
>b2bd  20 ad                       	.word	LAB_TAN-1		; TAN()
>b2bf  52 ad                       	.word	LAB_ATN-1		; ATN()
>b2c1  02 a5                       	.word	LAB_PEEK-1		; PEEK()
>b2c3  16 a5                       	.word	LAB_DEEK-1		; DEEK()		new function
>b2c5  54 a4                       	.word	LAB_SADD-1		; SADD()		new function
>b2c7  6d a4                       	.word	LAB_LENS-1		; LEN()
>b2c9  25 a1                       	.word	LAB_STRS-1		; STR$()
>b2cb  9a a4                       	.word	LAB_VAL-1		; VAL()
>b2cd  78 a4                       	.word	LAB_ASC-1		; ASC()
>b2cf  32 a4                       	.word	LAB_UCASE-1		; UCASE$()		new function
>b2d1  11 a4                       	.word	LAB_LCASE-1		; LCASE$()		new function
>b2d3  83 a3                       	.word	LAB_CHRS-1		; CHR$()
>b2d5  22 ae                       	.word	LAB_HEXS-1		; HEX$()		new function
>b2d7  d3 ad                       	.word	LAB_BINS-1		; BIN$()		new function
>b2d9  ab ad                       	.word	LAB_BTST-1		; BITTST()		new function
>b2db  82 af                       	.word	LAB_MAX-1		; MAX()		new function
>b2dd  92 af                       	.word	LAB_MIN-1		; MIN()		new function
>b2df  d8 b0                       	.word	LAB_PI-1		; PI			new function
>b2e1  e2 b0                       	.word	LAB_TWOPI-1		; TWOPI		new function
>b2e3  c8 b0                       	.word	LAB_VARPTR-1	; VARPTR()		new function
>b2e5  95 a3                       	.word	LAB_LEFT-1		; LEFT$()
>b2e7  9e a3                       	.word	LAB_RIGHT-1		; RIGHT$()
>b2e9  cd a3                       	.word	LAB_MIDS-1		; MID$()
.b2eb                              lab_oppt
>b2eb  79                          	.byte	$79			; +
>b2ec  c0 a5                       	.word	LAB_ADD-1
>b2ee  79                          	.byte	$79			; -
>b2ef  a5 a5                       	.word	LAB_SUBTRACT-1
>b2f1  7b                          	.byte	$7B			; *
>b2f2  3b a7                       	.word	LAB_MULTIPLY-1
>b2f4  7b                          	.byte	$7B			; /
>b2f5  03 a8                       	.word	LAB_DIVIDE-1
>b2f7  7f                          	.byte	$7F			; ^
>b2f8  ba ab                       	.word	LAB_POWER-1
>b2fa  50                          	.byte	$50			; AND
>b2fb  d4 9c                       	.word	LAB_AND-1
>b2fd  46                          	.byte	$46			; EOR			new operator
>b2fe  ba 9c                       	.word	LAB_EOR-1
>b300  46                          	.byte	$46			; OR
>b301  c7 9c                       	.word	LAB_OR-1
>b303  56                          	.byte	$56			; >>			new operator
>b304  80 9d                       	.word	LAB_RSHIFT-1
>b306  56                          	.byte	$56			; <<			new operator
>b307  68 9d                       	.word	LAB_LSHIFT-1
>b309  7d                          	.byte	$7D			; >
>b30a  f3 ab                       	.word	LAB_GTHAN-1
>b30c  5a                          	.byte	$5A			; =
>b30d  16 9c                       	.word	LAB_EQUAL-1
>b30f  64                          	.byte	$64			; <
>b310  f5 9c                       	.word	LAB_LTHAN-1
.b312                              tab_1stc
>b312  2a                          	.byte	"*"
>b313  2b                          	.byte	"+"
>b314  2d                          	.byte	"-"
>b315  2f                          	.byte	"/"
>b316  3c                          	.byte	"<"
>b317  3d                          	.byte	"="
>b318  3e                          	.byte	">"
>b319  3f                          	.byte	"?"
>b31a  41                          	.byte	"A"
>b31b  42                          	.byte	"B"
>b31c  43                          	.byte	"C"
>b31d  44                          	.byte	"D"
>b31e  45                          	.byte	"E"
>b31f  46                          	.byte	"F"
>b320  47                          	.byte	"G"
>b321  48                          	.byte	"H"
>b322  49                          	.byte	"I"
>b323  4c                          	.byte	"L"
>b324  4d                          	.byte	"M"
>b325  4e                          	.byte	"N"
>b326  4f                          	.byte	"O"
>b327  50                          	.byte	"P"
>b328  52                          	.byte	"R"
>b329  53                          	.byte	"S"
>b32a  54                          	.byte	"T"
>b32b  55                          	.byte	"U"
>b32c  56                          	.byte	"V"
>b32d  57                          	.byte	"W"
>b32e  5e                          	.byte	"^"
>b32f  00                          	.byte	$00			; table terminator
.b330                              tab_chrt
>b330  6a b3                       	.word	TAB_STAR		; table for "*"
>b332  6c b3                       	.word	TAB_PLUS		; table for "+"
>b334  6e b3                       	.word	TAB_MNUS		; table for "-"
>b336  70 b3                       	.word	TAB_SLAS		; table for "/"
>b338  72 b3                       	.word	TAB_LESS		; table for "<"
>b33a  76 b3                       	.word	TAB_EQUL		; table for "="
>b33c  78 b3                       	.word	TAB_MORE		; table for ">"
>b33e  7c b3                       	.word	TAB_QEST		; table for "?"
>b340  7e b3                       	.word	TAB_ASCA		; table for "A"
>b342  8e b3                       	.word	TAB_ASCB		; table for "B"
>b344  a7 b3                       	.word	TAB_ASCC		; table for "C"
>b346  be b3                       	.word	TAB_ASCD		; table for "D"
>b348  d7 b3                       	.word	TAB_ASCE		; table for "E"
>b34a  e6 b3                       	.word	TAB_ASCF		; table for "F"
>b34c  f0 b3                       	.word	TAB_ASCG		; table for "G"
>b34e  fd b3                       	.word	TAB_ASCH		; table for "H"
>b350  03 b4                       	.word	TAB_ASCI		; table for "I"
>b352  15 b4                       	.word	TAB_ASCL		; table for "L"
>b354  3a b4                       	.word	TAB_ASCM		; table for "M"
>b356  48 b4                       	.word	TAB_ASCN		; table for "N"
>b358  5a b4                       	.word	TAB_ASCO		; table for "O"
>b35a  62 b4                       	.word	TAB_ASCP		; table for "P"
>b35c  77 b4                       	.word	TAB_ASCR		; table for "R"
>b35e  a6 b4                       	.word	TAB_ASCS		; table for "S"
>b360  d4 b4                       	.word	TAB_ASCT		; table for "T"
>b362  e8 b4                       	.word	TAB_ASCU		; table for "U"
>b364  f9 b4                       	.word	TAB_ASCV		; table for "V"
>b366  05 b5                       	.word	TAB_ASCW		; table for "W"
>b368  14 b5                       	.word	TAB_POWR		; table for "^"
.b36a                              tab_star
>b36a  b9 00                       	.byte TK_MUL,$00		; *
.b36c                              tab_plus
>b36c  b7 00                       	.byte TK_PLUS,$00		; +
.b36e                              tab_mnus
>b36e  b8 00                       	.byte TK_MINUS,$00	; -
.b370                              tab_slas
>b370  ba 00                       	.byte TK_DIV,$00		; /
.b372                              tab_less
.b372                              lbb_lshift
>b372  3c c0                       	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
>b374  c3                          	.byte TK_LT			; <
>b375  00                          	.byte	$00
.b376                              tab_equl
>b376  c2 00                       	.byte TK_EQUAL,$00	; =
.b378                              tab_more
.b378                              lbb_rshift
>b378  3e bf                       	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
>b37a  c1                          	.byte TK_GT			; >
>b37b  00                          	.byte	$00
.b37c                              tab_qest
>b37c  9f 00                       	.byte TK_PRINT,$00	; ?
.b37e                              tab_asca
.b37e                              lbb_abs
>b37e  42 53 28 c6                 	.byte	"BS(",TK_ABS	; ABS(
.b382                              lbb_and
>b382  4e 44 bc                    	.byte	"ND",TK_AND		; AND
.b385                              lbb_asc
>b385  53 43 28 d8                 	.byte	"SC(",TK_ASC	; ASC(
.b389                              lbb_atn
>b389  54 4e 28 d1                 	.byte	"TN(",TK_ATN	; ATN(
>b38d  00                          	.byte	$00
.b38e                              tab_ascb
.b38e                              lbb_bins
>b38e  49 4e 24 28 dd              	.byte	"IN$(",TK_BINS	; BIN$(
.b393                              lbb_bitclr
>b393  49 54 43 4c 52 a8           	.byte	"ITCLR",TK_BITCLR	; BITCLR
.b399                              lbb_bitset
>b399  49 54 53 45 54 a7           	.byte	"ITSET",TK_BITSET	; BITSET
.b39f                              lbb_bittst
>b39f  49 54 54 53 54 28 de        	.byte	"ITTST(",TK_BITTST
>b3a6  00                          	.byte	$00
.b3a7                              tab_ascc
.b3a7                              lbb_call
>b3a7  41 4c 4c 9c                 	.byte	"ALL",TK_CALL	; CALL
.b3ab                              lbb_chrs
>b3ab  48 52 24 28 db              	.byte	"HR$(",TK_CHRS	; CHR$(
.b3b0                              lbb_clear
>b3b0  4c 45 41 52 a2              	.byte	"LEAR",TK_CLEAR	; CLEAR
.b3b5                              lbb_cont
>b3b5  4f 4e 54 a0                 	.byte	"ONT",TK_CONT	; CONT
.b3b9                              lbb_cos
>b3b9  4f 53 28 ce                 	.byte	"OS(",TK_COS	; COS(
>b3bd  00                          	.byte	$00
.b3be                              tab_ascd
.b3be                              lbb_data
>b3be  41 54 41 83                 	.byte	"ATA",TK_DATA	; DATA
.b3c2                              lbb_dec
>b3c2  45 43 88                    	.byte	"EC",TK_DEC		; DEC
.b3c5                              lbb_deek
>b3c5  45 45 4b 28 d3              	.byte	"EEK(",TK_DEEK	; DEEK(
.b3ca                              lbb_def
>b3ca  45 46 99                    	.byte	"EF",TK_DEF		; DEF
.b3cd                              lbb_dim
>b3cd  49 4d 85                    	.byte	"IM",TK_DIM		; DIM
.b3d0                              lbb_doke
>b3d0  4f 4b 45 9b                 	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
.b3d4                              lbb_do
>b3d4  4f 9d                       	.byte	"O",TK_DO		; DO
>b3d6  00                          	.byte	$00
.b3d7                              tab_asce
.b3d7                              lbb_else
>b3d7  4c 53 45 ad                 	.byte	"LSE",TK_ELSE	; ELSE
.b3db                              lbb_end
>b3db  4e 44 80                    	.byte	"ND",TK_END		; END
.b3de                              lbb_eor
>b3de  4f 52 bd                    	.byte	"OR",TK_EOR		; EOR
.b3e1                              lbb_exp
>b3e1  58 50 28 cd                 	.byte	"XP(",TK_EXP	; EXP(
>b3e5  00                          	.byte	$00
.b3e6                              tab_ascf
.b3e6                              lbb_fn
>b3e6  4e af                       	.byte	"N",TK_FN		; FN
.b3e8                              lbb_for
>b3e8  4f 52 81                    	.byte	"OR",TK_FOR		; FOR
.b3eb                              lbb_fre
>b3eb  52 45 28 c8                 	.byte	"RE(",TK_FRE	; FRE(
>b3ef  00                          	.byte	$00
.b3f0                              tab_ascg
.b3f0                              lbb_get
>b3f0  45 54 a5                    	.byte	"ET",TK_GET		; GET
.b3f3                              lbb_gosub
>b3f3  4f 53 55 42 8d              	.byte	"OSUB",TK_GOSUB	; GOSUB
.b3f8                              lbb_goto
>b3f8  4f 54 4f 89                 	.byte	"OTO",TK_GOTO	; GOTO
>b3fc  00                          	.byte	$00
.b3fd                              tab_asch
.b3fd                              lbb_hexs
>b3fd  45 58 24 28 dc              	.byte	"EX$(",TK_HEXS	; HEX$(
>b402  00                          	.byte	$00
.b403                              tab_asci
.b403                              lbb_if
>b403  46 8b                       	.byte	"F",TK_IF		; IF
.b405                              lbb_inc
>b405  4e 43 95                    	.byte	"NC",TK_INC		; INC
.b408                              lbb_input
>b408  4e 50 55 54 84              	.byte	"NPUT",TK_INPUT	; INPUT
.b40d                              lbb_int
>b40d  4e 54 28 c5                 	.byte	"NT(",TK_INT	; INT(
.b411                              lbb_irq
>b411  52 51 a9                    	.byte	"RQ",TK_IRQ		; IRQ
>b414  00                          	.byte	$00
.b415                              tab_ascl
.b415                              lbb_lcases
>b415  43 41 53 45 24 28 da        	.byte	"CASE$(",TK_LCASES
.b41c                              lbb_lefts
>b41c  45 46 54 24 28 e4           	.byte	"EFT$(",TK_LEFTS	; LEFT$(
.b422                              lbb_len
>b422  45 4e 28 d5                 	.byte	"EN(",TK_LEN	; LEN(
.b426                              lbb_let
>b426  45 54 87                    	.byte	"ET",TK_LET		; LET
.b429                              lbb_list
>b429  49 53 54 a1                 	.byte	"IST",TK_LIST	; LIST
.b42d                              lbb_load
>b42d  4f 41 44 97                 	.byte	"OAD",TK_LOAD	; LOAD
.b431                              lbb_log
>b431  4f 47 28 cc                 	.byte	"OG(",TK_LOG	; LOG(
.b435                              lbb_loop
>b435  4f 4f 50 9e                 	.byte	"OOP",TK_LOOP	; LOOP
>b439  00                          	.byte	$00
.b43a                              tab_ascm
.b43a                              lbb_max
>b43a  41 58 28 df                 	.byte	"AX(",TK_MAX	; MAX(
.b43e                              lbb_mids
>b43e  49 44 24 28 e6              	.byte	"ID$(",TK_MIDS	; MID$(
.b443                              lbb_min
>b443  49 4e 28 e0                 	.byte	"IN(",TK_MIN	; MIN(
>b447  00                          	.byte	$00
.b448                              tab_ascn
.b448                              lbb_new
>b448  45 57 a3                    	.byte	"EW",TK_NEW		; NEW
.b44b                              lbb_next
>b44b  45 58 54 82                 	.byte	"EXT",TK_NEXT	; NEXT
.b44f                              lbb_nmi
>b44f  4d 49 aa                    	.byte	"MI",TK_NMI		; NMI
.b452                              lbb_not
>b452  4f 54 b2                    	.byte	"OT",TK_NOT		; NOT
.b455                              lbb_null
>b455  55 4c 4c 94                 	.byte	"ULL",TK_NULL	; NULL
>b459  00                          	.byte	$00
.b45a                              tab_asco
.b45a                              lbb_off
>b45a  46 46 b6                    	.byte	"FF",TK_OFF		; OFF
.b45d                              lbb_on
>b45d  4e 93                       	.byte	"N",TK_ON		; ON
.b45f                              lbb_or
>b45f  52 be                       	.byte	"R",TK_OR		; OR
>b461  00                          	.byte	$00
.b462                              tab_ascp
.b462                              lbb_peek
>b462  45 45 4b 28 d2              	.byte	"EEK(",TK_PEEK	; PEEK(
.b467                              lbb_pi
>b467  49 e1                       	.byte	"I",TK_PI		; PI
.b469                              lbb_poke
>b469  4f 4b 45 9a                 	.byte	"OKE",TK_POKE	; POKE
.b46d                              lbb_pos
>b46d  4f 53 28 c9                 	.byte	"OS(",TK_POS	; POS(
.b471                              lbb_print
>b471  52 49 4e 54 9f              	.byte	"RINT",TK_PRINT	; PRINT
>b476  00                          	.byte	$00
.b477                              tab_ascr
.b477                              lbb_read
>b477  45 41 44 86                 	.byte	"EAD",TK_READ	; READ
.b47b                              lbb_rem
>b47b  45 4d 91                    	.byte	"EM",TK_REM		; REM
.b47e                              lbb_restore
>b47e  45 53 54 4f 52 45 8c        	.byte	"ESTORE",TK_RESTORE
.b485                              lbb_retirq
>b485  45 54 49 52 51 8e           	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
.b48b                              lbb_retnmi
>b48b  45 54 4e 4d 49 8f           	.byte	"ETNMI",TK_RETNMI	; RETNMI
.b491                              lbb_return
>b491  45 54 55 52 4e 90           	.byte	"ETURN",TK_RETURN	; RETURN
.b497                              lbb_rights
>b497  49 47 48 54 24 28 e5        	.byte	"IGHT$(",TK_RIGHTS
.b49e                              lbb_rnd
>b49e  4e 44 28 cb                 	.byte	"ND(",TK_RND	; RND(
.b4a2                              lbb_run
>b4a2  55 4e 8a                    	.byte	"UN",TK_RUN		; RUN
>b4a5  00                          	.byte	$00
.b4a6                              tab_ascs
.b4a6                              lbb_sadd
>b4a6  41 44 44 28 d4              	.byte	"ADD(",TK_SADD	; SADD(
.b4ab                              lbb_save
>b4ab  41 56 45 98                 	.byte	"AVE",TK_SAVE	; SAVE
.b4af                              lbb_sgn
>b4af  47 4e 28 c4                 	.byte	"GN(",TK_SGN	; SGN(
.b4b3                              lbb_sin
>b4b3  49 4e 28 cf                 	.byte	"IN(",TK_SIN	; SIN(
.b4b7                              lbb_spc
>b4b7  50 43 28 b0                 	.byte	"PC(",TK_SPC	; SPC(
.b4bb                              lbb_sqr
>b4bb  51 52 28 ca                 	.byte	"QR(",TK_SQR	; SQR(
.b4bf                              lbb_step
>b4bf  54 45 50 b3                 	.byte	"TEP",TK_STEP	; STEP
.b4c3                              lbb_stop
>b4c3  54 4f 50 92                 	.byte	"TOP",TK_STOP	; STOP
.b4c7                              lbb_strs
>b4c7  54 52 24 28 d6              	.byte	"TR$(",TK_STRS	; STR$(
.b4cc                              lbb_swap
>b4cc  57 41 50 a6                 	.byte	"WAP",TK_SWAP	; SWAP
.b4d0                              lbb_sys
>b4d0  59 53 ab                    	.byte   "YS", TK_SYS    ; SYS    *** added for SBC-2
>b4d3  00                          	.byte	$00
.b4d4                              tab_asct
.b4d4                              lbb_tab
>b4d4  41 42 28 ac                 	.byte	"AB(",TK_TAB	; TAB(
.b4d8                              lbb_tan
>b4d8  41 4e 28 d0                 	.byte	"AN(",TK_TAN	; TAN(
.b4dc                              lbb_then
>b4dc  48 45 4e b1                 	.byte	"HEN",TK_THEN	; THEN
.b4e0                              lbb_to
>b4e0  4f ae                       	.byte	"O",TK_TO		; TO
.b4e2                              lbb_twopi
>b4e2  57 4f 50 49 e2              	.byte	"WOPI",TK_TWOPI	; TWOPI
>b4e7  00                          	.byte	$00
.b4e8                              tab_ascu
.b4e8                              lbb_ucases
>b4e8  43 41 53 45 24 28 d9        	.byte	"CASE$(",TK_UCASES
.b4ef                              lbb_until
>b4ef  4e 54 49 4c b4              	.byte	"NTIL",TK_UNTIL	; UNTIL
.b4f4                              lbb_usr
>b4f4  53 52 28 c7                 	.byte	"SR(",TK_USR	; USR(
>b4f8  00                          	.byte	$00
.b4f9                              tab_ascv
.b4f9                              lbb_val
>b4f9  41 4c 28 d7                 	.byte	"AL(",TK_VAL	; VAL(
.b4fd                              lbb_vptr
>b4fd  41 52 50 54 52 28 e3        	.byte	"ARPTR(",TK_VPTR	; VARPTR(
>b504  00                          	.byte	$00
.b505                              tab_ascw
.b505                              lbb_wait
>b505  41 49 54 96                 	.byte	"AIT",TK_WAIT	; WAIT
.b509                              lbb_while
>b509  48 49 4c 45 b5              	.byte	"HILE",TK_WHILE	; WHILE
.b50e                              lbb_width
>b50e  49 44 54 48 a4              	.byte	"IDTH",TK_WIDTH	; WIDTH
>b513  00                          	.byte	$00
.b514                              tab_powr
>b514  bb 00                       	.byte	TK_POWER,$00	; ^
.b516                              lab_keyt
>b516  03 45                       	.byte	3,"E"
>b518  db b3                       	.word	LBB_END		; END
>b51a  03 46                       	.byte	3,"F"
>b51c  e8 b3                       	.word	LBB_FOR		; FOR
>b51e  04 4e                       	.byte	4,"N"
>b520  4b b4                       	.word	LBB_NEXT		; NEXT
>b522  04 44                       	.byte	4,"D"
>b524  be b3                       	.word	LBB_DATA		; DATA
>b526  05 49                       	.byte	5,"I"
>b528  08 b4                       	.word	LBB_INPUT		; INPUT
>b52a  03 44                       	.byte	3,"D"
>b52c  cd b3                       	.word	LBB_DIM		; DIM
>b52e  04 52                       	.byte	4,"R"
>b530  77 b4                       	.word	LBB_READ		; READ
>b532  03 4c                       	.byte	3,"L"
>b534  26 b4                       	.word	LBB_LET		; LET
>b536  03 44                       	.byte	3,"D"
>b538  c2 b3                       	.word	LBB_DEC		; DEC
>b53a  04 47                       	.byte	4,"G"
>b53c  f8 b3                       	.word	LBB_GOTO		; GOTO
>b53e  03 52                       	.byte	3,"R"
>b540  a2 b4                       	.word	LBB_RUN		; RUN
>b542  02 49                       	.byte	2,"I"
>b544  03 b4                       	.word	LBB_IF		; IF
>b546  07 52                       	.byte	7,"R"
>b548  7e b4                       	.word	LBB_RESTORE		; RESTORE
>b54a  05 47                       	.byte	5,"G"
>b54c  f3 b3                       	.word	LBB_GOSUB		; GOSUB
>b54e  06 52                       	.byte	6,"R"
>b550  85 b4                       	.word	LBB_RETIRQ		; RETIRQ
>b552  06 52                       	.byte	6,"R"
>b554  8b b4                       	.word	LBB_RETNMI		; RETNMI
>b556  06 52                       	.byte	6,"R"
>b558  91 b4                       	.word	LBB_RETURN		; RETURN
>b55a  03 52                       	.byte	3,"R"
>b55c  7b b4                       	.word	LBB_REM		; REM
>b55e  04 53                       	.byte	4,"S"
>b560  c3 b4                       	.word	LBB_STOP		; STOP
>b562  02 4f                       	.byte	2,"O"
>b564  5d b4                       	.word	LBB_ON		; ON
>b566  04 4e                       	.byte	4,"N"
>b568  55 b4                       	.word	LBB_NULL		; NULL
>b56a  03 49                       	.byte	3,"I"
>b56c  05 b4                       	.word	LBB_INC		; INC
>b56e  04 57                       	.byte	4,"W"
>b570  05 b5                       	.word	LBB_WAIT		; WAIT
>b572  04 4c                       	.byte	4,"L"
>b574  2d b4                       	.word	LBB_LOAD		; LOAD
>b576  04 53                       	.byte	4,"S"
>b578  ab b4                       	.word	LBB_SAVE		; SAVE
>b57a  03 44                       	.byte	3,"D"
>b57c  ca b3                       	.word	LBB_DEF		; DEF
>b57e  04 50                       	.byte	4,"P"
>b580  69 b4                       	.word	LBB_POKE		; POKE
>b582  04 44                       	.byte	4,"D"
>b584  d0 b3                       	.word	LBB_DOKE		; DOKE
>b586  04 43                       	.byte	4,"C"
>b588  a7 b3                       	.word	LBB_CALL		; CALL
>b58a  02 44                       	.byte	2,"D"
>b58c  d4 b3                       	.word	LBB_DO		; DO
>b58e  04 4c                       	.byte	4,"L"
>b590  35 b4                       	.word	LBB_LOOP		; LOOP
>b592  05 50                       	.byte	5,"P"
>b594  71 b4                       	.word	LBB_PRINT		; PRINT
>b596  04 43                       	.byte	4,"C"
>b598  b5 b3                       	.word	LBB_CONT		; CONT
>b59a  04 4c                       	.byte	4,"L"
>b59c  29 b4                       	.word	LBB_LIST		; LIST
>b59e  05 43                       	.byte	5,"C"
>b5a0  b0 b3                       	.word	LBB_CLEAR		; CLEAR
>b5a2  03 4e                       	.byte	3,"N"
>b5a4  48 b4                       	.word	LBB_NEW		; NEW
>b5a6  05 57                       	.byte	5,"W"
>b5a8  0e b5                       	.word	LBB_WIDTH		; WIDTH
>b5aa  03 47                       	.byte	3,"G"
>b5ac  f0 b3                       	.word	LBB_GET		; GET
>b5ae  04 53                       	.byte	4,"S"
>b5b0  cc b4                       	.word	LBB_SWAP		; SWAP
>b5b2  06 42                       	.byte	6,"B"
>b5b4  99 b3                       	.word	LBB_BITSET		; BITSET
>b5b6  06 42                       	.byte	6,"B"
>b5b8  93 b3                       	.word	LBB_BITCLR		; BITCLR
>b5ba  03 49                       	.byte	3,"I"
>b5bc  11 b4                       	.word	LBB_IRQ		; IRQ
>b5be  03 4e                       	.byte	3,"N"
>b5c0  4f b4                       	.word	LBB_NMI		; NMI
>b5c2  03 53                       	.byte	3,"S"			;
>b5c4  d0 b4                       	.word	LBB_SYS			; SYS   *** Added for SBC-2
>b5c6  04 54                       	.byte	4,"T"
>b5c8  d4 b4                       	.word	LBB_TAB		; TAB
>b5ca  04 45                       	.byte	4,"E"
>b5cc  d7 b3                       	.word	LBB_ELSE		; ELSE
>b5ce  02 54                       	.byte	2,"T"
>b5d0  e0 b4                       	.word	LBB_TO		; TO
>b5d2  02 46                       	.byte	2,"F"
>b5d4  e6 b3                       	.word	LBB_FN		; FN
>b5d6  04 53                       	.byte	4,"S"
>b5d8  b7 b4                       	.word	LBB_SPC		; SPC
>b5da  04 54                       	.byte	4,"T"
>b5dc  dc b4                       	.word	LBB_THEN		; THEN
>b5de  03 4e                       	.byte	3,"N"
>b5e0  52 b4                       	.word	LBB_NOT		; NOT
>b5e2  04 53                       	.byte	4,"S"
>b5e4  bf b4                       	.word	LBB_STEP		; STEP
>b5e6  05 55                       	.byte	5,"U"
>b5e8  ef b4                       	.word	LBB_UNTIL		; UNTIL
>b5ea  05 57                       	.byte	5,"W"
>b5ec  09 b5                       	.word	LBB_WHILE		; WHILE
>b5ee  03 4f                       	.byte	3,"O"
>b5f0  5a b4                       	.word	LBB_OFF		; OFF
>b5f2  01 2b                       	.byte	1,"+"
>b5f4  00 00                       	.word	$0000			; +
>b5f6  01 2d                       	.byte	1,"-"
>b5f8  00 00                       	.word	$0000			; -
>b5fa  01 2a                       	.byte	1,"*"
>b5fc  00 00                       	.word	$0000			; *
>b5fe  01 2f                       	.byte	1,"/"
>b600  00 00                       	.word	$0000			; /
>b602  01 5e                       	.byte	1,"^"
>b604  00 00                       	.word	$0000			; ^
>b606  03 41                       	.byte	3,"A"
>b608  82 b3                       	.word	LBB_AND		; AND
>b60a  03 45                       	.byte	3,"E"
>b60c  de b3                       	.word	LBB_EOR		; EOR
>b60e  02 4f                       	.byte	2,"O"
>b610  5f b4                       	.word	LBB_OR		; OR
>b612  02 3e                       	.byte	2,">"
>b614  78 b3                       	.word	LBB_RSHIFT		; >>
>b616  02 3c                       	.byte	2,"<"
>b618  72 b3                       	.word	LBB_LSHIFT		; <<
>b61a  01 3e                       	.byte	1,">"
>b61c  00 00                       	.word	$0000			; >
>b61e  01 3d                       	.byte	1,"="
>b620  00 00                       	.word	$0000			; =
>b622  01 3c                       	.byte	1,"<"
>b624  00 00                       	.word	$0000			; <
>b626  04 53                       	.byte	4,"S"			;
>b628  af b4                       	.word	LBB_SGN		; SGN
>b62a  04 49                       	.byte	4,"I"			;
>b62c  0d b4                       	.word	LBB_INT		; INT
>b62e  04 41                       	.byte	4,"A"			;
>b630  7e b3                       	.word	LBB_ABS		; ABS
>b632  04 55                       	.byte	4,"U"			;
>b634  f4 b4                       	.word	LBB_USR		; USR
>b636  04 46                       	.byte	4,"F"			;
>b638  eb b3                       	.word	LBB_FRE		; FRE
>b63a  04 50                       	.byte	4,"P"			;
>b63c  6d b4                       	.word	LBB_POS		; POS
>b63e  04 53                       	.byte	4,"S"			;
>b640  bb b4                       	.word	LBB_SQR		; SQR
>b642  04 52                       	.byte	4,"R"			;
>b644  9e b4                       	.word	LBB_RND		; RND
>b646  04 4c                       	.byte	4,"L"			;
>b648  31 b4                       	.word	LBB_LOG		; LOG
>b64a  04 45                       	.byte	4,"E"			;
>b64c  e1 b3                       	.word	LBB_EXP		; EXP
>b64e  04 43                       	.byte	4,"C"			;
>b650  b9 b3                       	.word	LBB_COS		; COS
>b652  04 53                       	.byte	4,"S"			;
>b654  b3 b4                       	.word	LBB_SIN		; SIN
>b656  04 54                       	.byte	4,"T"			;
>b658  d8 b4                       	.word	LBB_TAN		; TAN
>b65a  04 41                       	.byte	4,"A"			;
>b65c  89 b3                       	.word	LBB_ATN		; ATN
>b65e  05 50                       	.byte	5,"P"			;
>b660  62 b4                       	.word	LBB_PEEK		; PEEK
>b662  05 44                       	.byte	5,"D"			;
>b664  c5 b3                       	.word	LBB_DEEK		; DEEK
>b666  05 53                       	.byte	5,"S"			;
>b668  a6 b4                       	.word	LBB_SADD		; SADD
>b66a  04 4c                       	.byte	4,"L"			;
>b66c  22 b4                       	.word	LBB_LEN		; LEN
>b66e  05 53                       	.byte	5,"S"			;
>b670  c7 b4                       	.word	LBB_STRS		; STR$
>b672  04 56                       	.byte	4,"V"			;
>b674  f9 b4                       	.word	LBB_VAL		; VAL
>b676  04 41                       	.byte	4,"A"			;
>b678  85 b3                       	.word	LBB_ASC		; ASC
>b67a  07 55                       	.byte	7,"U"			;
>b67c  e8 b4                       	.word	LBB_UCASES		; UCASE$
>b67e  07 4c                       	.byte	7,"L"			;
>b680  15 b4                       	.word	LBB_LCASES		; LCASE$
>b682  05 43                       	.byte	5,"C"			;
>b684  ab b3                       	.word	LBB_CHRS		; CHR$
>b686  05 48                       	.byte	5,"H"			;
>b688  fd b3                       	.word	LBB_HEXS		; HEX$
>b68a  05 42                       	.byte	5,"B"			;
>b68c  8e b3                       	.word	LBB_BINS		; BIN$
>b68e  07 42                       	.byte	7,"B"			;
>b690  9f b3                       	.word	LBB_BITTST		; BITTST
>b692  04 4d                       	.byte	4,"M"			;
>b694  3a b4                       	.word	LBB_MAX		; MAX
>b696  04 4d                       	.byte	4,"M"			;
>b698  43 b4                       	.word	LBB_MIN		; MIN
>b69a  02 50                       	.byte	2,"P"			;
>b69c  67 b4                       	.word	LBB_PI		; PI
>b69e  05 54                       	.byte	5,"T"			;
>b6a0  e2 b4                       	.word	LBB_TWOPI		; TWOPI
>b6a2  07 56                       	.byte	7,"V"			;
>b6a4  fd b4                       	.word	LBB_VPTR		; VARPTR
>b6a6  06 4c                       	.byte	6,"L"			;
>b6a8  1c b4                       	.word	LBB_LEFTS		; LEFT$
>b6aa  07 52                       	.byte	7,"R"			;
>b6ac  97 b4                       	.word	LBB_RIGHTS		; RIGHT$
>b6ae  05 4d                       	.byte	5,"M"			;
>b6b0  3e b4                       	.word	LBB_MIDS		; MID$
.b6b2                              lab_baer
>b6b2  d6 b6                       	.word	ERR_NF		;$00 NEXT without FOR
>b6b4  e7 b6                       	.word	ERR_SN		;$02 syntax
>b6b6  ee b6                       	.word	ERR_RG		;$04 RETURN without GOSUB
>b6b8  03 b7                       	.word	ERR_OD		;$06 out of data
>b6ba  0f b7                       	.word	ERR_FC		;$08 function call
>b6bc  1d b7                       	.word	ERR_OV		;$0A overflow
>b6be  26 b7                       	.word	ERR_OM		;$0C out of memory
>b6c0  34 b7                       	.word	ERR_US		;$0E undefined statement
>b6c2  48 b7                       	.word	ERR_BS		;$10 array bounds
>b6c4  55 b7                       	.word	ERR_DD		;$12 double dimension array
>b6c6  66 b7                       	.word	ERR_D0		;$14 divide by 0
>b6c8  75 b7                       	.word	ERR_ID		;$16 illegal direct
>b6ca  84 b7                       	.word	ERR_TM		;$18 type mismatch
>b6cc  92 b7                       	.word	ERR_LS		;$1A long string
>b6ce  a2 b7                       	.word	ERR_ST		;$1C string too complex
>b6d0  b5 b7                       	.word	ERR_CN		;$1E continue error
>b6d2  c4 b7                       	.word	ERR_UF		;$20 undefined function
>b6d4  d7 b7                       	.word ERR_LD		;$22 LOOP without DO
>b6d6  4e 45 58 54 20 77 69 74 68 6f 75 74 20 46 4f 52 00  ERR_NF	.byte	"NEXT without FOR",$00
>b6e7  53 79 6e 74 61 78 00        ERR_SN	.byte	"Syntax",$00
>b6ee  52 45 54 55 52 4e 20 77 69 74 68 6f 75 74 20 47 4f 53 55 42 00  ERR_RG	.byte	"RETURN without GOSUB",$00
>b703  4f 75 74 20 6f 66 20 44 41 54 41 00  ERR_OD	.byte	"Out of DATA",$00
>b70f  46 75 6e 63 74 69 6f 6e 20 63 61 6c 6c 00  ERR_FC	.byte	"Function call",$00
>b71d  4f 76 65 72 66 6c 6f 77 00  ERR_OV	.byte	"Overflow",$00
>b726  4f 75 74 20 6f 66 20 6d 65 6d 6f 72 79 00  ERR_OM	.byte	"Out of memory",$00
>b734  55 6e 64 65 66 69 6e 65 64 20 73 74 61 74 65 6d 65 6e 74 00  ERR_US	.byte	"Undefined statement",$00
>b748  41 72 72 61 79 20 62 6f 75 6e 64 73 00  ERR_BS	.byte	"Array bounds",$00
>b755  44 6f 75 62 6c 65 20 64 69 6d 65 6e 73 69 6f 6e 00  ERR_DD	.byte	"Double dimension",$00
>b766  44 69 76 69 64 65 20 62 79 20 7a 65 72 6f 00  ERR_D0	.byte	"Divide by zero",$00
>b775  49 6c 6c 65 67 61 6c 20 64 69 72 65 63 74 00  ERR_ID	.byte	"Illegal direct",$00
>b784  54 79 70 65 20 6d 69 73 6d 61 74 63 68 00  ERR_TM	.byte	"Type mismatch",$00
>b792  53 74 72 69 6e 67 20 74 6f 6f 20 6c 6f 6e 67 00  ERR_LS	.byte	"String too long",$00
>b7a2  53 74 72 69 6e 67 20 74 6f 6f 20 63 6f 6d 70 6c 65 78 00  ERR_ST	.byte	"String too complex",$00
>b7b5  43 61 6e 27 74 20 63 6f 6e 74 69 6e 75 65 00  ERR_CN	.byte	"Can't continue",$00
>b7c4  55 6e 64 65 66 69 6e 65 64 20 66 75 6e 63 74 69 6f 6e 00  ERR_UF	.byte	"Undefined function",$00
>b7d7  4c 4f 4f 50 20 77 69 74 68 6f 75 74 20 44 4f 00  ERR_LD	.byte	"LOOP without DO",$00
>b7e7  0d 0a 42 72 65 61 6b 00     LAB_BMSG	.byte	$0D,$0A,"Break",$00
>b7ef  20 45 72 72 6f 72 00        LAB_EMSG	.byte	" Error",$00
>b7f6  20 69 6e 20 6c 69 6e 65 20 00  LAB_LMSG	.byte	" in line ",$00
>b800  0d 0a 52 65 61 64 79 0d 0a 00  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
>b80a  20 45 78 74 72 61 20 69 67 6e 6f 72 65 64 0d 0a 00  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
>b81b  20 52 65 64 6f 20 66 72 6f 6d 20 73 74 61 72 74 0d 0a 00  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
.b82e                              aa_end_basic
.b82e                              psave

.b82e  20 6d b8   jsr $b86d        		jsr	pscan
.b831  a0 00      ldy #$00         		ldy	#$00
.b833  a5 11      lda $11          		lda	itempl
.b835  91 11      sta ($11),y      		sta	(itempl),y
.b837  c8         iny              		iny
.b838  a5 12      lda $12          		lda	itemph
.b83a  91 11      sta ($11),y      		sta	(itempl),y
.b83c  a6 79      ldx $79          		ldx	smeml
.b83e  a5 7a      lda $7a          		lda	smemh
.b840  20 67 e1   jsr $e167        		jsr	print2byte
.b843  20 5a e1   jsr $e15a        		jsr	print_cr
.b846  38         sec              		sec
.b847  a5 11      lda $11          		lda	itempl
.b849  e5 79      sbc $79          		sbc	smeml
.b84b  aa         tax              		tax
.b84c  a5 12      lda $12          		lda	itemph
.b84e  e5 7a      sbc $7a          		sbc	smemh
.b850  20 67 e1   jsr $e167        		jsr	print2byte
.b853  20 5a e1   jsr $e15a        		jsr	print_cr
.b856  60         rts              		rts
.b857                              pload
.b857  20 6d b8   jsr $b86d        		jsr	pscan
.b85a  a5 11      lda $11          		lda	itempl
.b85c  85 7b      sta $7b          		sta	svarl
.b85e  85 7d      sta $7d          		sta	sarryl
.b860  85 7f      sta $7f          		sta	earryl
.b862  a5 12      lda $12          		lda	itemph
.b864  85 7c      sta $7c          		sta	svarh
.b866  85 7e      sta $7e          		sta	sarryh
.b868  85 80      sta $80          		sta	earryh
.b86a  4c 14 92   jmp $9214        		JMP   LAB_1319		
.b86d                              pscan
.b86d  a5 79      lda $79          		lda	smeml
.b86f  85 11      sta $11                	sta	itempl
.b871  a5 7a      lda $7a                	lda	smemh
.b873  85 12      sta $12                	sta	itemph
.b875  a0 00      ldy #$00         pscan1	ldy   #$00
.b877  b1 11      lda ($11),y      		lda   (itempl),y
.b879  d0 13      bne $b88e        		bne   pscan2
.b87b  c8         iny              		iny   
.b87c  b1 11      lda ($11),y      		lda   (itempl),y
.b87e  d0 0e      bne $b88e        		bne   pscan2
.b880  18         clc              		clc
.b881  a9 02      lda #$02         		lda   #$02
.b883  65 11      adc $11          		adc   itempl
.b885  85 11      sta $11          		sta	itempl
.b887  a9 00      lda #$00         		lda	#$00
.b889  65 12      adc $12          		adc	itemph
.b88b  85 12      sta $12          		sta	itemph
.b88d  60         rts              		rts
.b88e  a0 00      ldy #$00         pscan2	ldy   #$00
.b890  b1 11      lda ($11),y      		lda	(itempl),y
.b892  aa         tax              		tax
.b893  c8         iny              		iny
.b894  b1 11      lda ($11),y      		lda	(itempl),y
.b896  85 12      sta $12          		sta	itemph
.b898  86 11      stx $11          		stx	itempl
.b89a  80 d9      bra $b875        		bra	pscan1

.e000  a2 00      ldx #$00         Via1_init      ldx   #$00              ; get data from table
.e002  bd 0e e0   lda $e00e,x      Via1init1      lda   Via1idata,x       ; init all 16 regs from 00 to 0F
.e005  9d 30 c0   sta $c030,x                     sta   Via1Base,x        ; 
.e008  e8         inx                             inx                     ; 
.e009  e0 0f      cpx #$0f                        cpx   #$0f              ; 
.e00b  d0 f5      bne $e002                       bne   Via1init1         ;       
.e00d  60         rts                             rts                     ; done

>e00e  00                          Via1idata      .byte $00               ; prb  '00000000'
>e00f  00                                         .byte $00               ; pra  "00000000'
>e010  00                                         .byte $00               ; ddrb 'iiiiiiii'
>e011  00                                         .byte $00               ; ddra 'iiiiiiii'
>e012  00                                         .byte $00               ; tacl  
>e013  00                                         .byte $00               ; tach  
>e014  00                                         .byte $00               ; tall  
>e015  00                                         .byte $00               ; talh  
>e016  00                                         .byte $00               ; t2cl
>e017  00                                         .byte $00               ; t2ch
>e018  00                                         .byte $00               ; sr
>e019  00                                         .byte $00               ; acr
>e01a  00                                         .byte $00               ; pcr
>e01b  7f                                         .byte $7f               ; ifr
>e01c  7f                                         .byte $7f               ; ier
.e01d                              via2_init

.e01d  a9 30      lda #$30                        lda      #$30
.e01f  8d f0 c0   sta $c0f0                       sta      $c0f0
.e022  a9 31      lda #$31                        lda      #$31
.e024  8d f1 c0   sta $c0f1                       sta      $c0f1
.e027  a9 32      lda #$32                        lda      #$32
.e029  8d f2 c0   sta $c0f2                       sta      $c0f2
.e02c  a9 33      lda #$33                        lda      #$33
.e02e  8d f3 c0   sta $c0f3                       sta      $c0f3
.e031  a2 00      ldx #$00                        ldx   #$00              ; get data from table
.e033  bd 3f e0   lda $e03f,x      Via2init1      lda   Via2idata,x       ; init all 16 regs from 00 to 0F
.e036  9d 10 c0   sta $c010,x                     sta   Via2Base,x        ; 
.e039  e8         inx                             inx                     ; 
.e03a  e0 07      cpx #$07                        cpx   #$07              ; 
.e03c  d0 f5      bne $e033                       bne   Via2init1         ;       
.e03e  60         rts                             rts                     ; done

>e03f  00                          Via2idata      .byte $00               ; prb  '00000000'
>e040  00                                         .byte $00               ; pra  "00000000'
>e041  00                                         .byte $00               ; ddrb 'iiiiiiii'
>e042  00                                         .byte $00               ; ddra 'iiiiiiii'
>e043  00                                         .byte $00               ; tacl  
>e044  00                                         .byte $00               ; tach  
>e045  00                                         .byte $00               ; tall  
>e046  00                                         .byte $00               ; talh  
>e047  00                                         .byte $00               ; t2cl
>e048  00                                         .byte $00               ; t2ch
>e049  00                                         .byte $00               ; sr
>e04a  00                                         .byte $00               ; acr
>e04b  00                                         .byte $00               ; pcr
>e04c  7f                                         .byte $7f               ; ifr
>e04d  7f                                         .byte $7f               ; ier

.e04e  a2 bf      ldx #$bf         ACIA0_init     LDX   #<ACIA0_Input      ; set up RAM vectors for
.e050  a9 e0      lda #$e0                        LDA   #>ACIA0_Input      ; Input, Output, and Scan
.e052  a8         tay                             TAY                     	; Routines
.e053  49 a5      eor #$a5                        EOR   #$A5              	;
.e055  8d ed 03   sta $03ed                       sta   ChrInVect+2       	;
.e058  8c ec 03   sty $03ec                       sty   ChrInVect+1       	;
.e05b  8e eb 03   stx $03eb                       stx   ChrInVect         	;
.e05e  a2 b1      ldx #$b1                        LDX   #<ACIA0_Scan  	;
.e060  a9 e0      lda #$e0                        LDA   #>ACIA0_Scan       ;
.e062  a8         tay                             TAY                     	;
.e063  49 a5      eor #$a5                        EOR   #$A5              	;
.e065  8d f0 03   sta $03f0                       sta   ScanInVect+2      	;
.e068  8c ef 03   sty $03ef                       sty   ScanInVect+1      	;
.e06b  8e ee 03   stx $03ee                       stx   ScanInVect        	;
.e06e  a2 c5      ldx #$c5                        LDX   #<ACIA0_Output     ;
.e070  a9 e0      lda #$e0                        LDA   #>ACIA0_Output     ;
.e072  a8         tay                             TAY                     	;
.e073  49 a5      eor #$a5                        EOR   #$A5              	;
.e075  8d f3 03   sta $03f3                       sta   ChrOutVect+2      	;
.e078  8c f2 03   sty $03f2                       sty   ChrOutVect+1      	;
.e07b  8e f1 03   stx $03f1                       stx   ChrOutVect        	;
.e07e  a9 b1      lda #$b1                        lda   #<ACIA0_scan      	; setup BASIC vectors
.e080  8d 05 02   sta $0205                       sta   VEC_IN
.e083  a9 e0      lda #$e0         	       lda   #>ACIA0_scan	; BASIC's chr input
.e085  8d 06 02   sta $0206                       sta   VEC_IN+1
.e088  a9 c5      lda #$c5                        lda   #<ACIA0_Output	
.e08a  8d 07 02   sta $0207                       sta   VEC_OUT
.e08d  a9 e0      lda #$e0         	       lda   #>ACIA0_Output	; BASIC's chr output 
.e08f  8d 08 02   sta $0208                       sta   VEC_OUT+1
.e092  a9 2e      lda #$2e         	       lda   #<Psave
.e094  8d 0b 02   sta $020b                       sta   VEC_SV
.e097  a9 b8      lda #$b8         	       lda   #>Psave		; SAVE cmd
.e099  8d 0c 02   sta $020c                       sta   VEC_SV+1
.e09c  a9 57      lda #$57         	       lda   #<pload
.e09e  8d 09 02   sta $0209                       sta   VEC_LD
.e0a1  a9 b8      lda #$b8         	       lda   #>pload		; LOAD cmd
.e0a3  8d 0a 02   sta $020a                       sta   VEC_LD+1
.e0a6  a9 03      lda #$03         ACIA0portset    lda     #$03                ; reset UART
.e0a8  8d 08 c0   sta $c008                        sta     UARTS
.e0ab  a9 15      lda #$15                         lda     #$15                ; set 8N1 serial parameter
.e0ad  8d 08 c0   sta $c008                        sta     UARTS
.e0b0  60         rts                              rts
.e0b1  ad 08 c0   lda $c008        ACIA0_Scan      LDA     UARTS           ; check UART status
.e0b4  29 01      and #$01                         AND     #$01            ; can read?
.e0b6  f0 05      beq $e0bd                        BEQ     UAGRET          ; if not, return with Z flag set
.e0b8  ad 09 c0   lda $c009                        LDA     UARTD           ; read UART data
.e0bb  38         sec                              sec
.e0bc  60         rts                              rts
.e0bd  18         clc              UAGRET          clc
.e0be  60         rts                              RTS
.e0bf  20 b1 e0   jsr $e0b1        ACIA0_Input     JSR     ACIA0_Scan
.e0c2  90 fb      bcc $e0bf                        BCC     ACIA0_Input
.e0c4  60         rts                              RTS
.e0c5  48         pha              ACIA0_Output    PHA                     ; save character
.e0c6  ad 08 c0   lda $c008        UAPUTL          LDA     UARTS           ; check UART status
.e0c9  29 02      and #$02                         AND     #$02            ; can write?
.e0cb  f0 f9      beq $e0c6                        BEQ     UAPUTL          ; wait if not
.e0cd  68         pla                              PLA                     ; restore character
.e0ce  8d 09 c0   sta $c009                        STA     UARTD           ; write character
.e0d1  60         rts                              RTS
.e0d2  4c 43 e2   jmp $e243        Start_OS       jmp   MonitorBoot         ; easy access to monitor program
.e0d5  4c 5a e1   jmp $e15a        Jmp_CR	   jmp   Print_CR		
.e0d8  4c 8b e1   jmp $e18b        Jmp_1sp	   jmp   Print1SP			; jump table for usable monitor
.e0db  4c 88 e1   jmp $e188        Jmp_2sp	   jmp   Print2SP			; routines
.e0de  4c 83 e1   jmp $e183        Jmp_xsp	   jmp   PrintXSP			; This will not change in future
.e0e1  4c 74 e1   jmp $e174        Jmp_nib	   jmp   PrintDig			; releases, only be added to
.e0e4  4c 6b e1   jmp $e16b        Jmp_byte	   jmp   Print1Byte
.e0e7  4c 67 e1   jmp $e167        jmp_wrd	   jmp   Print2Byte
.e0ea  4c 09 e2   jmp $e209        jmp_bell	   jmp   Bell
.e0ed  4c 0e e2   jmp $e20e        jmp_delay	   jmp   Delay
.e0f0  4c 03 e2   jmp $e203        jmp_scan	   jmp   Scan_input
.e0f3  4c 00 e2   jmp $e200        jmp_inp        jmp   Input_chr  
.e0f6  4c 06 e2   jmp $e206        jmp_out        jmp   Output
.e0f9  4c 93 e1   jmp $e193        jmp_input	   jmp   Input
.e0fc  4c 97 e1   jmp $e197        jmp_input1     jmp   Input1

>e0ff  20 50 43 3d 20 20 41 3d 20 20 58 3d 20 20 59 3d 20 20 53 3d 20 20 50 3d 20 28 4e 56 52 42 44 49 5a 43 29 3d  RegData        .byte" PC=  A=  X=  Y=  S=  P= (NVRBDIZC)="

.e123  20 5a e1   jsr $e15a        PrintReg       Jsr   Print_CR          ; Lead with a CR
.e126  a2 ff      ldx #$ff                        ldx   #$ff              ;
.e128  a0 ff      ldy #$ff                        ldy   #$ff              ;
.e12a  c8         iny              Printreg1      iny                     ;
.e12b  b9 ff e0   lda $e0ff,y                     lda   Regdata,y         ;
.e12e  20 06 e2   jsr $e206                       jsr   Output            ;
.e131  c9 3d      cmp #$3d                        cmp   #$3D              ; "="
.e133  d0 f5      bne $e12a                       bne   Printreg1         ;
.e135  e8         inx              Printreg2      inx                     ;
.e136  e0 07      cpx #$07                        cpx   #$07              ;
.e138  f0 0c      beq $e146                       beq   Printreg3         ; done with first 6
.e13a  bd e0 03   lda $03e0,x                     lda   PCH,x             ;  
.e13d  20 6b e1   jsr $e16b                       jsr   Print1Byte        ;
.e140  e0 00      cpx #$00                        cpx   #$00              ;
.e142  d0 e6      bne $e12a                       bne   Printreg1         ;
.e144  80 ef      bra $e135                       bra   Printreg2         ;
.e146  ca         dex              Printreg3      dex                     ;
.e147  bd e0 03   lda $03e0,x                     lda   PCH,x             ; get Preg
.e14a  a2 08      ldx #$08                        ldx   #$08              ; 
.e14c  2a         rol              Printreg4      rol                     ;
.e14d  a8         tay                             tay                     ;
.e14e  a9 31      lda #$31                        lda   #$31              ;
.e150  b0 01      bcs $e153                       bcs   Printreg5         ;
.e152  3a         dec                             dec                     ;
.e153  20 06 e2   jsr $e206        Printreg5      jsr   Output            ;
.e156  98         tya                             tya                     ;
.e157  ca         dex                             dex                     ;
.e158  d0 f2      bne $e14c                       bne   Printreg4         ;
.e15a  48         pha              Print_CR       PHA                     ; Save Acc
.e15b  a9 0d      lda #$0d                        LDA   #$0D              ; "cr"
.e15d  20 06 e2   jsr $e206                       JSR   OUTPUT            ; send it
.e160  a9 0a      lda #$0a                        LDA   #$0A              ; "lf"
.e162  20 06 e2   jsr $e206                       JSR   OUTPUT            ; send it
.e165  68         pla                             PLA                     ; Restore Acc
.e166  60         rts                             RTS                     ; 
.e167  20 6b e1   jsr $e16b        Print2Byte     JSR   Print1Byte        ;  prints AAXX hex digits
.e16a  8a         txa                             TXA                     ;
.e16b  48         pha              Print1Byte     PHA                     ;  prints AA hex digits
.e16c  4a         lsr                             LSR                     ;  MOVE UPPER NIBBLE TO LOWER
.e16d  4a         lsr                             LSR                     ;
.e16e  4a         lsr                             LSR                     ;
.e16f  4a         lsr                             LSR                     ;
.e170  20 74 e1   jsr $e174                       JSR   PrintDig          ;
.e173  68         pla                             PLA                     ;
.e174  5a         phy              PrintDig       PHY                     ;  prints A hex nibble (low 4 bits)
.e175  29 0f      and #$0f                        AND   #$0F              ;
.e177  a8         tay                             TAY                     ;
.e178  b9 03 e9   lda $e903,y                     LDA   Hexdigdata,Y      ;
.e17b  7a         ply                             PLY                     ;
.e17c  4c 06 e2   jmp $e206                       jmp   output            ;
.e17f  20 8b e1   jsr $e18b        PrintXSP1      JSR   Print1SP          ;
.e182  ca         dex                             dex                     ;
.e183  e0 00      cpx #$00         PrintXSP       cpx   #$00              ;
.e185  d0 f8      bne $e17f                       bne   PrintXSP1         ;
.e187  60         rts                             rts                     ;
.e188  20 8b e1   jsr $e18b        Print2SP       jsr   Print1SP          ; print 2 SPACES
.e18b  a9 20      lda #$20         Print1SP       LDA   #$20              ; print 1 SPACE
.e18d  4c 06 e2   jmp $e206                       JMP   OUTPUT            ;
.e190  a9 21      lda #$21         Input_Assem    lda   #$21              ; Assembler Prompt "!"

>e192  2c                                         .byte $2c               ; mask out next line to bypass 

.e193  a9 3e      lda #$3e         Input          lda   #$3E              ; Monitor Prompt ">"
.e195  85 32      sta $32                         sta   Prompt            ; save prompt chr 
.e197  20 5a e1   jsr $e15a        Input1         jsr   Print_CR          ; New Line
.e19a  a5 32      lda $32                         lda   Prompt            ; get prompt
.e19c  20 06 e2   jsr $e206                       jsr   Output            ; Print Prompt
.e19f  a0 ff      ldy #$ff                        ldy   #$ff              ; pointer
.e1a1  20 00 e2   jsr $e200        InputWait      jsr   Input_Chr         ; get a character
.e1a4  c9 20      cmp #$20                        cmp   #$20              ; is ctrl char?
.e1a6  b0 3d      bcs $e1e5                       BCS   InputSave         ; no, echo chr 
.e1a8  c9 0d      cmp #$0d                        cmp   #$0d              ; cr
.e1aa  f0 4a      beq $e1f6                       Beq   InputDone         ; done
.e1ac  c9 1b      cmp #$1b                        cmp   #$1B              ; esc
.e1ae  f0 e7      beq $e197                       beq   Input1            ; cancel and new line
.e1b0  c9 08      cmp #$08                        cmp   #$08              ; bs
.e1b2  f0 09      beq $e1bd                       beq   backspace         ;
.e1b4  c9 09      cmp #$09         		   cmp   #$09		   ; TAB key
.e1b6  f0 1b      beq $e1d3        		   beq   tabkey		   ;
.e1b8  c9 02      cmp #$02                        cmp   #$02              ; Ctrl-B
.e1ba  d0 e5      bne $e1a1                       bne   InputWait         ; Ignore other codes
.e1bc  00         brk                             brk                     ; Force a keyboard Break cmd
.e1bd  c0 ff      cpy #$ff         backspace      cpy   #$ff              ;
.e1bf  f0 e0      beq $e1a1                       beq   InputWait         ; nothing to do
.e1c1  88         dey                             dey                     ; remove last char
.e1c2  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e1c4  20 06 e2   jsr $e206                       jsr   Output            ;
.e1c7  a9 20      lda #$20                        Lda   #$20              ; Print space (destructive BS)
.e1c9  20 06 e2   jsr $e206                       jsr   Output            ;
.e1cc  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e1ce  20 06 e2   jsr $e206                       jsr   Output            ;
.e1d1  80 ce      bra $e1a1                       BRA   InputWait         ; ready for next key
.e1d3  a9 20      lda #$20         tabkey	   lda   #$20		   ; convert tab to space
.e1d5  c8         iny              		   iny			   ; move cursor
.e1d6  30 1f      bmi $e1f7                       bmi   InputTooLong	   ; line too long?
.e1d8  99 00 03   sta $0300,y                     sta   Buffer,y		   ; no, save space in buffer
.e1db  20 06 e2   jsr $e206        		   jsr   output		   ; print the space too
.e1de  98         tya                             tya   			   ; test to see if tab is on multiple of 8
.e1df  29 07      and #$07         		   and   #$07		   ; mask remainder of cursor/8
.e1e1  d0 f0      bne $e1d3                       bne   tabkey		   ; not done, add another space
.e1e3  80 bc      bra $e1a1        		   bra   InputWait	   ; done. 
.e1e5  c9 61      cmp #$61         InputSave      CMP   #$61              ;   ucase
.e1e7  90 02      bcc $e1eb                       BCC   InputSave1        ;
.e1e9  e9 20      sbc #$20                        SBC   #$20              ;
.e1eb  c8         iny              InputSave1     INY                     ;
.e1ec  30 09      bmi $e1f7                       BMI   InputTooLong      ; get next char (up to 127)
.e1ee  99 00 03   sta $0300,y                     STA   Buffer,y          ;
.e1f1  20 06 e2   jsr $e206                       JSR   Output            ; OutputCharacter
.e1f4  80 ab      bra $e1a1                       BRA   InputWait         ;
.e1f6  c8         iny              InputDone      INY                     ;
.e1f7  a9 0d      lda #$0d         InputTooLong   LDA   #$0d              ; force CR at end of 128 characters 
.e1f9  99 00 03   sta $0300,y                     sta   Buffer,y          ;
.e1fc  20 06 e2   jsr $e206                       JSR   Output            ;
.e1ff  60         rts                             RTS                     ;
.e200  6c eb 03   jmp ($03eb)      Input_chr      jmp   (ChrInVect)       ;
.e203  6c ee 03   jmp ($03ee)      Scan_input     jmp   (ScanInVect)      ; 
.e206  6c f1 03   jmp ($03f1)      Output         jmp   (ChrOutVect)      ;
.e209  a9 07      lda #$07         bell           LDA  #$07               ; Ctrl G Bell
.e20b  4c 06 e2   jmp $e206                       jmp  Output             ; 
.e20e  48         pha              Delay          PHA                     ; use A to execute a delay loop
.e20f  3a         dec              delay1         DEC                     ;
.e210  d0 fd      bne $e20f                       BNE   delay1            ;
.e212  68         pla                             PLA                     ;
.e213  3a         dec                             DEC                     ;
.e214  d0 f8      bne $e20e                       BNE   Delay             ;
.e216  60         rts              GRTS           RTS                     ;
.e217  8d e2 03   sta $03e2        BRKroutine     sta   ACC               ; save A    Monitor"s break handler
.e21a  8e e3 03   stx $03e3                       stx   Xreg              ; save X
.e21d  8c e4 03   sty $03e4                       sty   Yreg              ; save Y
.e220  68         pla                             pla                     ; 
.e221  8d e6 03   sta $03e6                       sta   Preg              ; save P
.e224  68         pla                             pla                     ; PCL
.e225  fa         plx                             plx                     ; PCH
.e226  38         sec                             sec                     ;
.e227  e9 02      sbc #$02                        sbc   #$02              ;
.e229  8d e1 03   sta $03e1                       sta   PCL               ; backup to BRK cmd
.e22c  b0 01      bcs $e22f                       bcs   Brk2              ;
.e22e  ca         dex                             dex                     ;
.e22f  8e e0 03   stx $03e0        Brk2           stx   PCH               ; save PC
.e232  ba         tsx                             TSX                     ; get stack pointer
.e233  8e e5 03   stx $03e5                       stx   SPtr              ; save stack pointer
.e236  20 09 e2   jsr $e209                       jsr   Bell              ; Beep speaker
.e239  20 23 e1   jsr $e123                       jsr   PrintReg          ; dump register contents 
.e23c  a2 ff      ldx #$ff                        ldx   #$FF              ; 
.e23e  9a         txs                             txs                     ; clear stack
.e23f  58         cli                             cli                     ; enable interrupts again
.e240  4c 49 e2   jmp $e249                       jmp   Monitor           ; start the monitor
.e243                              monitorboot
.e243  20 09 e2   jsr $e209                       jsr   bell              ; beep ready
.e246  20 be e2   jsr $e2be                       JSR   Version           ;
.e249                              sysjmp
.e249  a2 ff      ldx #$ff         Monitor        LDX   #$FF              ; 
.e24b  9a         txs                             TXS			   ;  Init the stack
.e24c  20 93 e1   jsr $e193                       JSR   input             ;  line input
.e24f  a9 00      lda #$00                        LDA   #$00              ;
.e251  a8         tay                             TAY                     ;  set to 1st character in line
.e252  85 33      sta $33                         sta   LineCnt           ; normal list vs range list 
.e254  85 37      sta $37          Mon01          STA   Memchr            ;
.e256  64 3c      stz $3c          Mon02          STZ   Hexdigits         ;  holds parsed hex
.e258  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.e25a  20 7f e2   jsr $e27f                       JSR   ParseHexDig       ;  Get any Hex chars
.e25d  a2 11      ldx #$11                        LDX   #CmdCount         ;  get # of cmds currently used
.e25f  dd 13 e9   cmp $e913,x      Mon08          CMP   CmdAscii,X        ;  is non hex cmd chr?
.e262  f0 05      beq $e269                       BEQ   Mon09             ;  yes x= cmd number
.e264  ca         dex                             DEX                     ;
.e265  10 f8      bpl $e25f                       BPL   Mon08             ;
.e267  80 e0      bra $e249                       BRA   Monitor           ;  no
.e269  da         phx              Mon09          PHX                     ;  save command
.e26a  5a         phy                             PHY                     ;  Save input line pointer
.e26b  8a         txa                             TXA                     ;
.e26c  0a         asl                             ASL                     ;  ptr * 2
.e26d  aa         tax                             TAX                     ;  
.e26e  20 7c e2   jsr $e27c                       JSR   Mon10             ;  Execute cmd
.e271  7a         ply                             PLY                     ;
.e272  fa         plx                             PLX                     ;
.e273  f0 d4      beq $e249                       BEQ   Monitor           ;  done
.e275  bd 49 e9   lda $e949,x                     LDA   Cmdseccode,X      ;  
.e278  30 dc      bmi $e256                       BMI   Mon02             ;
.e27a  80 d8      bra $e254                       BRA   Mon01             ;
.e27c  7c 25 e9   jmp ($e925,x)    Mon10          JMP   (Cmdjmptbl,X)     ;
.e27f  64 35      stz $35          ParseHexDig    STZ   Hexdigcnt         ;  cntr
.e281  80 0e      bra $e291                       BRA   ParseHex05        ;
.e283  8a         txa              ParseHex03     TXA                     ;  parse hex dig
.e284  a2 04      ldx #$04                        LDX   #$04              ;  
.e286  06 3c      asl $3c          ParseHex04     ASL   Hexdigits         ;
.e288  26 3d      rol $3d                         ROL   Hexdigits+1       ;
.e28a  ca         dex                             DEX                     ;
.e28b  d0 f9      bne $e286                       BNE   ParseHex04        ;
.e28d  04 3c      tsb $3c                         TSB   Hexdigits         ;
.e28f  c6 35      dec $35                         DEC   Hexdigcnt         ;
.e291  b9 00 03   lda $0300,y      ParseHex05     LDA   buffer,Y          ;
.e294  a2 0f      ldx #$0f                        LDX   #$0F              ;   is hex chr?
.e296  c8         iny                             INY                     ;
.e297  dd 03 e9   cmp $e903,x      ParseHex07     CMP   Hexdigdata,X      ;
.e29a  f0 e7      beq $e283                       BEQ   ParseHex03        ;   yes
.e29c  ca         dex                             DEX                     ;
.e29d  10 f8      bpl $e297                       BPL   ParseHex07        ;
.e29f  60         rts                             RTS                     ; Stored in HexDigits if HexDigCnt <> 0
.e2a0  a9 79      lda #$79         Help_cmd       lda   #<Helptxt         ;  lower byte - Menu of Commands
.e2a2  85 3a      sta $3a                         sta   addrptr           ;
.e2a4  a9 ec      lda #$ec                        lda   #>Helptxt         ;  upper byte
.e2a6  85 3b      sta $3b                         sta   addrptr+1         ;
.e2a8  80 0f      bra $e2b9                       bra   Help_cmd3         ;
.e2aa  c9 7e      cmp #$7e         Help_Cmd4      cmp   #$7e              ;  "~"
.e2ac  f0 05      beq $e2b3                       beq   Help_Cmd1         ;
.e2ae  20 06 e2   jsr $e206                       jsr   Output            ;
.e2b1  80 03      bra $e2b6                       bra   Help_cmd2         ;
.e2b3  20 5a e1   jsr $e15a        Help_cmd1      jsr   Print_CR          ;     
.e2b6  20 70 e3   jsr $e370        Help_cmd2      jsr   Inc_addrptr       ;
.e2b9  b2 3a      lda ($3a)        Help_cmd3      lda   (addrptr)         ;
.e2bb  d0 ed      bne $e2aa                       bne   Help_cmd4         ;
.e2bd  60         rts                             rts                     ;
.e2be  20 5a e1   jsr $e15a        Version        jsr   Print_CR          ; 
.e2c1  a2 ff      ldx #$ff                        ldx   #$FF              ; set txt pointer
.e2c3  a9 0d      lda #$0d                        lda   #$0d              ; 
.e2c5  e8         inx              PortReadyMsg   inx                     ;
.e2c6  20 06 e2   jsr $e206                       JSR   Output            ; put character to Port
.e2c9  bd 63 f2   lda $f263,x                     lda   porttxt,x         ; get message text
.e2cc  d0 f7      bne $e2c5                       bne   PortReadyMsg      ; 
.e2ce  60         rts                             rts                     ;
.e2cf  20 d8 e2   jsr $e2d8        Excute_cmd     jsr   exe1              ;
.e2d2  a2 ff      ldx #$ff                        ldx   #$FF              ; reset stack
.e2d4  9a         txs                             txs                     ;
.e2d5  4c 49 e2   jmp $e249                       jmp   Monitor           ;
.e2d8  6c 3c 00   jmp ($003c)      exe1           JMP   (Hexdigits)       ;
.e2db  a6 3c      ldx $3c          DOT_cmd        LDX   Hexdigits         ; move address to addrptr
.e2dd  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e2df  86 3a      stx $3a                         STX   Addrptr           ;
.e2e1  85 3b      sta $3b                         STA   Addrptr+1         ;
.e2e3  e6 33      inc $33                         inc   LineCnt           ; range list command
.e2e5  60         rts                             RTS                     ;
.e2e6  c0 01      cpy #$01         CR_cmd         CPY   #$01              ;
.e2e8  d0 0c      bne $e2f6                       BNE   SP_cmd            ;
.e2ea  a5 3a      lda $3a                         LDA   Addrptr           ; CR alone - move addrptr to hexdigits
.e2ec  09 0f      ora #$0f                        ORA   #$0F              ;  to simulate entering an address
.e2ee  85 3c      sta $3c                         STA   Hexdigits         ; *** change 07 to 0f for 16 byte/line
.e2f0  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e2f2  85 3d      sta $3d                         STA   Hexdigits+1       ;
.e2f4  80 17      bra $e30d                       BRA   SP_cmd2           ;
.e2f6  a5 35      lda $35          SP_cmd         LDA   Hexdigcnt         ; Space command entry
.e2f8  f0 5a      beq $e354                       BEQ   SP_cmd5           ; any digits to process? no - done
.e2fa  a6 37      ldx $37                         LDX   Memchr            ; yes - is sec cmd code 0 ? yes - 
.e2fc  f0 0a      beq $e308                       BEQ   SP_cmd1           ; yes - 
.e2fe  ca         dex                             DEX                     ; Is sec cmd = 1?       
.e2ff  f0 1c      beq $e31d                       BEQ   SP_cmd3           ;       yes - is sec cmd code 1 ?
.e301  a5 3c      lda $3c                         LDA   Hexdigits         ;             no - ":" cmd processed
.e303  92 3a      sta ($3a)                       STA   (Addrptr)         ;
.e305  4c 70 e3   jmp $e370                       JMP   Inc_addrptr       ; set to next address and return
.e308  20 db e2   jsr $e2db        SP_cmd1        JSR   DOT_cmd           ; sec dig = 0  move address to addrptr
.e30b  80 10      bra $e31d                       BRA   SP_cmd3           ;
.e30d  a5 3a      lda $3a          SP_cmd2        LDA   Addrptr           ; CR cmd entry 
.e30f  89 0f      bit #$0f                        BIT   #$0F              ; *** changed 07 to 0F for 16 bytes/line
.e311  f0 0a      beq $e31d                       BEQ   SP_cmd3           ; if 16, print new line
.e313  c0 00      cpy #$00                        cpy   #$00              ; if TXT cmd, don"t print the - or spaces between chrs
.e315  f0 46      beq $e35d                       beq   TXT_cmd1          ;
.e317  89 07      bit #$07                        BIT   #$07              ; if 8, print -
.e319  f0 11      beq $e32c                       BEQ   SP_cmd33          ;
.e31b  80 19      bra $e336                       BRA   SP_cmd4           ; else print next byte
.e31d  20 5a e1   jsr $e15a        SP_cmd3        JSR   Print_CR          ; "." cmd - display address and data 
.e320  20 03 e2   jsr $e203                       jsr   Scan_Input        ; see if brk requested
.e323  b0 2d      bcs $e352                       bcs   SP_brk            ; if so, stop 
.e325  a5 3b      lda $3b                         LDA   Addrptr+1         ; print address
.e327  a6 3a      ldx $3a                         LDX   Addrptr           ;
.e329  20 67 e1   jsr $e167                       JSR   Print2Byte        ;
.e32c  a9 20      lda #$20         SP_cmd33       LDA   #$20              ; " " print 1 - 16 bytes of data
.e32e  20 06 e2   jsr $e206                       JSR   OUTPUT            ;
.e331  a9 2d      lda #$2d                        LDA   #$2D              ; "-"
.e333  20 06 e2   jsr $e206                       JSR   OUTPUT            ;
.e336  a9 20      lda #$20         SP_cmd4        LDA   #$20              ; " " 
.e338  20 06 e2   jsr $e206                       JSR   OUTPUT            ;
.e33b  c0 00      cpy #$00                        cpy   #$00              ;
.e33d  f0 1e      beq $e35d                       beq   TXT_Cmd1          ;
.e33f  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;
.e341  20 6b e1   jsr $e16b                       JSR   Print1Byte        ;
.e344  38         sec              SP_cmd44       SEC                     ;  checks if range done
.e345  a5 3a      lda $3a                         LDA   Addrptr           ;
.e347  e5 3c      sbc $3c                         SBC   Hexdigits         ;
.e349  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e34b  e5 3d      sbc $3d                         SBC   Hexdigits+1       ;
.e34d  20 70 e3   jsr $e370                       jsr   Inc_addrptr       ;
.e350  90 bb      bcc $e30d                       BCC   SP_cmd2           ; loop until range done
.e352  64 37      stz $37          SP_brk         STZ   Memchr            ; reset sec cmd code
.e354  60         rts              SP_cmd5        RTS                     ; done or no digits to process
.e355  5a         phy              TXT_Cmd        PHY                     ;
.e356  a0 00      ldy #$00                        ldy   #$00              ;
.e358  20 f6 e2   jsr $e2f6                       jsr   SP_cmd            ;
.e35b  7a         ply                             PLY                     ;
.e35c  60         rts                             RTS                     ;
.e35d  b2 3a      lda ($3a)        TXT_cmd1       LDA   (Addrptr)         ;
.e35f  29 7f      and #$7f                        AND   #$7F              ;
.e361  c9 7f      cmp #$7f                        CMP   #$7F              ;
.e363  f0 04      beq $e369                       BEQ   TXT_Cmd2          ;
.e365  c9 20      cmp #$20                        CMP   #$20              ; " "
.e367  b0 02      bcs $e36b                       BCS   TXT_Cmd3          ;
.e369  a9 2e      lda #$2e         TXT_Cmd2       LDA   #$2E              ; "." use "." if not printable char
.e36b  20 06 e2   jsr $e206        TXT_Cmd3       JSR   OUTPUT            ;
.e36e  80 d4      bra $e344                       BRA   SP_cmd44          ;
.e370  e6 3a      inc $3a          Inc_addrptr    INC   Addrptr           ;  increments addrptr
.e372  d0 02      bne $e376                       BNE   Inc_addr1         ;
.e374  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e376  60         rts              Inc_addr1      RTS                     ;
.e377  a5 33      lda $33          Insert_cmd     lda   Linecnt           ;  "I" cmd code
.e379  f0 3e      beq $e3b9                       beq   Insert_3          ; abort if no . cmd entered
.e37b  38         sec                             sec                     ;
.e37c  a5 3c      lda $3c                         lda   Hexdigits         ;
.e37e  e5 3a      sbc $3a                         sbc   addrptr           ;
.e380  aa         tax                             tax                     ;
.e381  a5 3d      lda $3d                         lda   Hexdigits+1       ;
.e383  e5 3b      sbc $3b                         sbc   addrptr+1         ;
.e385  a8         tay                             tay                     ;
.e386  90 31      bcc $e3b9                       bcc   Insert_3          ;
.e388  18         clc                             clc                     ;
.e389  8a         txa                             txa                     ;
.e38a  65 3e      adc $3e                         adc   memptr            ;
.e38c  85 3c      sta $3c                         sta   hexdigits         ;
.e38e  98         tya                             tya                     ;
.e38f  65 3f      adc $3f                         adc   memptr+1          ;
.e391  85 3d      sta $3d                         sta   hexdigits+1       ;
.e393  b2 3e      lda ($3e)        Insert_0       LDA   (memptr)          ;
.e395  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e397  a9 ff      lda #$ff                        lda   #$FF              ;
.e399  c6 3c      dec $3c                         DEC   Hexdigits         ;  
.e39b  c5 3c      cmp $3c                         cmp   Hexdigits         ;  
.e39d  d0 02      bne $e3a1                       BNE   Insert_1          ;
.e39f  c6 3d      dec $3d                         DEC   Hexdigits+1       ;
.e3a1  c6 3e      dec $3e          Insert_1       dec   Memptr            ;  
.e3a3  c5 3e      cmp $3e                         cmp   Memptr            ;
.e3a5  d0 02      bne $e3a9                       bne   Insert_2          ;
.e3a7  c6 3f      dec $3f                         dec   Memptr+1          ;
.e3a9  38         sec              Insert_2       SEC                     ;  
.e3aa  a5 3e      lda $3e                         LDA   memptr            ;
.e3ac  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e3ae  a5 3f      lda $3f                         LDA   memptr+1          ;
.e3b0  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e3b2  90 05      bcc $e3b9                       bcc   Insert_3          ;
.e3b4  20 03 e2   jsr $e203                       jsr   Scan_Input        ; see if brk requested
.e3b7  90 da      bcc $e393                       bcc   Insert_0          ; if so, stop List
.e3b9  60         rts              Insert_3       RTS                     ;
.e3ba  a5 33      lda $33          Move_cmd       lda   Linecnt           ; *** any changes to this routine affect EEPROM_WR too!!!
.e3bc  d0 0d      bne $e3cb                       bne   Move_cmd3         ; abort if no . cmd was used
.e3be  60         rts              Move_brk       RTS                     ;
.e3bf  e6 3a      inc $3a          Move_cmd1      INC   Addrptr           ;  increments addrptr
.e3c1  d0 02      bne $e3c5                       BNE   Move_cmd2         ;
.e3c3  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e3c5  e6 3c      inc $3c          Move_cmd2      inc   Hexdigits         ;  "M" cmd code
.e3c7  d0 02      bne $e3cb                       bne   Move_cmd3         ;
.e3c9  e6 3d      inc $3d                         inc   Hexdigits+1       ;
.e3cb  38         sec              Move_cmd3      SEC                     ;  checks if range done
.e3cc  a5 3e      lda $3e                         LDA   Memptr            ;
.e3ce  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e3d0  a5 3f      lda $3f                         LDA   Memptr+1          ;
.e3d2  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e3d4  90 e8      bcc $e3be                       BCC   Move_brk          ;  exit if range done
.e3d6  20 03 e2   jsr $e203                       jsr   Scan_Input        ; see if brk requested
.e3d9  b0 e3      bcs $e3be                       bcs   Move_brk          ; 
.e3db  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;  Moves one byte
.e3dd  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e3df  80 de      bra $e3bf                       BRA   Move_cmd1         ; (zapped after move from eeprom_wr)
.e3e1  b2 3a      lda ($3a)        EEPROM_TEST    lda   (Addrptr)         ;    moved along with Move_cmd for EEPROM_WR
.e3e3  52 3c      eor ($3c)                       eor   (Hexdigits)       ;    ""
.e3e5  30 fa      bmi $e3e1                       bmi   EEPROM_TEST       ;    ""
.e3e7  80 d6      bra $e3bf                       bra   Move_cmd1         ;    ""
.e3e9  a5 3a      lda $3a          EEPROM_WR      lda   Addrptr           ;  move the Move_cmd sub to $0280 (kybrd buffer)
.e3eb  48         pha                             pha                     ;  adding EEPROM test routine 
.e3ec  a5 3b      lda $3b                         lda   Addrptr+1         ;  then run the burn program from RAM
.e3ee  48         pha                             pha                     ;  
.e3ef  a9 ba      lda #$ba                        lda   #<Move_cmd        ;
.e3f1  85 3a      sta $3a                         sta   Addrptr           ;
.e3f3  a9 e3      lda #$e3                        lda   #>Move_cmd        ;
.e3f5  85 3b      sta $3b                         sta   Addrptr+1         ;
.e3f7  a0 2e      ldy #$2e                        ldy   #$2E              ;  47 instructions
.e3f9  b1 3a      lda ($3a),y      EEPROM_WR1     lda   (Addrptr),y       ;
.e3fb  99 80 02   sta $0280,y                     sta   $0280,y           ;
.e3fe  88         dey                             dey                     ;
.e3ff  10 f8      bpl $e3f9                       bpl   EEPROM_WR1        ;
.e401  a9 ea      lda #$ea                        lda   #$EA              ; NOP instruction
.e403  8d a5 02   sta $02a5                       sta   $02A5             ; *
.e406  8d a6 02   sta $02a6                       sta   $02A6             ; * affected by changes to Move_cmd routine
.e409  8d 9c 02   sta $029c                       sta   $029C             ; * affected by changes to Move_cmd routine
.e40c  8d 9d 02   sta $029d                       sta   $029D             ; * affected by changes to Move_cmd routine
.e40f  8d 9e 02   sta $029e                       sta   $029E             ; * affected by changes to Move_cmd routine
.e412  8d 9f 02   sta $029f                       sta   $029F             ; * affected by changes to Move_cmd routine
.e415  8d a0 02   sta $02a0                       sta   $02A0             ; * affected by changes to Move_cmd routine
.e418  68         pla                             pla                     ;
.e419  85 3b      sta $3b                         sta   Addrptr+1         ;
.e41b  68         pla                             pla                     ;
.e41c  85 3a      sta $3a                         sta   Addrptr           ;        
.e41e  4c 80 02   jmp $0280                       jmp   $0280             ;
.e421  a6 3c      ldx $3c          Dest_cmd       LDX   Hexdigits         ;  ">" cmd code
.e423  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e425  86 3e      stx $3e                         STX   Memptr            ;  move address to memptr
.e427  85 3f      sta $3f                         STA   Memptr+1          ;
.e429  60         rts                             RTS                     ;  
.e42a  a5 33      lda $33          LIST_cmd       lda   LineCnt           ;  Check for normal/range
.e42c  f0 29      beq $e457                       beq   List_cmd_1        ;  0 = normal  1=range 
.e42e  a5 3a      lda $3a                         LDA   Addrptr           ;  Dissassemble range of code
.e430  a6 3b      ldx $3b                         LDX   Addrptr+1         ;  move addrptr to startaddr
.e432  85 38      sta $38                         STA   Startaddr         ;
.e434  86 39      stx $39                         STX   Startaddr+1       ;
.e436  38         sec              List_range     sec                     ;
.e437  a5 38      lda $38                         lda   Startaddr         ;
.e439  e5 3a      sbc $3a                         sbc   Addrptr           ;
.e43b  a5 39      lda $39                         lda   Startaddr+1       ; 
.e43d  e5 3b      sbc $3b                         sbc   Addrptr+1         ;
.e43f  90 15      bcc $e456                       bcc   List_done         ;
.e441  20 6f e4   jsr $e46f                       jsr   List_Line         ;  list one line
.e444  20 03 e2   jsr $e203                       jsr   Scan_Input        ; see if brk requested
.e447  b0 0d      bcs $e456                       bcs   List_done         ; if so, stop List
.e449  38         sec                             SEC                     ;  checks if range done
.e44a  a5 3c      lda $3c                         LDA   Hexdigits         ;
.e44c  e5 38      sbc $38                         SBC   Startaddr         ;
.e44e  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e450  e5 39      sbc $39                         SBC   Startaddr+1       ;
.e452  b0 e2      bcs $e436                       BCS   List_range        ;  if not, loop until done
.e454  64 33      stz $33                         stz   LineCnt           ;
.e456  60         rts              List_done      RTS                     ;
.e457  a5 35      lda $35          List_cmd_1     LDA   Hexdigcnt         ; Dissassemble one page of cmds
.e459  f0 08      beq $e463                       BEQ   List1             ; followed with more pages 
.e45b  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.e45d  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e45f  86 38      stx $38                         STX   Startaddr         ;
.e461  85 39      sta $39                         STA   Startaddr+1       ;
.e463  a9 14      lda #$14         List1          LDA   #$14              ; one page of dissassembly
.e465  85 33      sta $33                         STA   Linecnt           ;
.e467  20 6f e4   jsr $e46f        List2          JSR   List_line         ;
.e46a  c6 33      dec $33                         DEC   Linecnt           ;
.e46c  d0 f9      bne $e467                       BNE   List2             ;
.e46e  60         rts                             RTS                     ;
.e46f  20 5a e1   jsr $e15a        List_line      JSR   Print_CR          ; 
.e472  20 81 e4   jsr $e481                       JSR   List_one          ; one line of dissassembly
.e475  18         clc                             CLC                     ;
.e476  a5 38      lda $38                         LDA   Startaddr         ; inc address pointer to next cmd
.e478  65 35      adc $35                         ADC   Hexdigcnt         ;
.e47a  85 38      sta $38                         STA   Startaddr         ;
.e47c  90 02      bcc $e480                       BCC   List3             ;
.e47e  e6 39      inc $39                         INC   Startaddr+1       ;
.e480  60         rts              List3          RTS                     ;
.e481  b2 38      lda ($38)        List_one       LDA   (Startaddr)       ; Dissassemble one CMD from Startaddr
.e483  aa         tax                             TAX                     ; Initialize List Cmd pointers
.e484  bd 5b e9   lda $e95b,x                     LDA   OPCtxtidx,X       ;
.e487  85 36      sta $36                         STA   OPCtxtptr         ;
.e489  bd 5b ea   lda $ea5b,x                     LDA   OPCaddmode,X      ;
.e48c  29 0f      and #$0f                        AND   #$0F              ; mask out psuedo-modes
.e48e  85 34      sta $34                         STA   Modejmp           ;
.e490  aa         tax                             TAX                     ;
.e491  bd 5b eb   lda $eb5b,x                     LDA   ModeByteCnt,X     ;
.e494  85 35      sta $35                         STA   Hexdigcnt         ;
.e496  a5 39      lda $39                         LDA   Startaddr+1       ;
.e498  a6 38      ldx $38                         LDX   Startaddr         ;
.e49a  20 67 e1   jsr $e167                       JSR   Print2Byte        ; print address 
.e49d  a9 2d      lda #$2d                        LDA   #$2D              ;  "-"
.e49f  20 06 e2   jsr $e206                       JSR   OUTPUT            ;
.e4a2  20 88 e1   jsr $e188                       JSR   Print2SP          ; print "  "
.e4a5  a2 01      ldx #$01                        LDX   #$01              ;---------
.e4a7  a0 00      ldy #$00         List4          LDY   #$00              ;print up to 3 ascii chars...
.e4a9  c4 35      cpy $35          List5          CPY   Hexdigcnt         ;  two spaces...
.e4ab  b0 0b      bcs $e4b8                       BCS   List6             ;  up to three hex chars...
.e4ad  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;  two spaces
.e4af  e0 00      cpx #$00                        CPX   #$00              ;
.e4b1  d0 0e      bne $e4c1                       BNE   List8             ;
.e4b3  20 6b e1   jsr $e16b                       JSR   Print1Byte        ;
.e4b6  80 07      bra $e4bf                       BRA   List7             ;
.e4b8  e0 00      cpx #$00         List6          CPX   #$00              ;
.e4ba  d0 03      bne $e4bf                       BNE   List7             ;
.e4bc  20 88 e1   jsr $e188                       JSR   Print2SP          ;
.e4bf  a9 20      lda #$20         List7          LDA   #$20              ; " "
.e4c1  29 7f      and #$7f         List8          AND   #$7F              ;
.e4c3  c9 7f      cmp #$7f                        CMP   #$7F              ;
.e4c5  f0 04      beq $e4cb                       BEQ   List9             ;
.e4c7  c9 20      cmp #$20                        CMP   #$20              ; " "
.e4c9  b0 02      bcs $e4cd                       BCS   List10            ;
.e4cb  a9 2e      lda #$2e         List9          LDA   #$2E              ; "." use "." if not printable char
.e4cd  20 06 e2   jsr $e206        List10         JSR   OUTPUT            ;
.e4d0  c8         iny                             INY                     ;
.e4d1  c0 03      cpy #$03                        CPY   #$03              ;
.e4d3  90 d4      bcc $e4a9                       BCC   List5             ;
.e4d5  20 88 e1   jsr $e188                       JSR   Print2SP          ;
.e4d8  ca         dex                             DEX                     ;
.e4d9  f0 cc      beq $e4a7                       BEQ   List4             ;---------
.e4db  a5 36      lda $36                         LDA   OPCtxtptr         ; get opcode text
.e4dd  0a         asl                             ASL                     ;
.e4de  65 36      adc $36                         ADC   OPCtxtptr         ;
.e4e0  aa         tax                             TAX                     ;
.e4e1  a0 fd      ldy #$fd                        LDY   #$FD              ;
.e4e3  bd 9b eb   lda $eb9b,x      List11         LDA   OPCtxtData,X      ;
.e4e6  20 06 e2   jsr $e206                       JSR   OUTPUT            ; print opcode text
.e4e9  e8         inx                             INX                     ;
.e4ea  c8         iny                             INY                     ;
.e4eb  d0 f6      bne $e4e3                       BNE   List11            ;
.e4ed  a5 36      lda $36                         LDA   OPCtxtptr         ;
.e4ef  c9 42      cmp #$42                        CMP   #$42              ; 4chr opcodes start
.e4f1  30 19      bmi $e50c                       BMI   List12		   ;
.e4f3  c9 46      cmp #$46                        CMP   #$46              ; the .xx cmds
.e4f5  10 15      bpl $e50c                       BPL   List12            ; 
.e4f7  b2 38      lda ($38)                       lda   (startaddr)	   ; get opcode of 4byte code
.e4f9  4a         lsr                             lsr
.e4fa  4a         lsr                             lsr
.e4fb  4a         lsr                             lsr
.e4fc  4a         lsr                             lsr
.e4fd  29 07      and #$07                        AND   #$07              ; strip last 3 bits
.e4ff  09 30      ora #$30                        ora   #$30              ; add CHR '0'
.e501  20 06 e2   jsr $e206                       jsr   Output            ; print it
.e504  a9 20      lda #$20                        lda   #$20              ; " "
.e506  20 06 e2   jsr $e206                       jsr   Output            ; 
.e509  4c 0f e5   jmp $e50f                       jmp   List13            ;
.e50c  20 88 e1   jsr $e188        List12         JSR   Print2SP          ;
.e50f  a5 34      lda $34          List13         LDA   Modejmp           ; setup to print operand
.e511  0a         asl                             ASL                     ;
.e512  aa         tax                             TAX                     ;
.e513  7c 6b eb   jmp ($eb6b,x)                   JMP   (ModeJmpTbl,X)    ; goto operand printing command
.e516  a9 23      lda #$23         IMM_mode       LDA   #$23              ; print #$HH
.e518  20 06 e2   jsr $e206                       JSR   output            ;
.e51b  a9 24      lda #$24         ZP_mode        LDA   #$24              ; print $HH
.e51d  20 06 e2   jsr $e206                       JSR   output            ;
.e520  a0 01      ldy #$01                        LDY   #$01              ;
.e522  b1 38      lda ($38),y      Byte_mode      LDA   (Startaddr),Y     ;
.e524  4c 6b e1   jmp $e16b                       JMP   Print1Byte        ;
.e527  20 1b e5   jsr $e51b        ZP_X_mode      JSR   ZP_mode           ; print $HH,X
.e52a  a9 2c      lda #$2c         X_mode         LDA   #$2C              ; print ,X
.e52c  20 06 e2   jsr $e206                       JSR   output            ;
.e52f  a9 58      lda #$58                        LDA   #$58              ; 
.e531  4c 06 e2   jmp $e206                       JMP   output            ;
.e534  20 1b e5   jsr $e51b        ZP_Y_mode      JSR   ZP_mode           ; print $HH,Y
.e537  a9 2c      lda #$2c         Y_mode         LDA   #$2C              ; Print ,Y
.e539  20 06 e2   jsr $e206                       JSR   output            ;
.e53c  a9 59      lda #$59                        LDA   #$59              ; 
.e53e  4c 06 e2   jmp $e206                       JMP   output            ;
.e541  20 87 e5   jsr $e587        INDZP_mode     JSR   IND0_mode         ; Print ($HH)
.e544  20 1b e5   jsr $e51b                       JSR   ZP_mode           ;
.e547  a9 29      lda #$29         IND1_mode      LDA   #$29              ; Print )
.e549  4c 06 e2   jmp $e206                       JMP   output            ;
.e54c  20 87 e5   jsr $e587        INDZP_X_mode   JSR   IND0_mode         ; Print ($HH,X)
.e54f  20 1b e5   jsr $e51b                       JSR   ZP_mode           ;
.e552  20 2a e5   jsr $e52a                       JSR   X_mode            ;
.e555  80 f0      bra $e547                       BRA   IND1_mode         ;
.e557  20 41 e5   jsr $e541        INDZP_Y_mode   JSR   INDZP_mode        ; Print ($HH),Y
.e55a  80 db      bra $e537                       BRA   Y_mode            ;
.e55c  a9 24      lda #$24         ABS_mode       LDA   #$24              ; Print $HHHH
.e55e  20 06 e2   jsr $e206                       JSR   output            ;
.e561  a0 02      ldy #$02                        LDY   #$02              ;
.e563  20 22 e5   jsr $e522                       JSR   Byte_mode         ;
.e566  88         dey                             DEY                     ;
.e567  80 b9      bra $e522                       BRA   Byte_mode         ;
.e569  20 5c e5   jsr $e55c        ABS_X_mode     JSR   ABS_mode          ; Print $HHHH,X
.e56c  80 bc      bra $e52a                       BRA   X_mode            ;
.e56e  20 5c e5   jsr $e55c        ABS_Y_mode     JSR   ABS_mode          ; Print $HHHH,Y
.e571  80 c4      bra $e537                       BRA   Y_mode            ;
.e573  20 87 e5   jsr $e587        INDABS_mode    JSR   IND0_mode         ; Print ($HHHH)
.e576  20 5c e5   jsr $e55c                       JSR   ABS_mode          ;
.e579  80 cc      bra $e547                       BRA   IND1_mode         ;
.e57b  20 87 e5   jsr $e587        INDABSX_mode   JSR   IND0_mode         ; Print ($HHHH,X)
.e57e  20 5c e5   jsr $e55c                       JSR   ABS_mode          ;
.e581  20 2a e5   jsr $e52a                       JSR   X_mode            ;
.e584  80 c1      bra $e547                       BRA   IND1_mode         ;
.e586  60         rts              IMPLIED_mode   RTS                     ; Implied/Accumulator mode 
.e587  a9 28      lda #$28         IND0_mode      LDA   #$28              ; Print (
.e589  4c 06 e2   jmp $e206                       JMP   output            ;
.e58c  20 1b e5   jsr $e51b        BBREL_mode     JSR   ZP_mode		   ;
.e58f  a9 2c      lda #$2c         		   LDA   #$2C              ; Print ,
.e591  20 06 e2   jsr $e206                       JSR   output            ;
.e594  a9 24      lda #$24                        LDA   #$24              ; Print $
.e596  20 06 e2   jsr $e206                       JSR   output            ;
.e599  a0 02      ldy #$02                        LDY   #$02		   ;
.e59b  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.e59d  85 37      sta $37                         STA   Memchr            ;
.e59f  18         clc                             CLC                     ;
.e5a0  a5 38      lda $38                         LDA   Startaddr         ;
.e5a2  69 03      adc #$03                        ADC   #$03              ;
.e5a4  4c b7 e5   jmp $e5b7                       JMP   REL_mode0         ;
.e5a7  a9 24      lda #$24         REL_mode       LDA   #$24              ; Print $HHHH as Relative Branch
.e5a9  20 06 e2   jsr $e206                       JSR   output            ;
.e5ac  a0 01      ldy #$01                        LDY   #$01              ;
.e5ae  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.e5b0  85 37      sta $37                         STA   Memchr            ;
.e5b2  18         clc                             CLC                     ;
.e5b3  a5 38      lda $38                         LDA   Startaddr         ;
.e5b5  69 02      adc #$02                        ADC   #$02              ;
.e5b7  aa         tax              REL_mode0      TAX                     ;
.e5b8  a5 39      lda $39                         LDA   Startaddr+1       ;
.e5ba  69 00      adc #$00                        ADC   #$00              ;
.e5bc  a8         tay                             TAY                     ;
.e5bd  18         clc                             CLC                     ;
.e5be  8a         txa                             TXA                     ;
.e5bf  65 37      adc $37                         ADC   Memchr            ;
.e5c1  aa         tax                             TAX                     ;
.e5c2  98         tya                             TYA                     ;
.e5c3  a4 37      ldy $37                         LDY   Memchr            ;
.e5c5  10 01      bpl $e5c8                       BPL   Rel_mode1         ;
.e5c7  3a         dec                             DEC                     ;
.e5c8  69 00      adc #$00         Rel_mode1      ADC   #$00              ;
.e5ca  4c 67 e1   jmp $e167                       JMP   Print2Byte        ;
.e5cd  ba         tsx              Assem_Init     tsx                     ;
.e5ce  e8         inx                             inx                     ;
.e5cf  e8         inx                             inx                     ;
.e5d0  e8         inx                             inx                     ;
.e5d1  e8         inx                             inx                     ;
.e5d2  9e 00 01   stz $0100,x                     stz   $0100,x           ;
.e5d5  20 be e2   jsr $e2be                       jsr   version           ;  show version and ? prompt
.e5d8  4c fb e5   jmp $e5fb                       jmp   Assembler         ;
.e5db  a9 a5      lda #$a5         Asm_Help       lda   #<AsmHelptxt      ;  lower byte - Menu of Commands
.e5dd  85 3a      sta $3a                         sta   addrptr           ;
.e5df  a9 f0      lda #$f0                        lda   #>AsmHelptxt      ;  upper byte
.e5e1  85 3b      sta $3b                         sta   addrptr+1         ;
.e5e3  80 0f      bra $e5f4                       bra   AsmHelp3          ;
.e5e5  c9 7e      cmp #$7e         ASmHelp4       cmp   #$7e              ;  "~"
.e5e7  f0 05      beq $e5ee                       beq   AsmHelp1          ;
.e5e9  20 06 e2   jsr $e206                       jsr   Output            ;
.e5ec  80 03      bra $e5f1                       bra   AsmHelp2          ;
.e5ee  20 5a e1   jsr $e15a        AsmHelp1       jsr   Print_CR          ;     
.e5f1  20 70 e3   jsr $e370        AsmHelp2       jsr   Inc_addrptr       ;
.e5f4  b2 3a      lda ($3a)        AsmHelp3       lda   (addrptr)         ;
.e5f6  d0 ed      bne $e5e5                       bne   AsmHelp4          ;
.e5f8  20 c9 e8   jsr $e8c9                       jsr   Opcode_List       ;  
.e5fb  a2 ff      ldx #$ff         Assembler      LDX   #$FF              ;
.e5fd  9a         txs                             TXS                     ; init stack
.e5fe  64 35      stz $35                         stz   HexDigCnt         ;
.e600  20 90 e1   jsr $e190                       jsr   Input_assem       ;
.e603  a0 00      ldy #$00                        ldy   #$00              ; beginning of input line
.e605  ad 00 03   lda $0300                       lda   buffer            ;
.e608  c9 0d      cmp #$0d                        cmp   #$0d              ; Enter = done 
.e60a  d0 03      bne $e60f                       bne   Asm01             ;
.e60c  4c 49 e2   jmp $e249                       JMP   Monitor           ; exit assembler
.e60f  c9 3f      cmp #$3f         Asm01          cmp   #$3f              ; "?" Print Help
.e611  f0 c8      beq $e5db                       beq   Asm_Help          ;
.e613  c9 20      cmp #$20                        cmp   #$20              ; space
.e615  f0 3b      beq $e652                       beq   Asm_opfetch       ;
.e617  c9 3b      cmp #$3b                        cmp   #$3b              ;  ";" ignore line
.e619  f0 e0      beq $e5fb                       beq   Assembler         ;
.e61b  c9 4c      cmp #$4c                        cmp   #$4C              ;  "L" list
.e61d  f0 2c      beq $e64b                       beq   Asm_List          ;
.e61f  c9 24      cmp #$24                        cmp   #$24              ;  "$" ignore this
.e621  d0 01      bne $e624                       bne   Asm02             ;
.e623  c8         iny                             iny                     ;
.e624  64 3c      stz $3c          Asm02          STZ   Hexdigits         ;  holds parsed hex
.e626  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.e628  20 7f e2   jsr $e27f                       JSR   ParseHexDig       ;  get Hex Chars 
.e62b  a6 35      ldx $35                         LDX   Hexdigcnt         ;
.e62d  f0 08      beq $e637                       Beq   Asm_Err           ;
.e62f  c9 4c      cmp #$4c                        cmp   #$4C              ; "L" do list               ???
.e631  f0 1a      beq $e64d                       Beq   Asm_List1         ;
.e633  c9 20      cmp #$20                        cmp   #$20              ; Space
.e635  f0 1b      beq $e652                       Beq   Asm_opfetch       ;
.e637  98         tya              Asm_Err        tya                     ;  get line pointer
.e638  aa         tax                             tax                     ;
.e639  a9 0a      lda #$0a                        lda   #$0a              ; LF move down one line
.e63b  20 06 e2   jsr $e206                       jsr   output            ;
.e63e  20 83 e1   jsr $e183                       jsr   PrintXSP          ; move to where error occured
.e641  a9 5e      lda #$5e                        lda   #$5E              ; "^"                       ???
.e643  20 06 e2   jsr $e206                       jsr   Output            ; mark it 
.e646  20 09 e2   jsr $e209                       jsr   bell              ; 
.e649  80 b0      bra $e5fb                       bra   Assembler         ;
.e64b  64 35      stz $35          Asm_list       stz   HexDigcnt         ;
.e64d  20 57 e4   jsr $e457        Asm_List1      jsr   List_Cmd_1        ;
.e650  80 a9      bra $e5fb        Asm_hop        bra   Assembler         ;
.e652  a5 35      lda $35          Asm_opfetch    lda   HexDigCnt         ;
.e654  f0 0a      beq $e660                       beq   Asm_op01          ; no address change
.e656  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.e658  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e65a  86 3a      stx $3a                         STX   AddrPtr           ;
.e65c  85 3b      sta $3b                         STA   AddrPtr+1         ;
.e65e  88         dey                             dey                     ;
.e65f  c8         iny              Asm_stripSP    iny                     ;
.e660  b9 00 03   lda $0300,y      Asm_op01       lda   buffer,y          ;
.e663  c9 20      cmp #$20                        cmp   #$20              ; strip spaces
.e665  f0 f8      beq $e65f                       beq   Asm_stripSP       ;
.e667  c9 0d      cmp #$0d                        cmp   #$0d              ; done
.e669  f0 e5      beq $e650                       beq   Asm_hop           ;
.e66b  c9 3b      cmp #$3b                        cmp   #$3b              ; ";" comment char done
.e66d  f0 e1      beq $e650                       beq   Asm_hop           ;
.e66f  a2 00      ldx #$00                        ldx   #$00              ;
.e671  86 36      stx $36                         stx   OpcTxtPtr         ;
.e673  84 33      sty $33                         sty   LineCnt           ;
.e675  a4 33      ldy $33          Asm_opclp      ldy   LineCnt           ;
.e677  a5 36      lda $36                         lda   OpcTxtPtr         ;
.e679  0a         asl                             ASL                     ;
.e67a  65 36      adc $36                         adc   OpcTxtPtr         ;
.e67c  aa         tax                             tax                     ;
.e67d  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.e680  c8         iny                             iny                     ;
.e681  dd 9b eb   cmp $eb9b,x                     cmp   OpcTxtData,x      ;
.e684  d0 14      bne $e69a                       bne   Asm_getnext       ;
.e686  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.e689  e8         inx                             inx                     ;
.e68a  c8         iny                             iny                     ;
.e68b  dd 9b eb   cmp $eb9b,x                     cmp   OpcTxtData,x      ;
.e68e  d0 0a      bne $e69a                       bne   Asm_getnext       ;
.e690  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.e693  e8         inx                             inx                     ;
.e694  c8         iny                             iny                     ;
.e695  dd 9b eb   cmp $eb9b,x                     cmp   OpcTxtData,x      ;
.e698  f0 0c      beq $e6a6                       beq   Asm_goodop        ;
.e69a  a6 36      ldx $36          Asm_getnext    ldx   OpcTxtPtr         ;
.e69c  e8         inx                             inx                     ;
.e69d  86 36      stx $36                         stx   OpcTxtPtr         ;
.e69f  e0 4a      cpx #$4a                        cpx   #$4A              ; last one? then err
.e6a1  d0 d2      bne $e675                       bne   Asm_opclp
.e6a3  4c 37 e6   jmp $e637        Asm_err2       jmp   Asm_err
.e6a6  a9 00      lda #$00         Asm_goodop     lda   #$00
.e6a8  85 34      sta $34                         sta   ModeJmp           ; 
.e6aa  c6 34      dec $34                         dec   ModeJmp           ; init to FF for () check
.e6ac  85 3c      sta $3c                         sta   HexDigits         ; and Byte holder
.e6ae  85 3d      sta $3d                         sta   HexDigits+1       ; 
.e6b0  85 35      sta $35                         sta   HexDigCnt         ;
.e6b2  a6 36      ldx $36                         ldx   OpcTxtPtr         ;
.e6b4  e0 42      cpx #$42                        cpx   #$42              ; 
.e6b6  30 18      bmi $e6d0                       bmi   Asm_goodSP        ; not a 4 chr opcode
.e6b8  e0 46      cpx #$46                        cpx   #$46              
.e6ba  10 14      bpl $e6d0                       bpl   Asm_goodSP        ; not a 4 chr opcode
.e6bc  b9 00 03   lda $0300,y                     lda   buffer,y          ; get next chr
.e6bf  c8         iny                             iny                     ; advance pointer
.e6c0  c9 38      cmp #$38                        cmp   #$38              ; 
.e6c2  10 df      bpl $e6a3                       bpl   Asm_err2          ; not chr "0"-"7"
.e6c4  c9 30      cmp #$30                        cmp   #$30
.e6c6  30 db      bmi $e6a3                       bmi   Asm_err2          ; not chr "0"-"7"
.e6c8  0a         asl                             ASL
.e6c9  0a         asl                             ASL
.e6ca  0a         asl                             ASL
.e6cb  0a         asl                             ASL
.e6cc  85 39      sta $39                         sta   startaddr_H       ; temp holder for 4th chr opcode
.e6ce  a9 80      lda #$80                        LDA   #$80              ; flag for 
.e6d0  be 00 03   ldx $0300,y      Asm_goodSP     ldx   buffer,y          ; get next operand char
.e6d3  c8         iny                             iny                     ; point to next operand chr
.e6d4  e0 20      cpx #$20                        cpx   #$20              ;  sp
.e6d6  d0 24      bne $e6fc                       bne   Asm_GoodSP2
.e6d8  c9 80      cmp #$80                        cmp   #$80
.e6da  30 f4      bmi $e6d0                       bmi   Asm_goodSP
.e6dc  a6 36      ldx $36          Asm_goodSP1    ldx   OpcTxtPtr         ; check if its a BBRx or BBSx opcode
.e6de  e0 44      cpx #$44                        cpx   #$44              ; 
.e6e0  10 ee      bpl $e6d0                       bpl   Asm_GoodSP        ;
.e6e2  a6 35      ldx $35                         ldx   HexDigCnt         ;
.e6e4  f0 ea      beq $e6d0                       beq   Asm_goodSP        ;
.e6e6  c9 d0      cmp #$d0                        cmp   #$D0              ; already have zp & rel?
.e6e8  10 e6      bpl $e6d0                       bpl   Asm_GoodSP        ; we don't care then
.e6ea  c9 c0      cmp #$c0                        cmp   #$C0              ; already got a zp address?
.e6ec  10 b5      bpl $e6a3                       bpl   Asm_Err2          ; then error
.e6ee  a6 3d      ldx $3d                         ldx   HexDigits+1
.e6f0  d0 b1      bne $e6a3                       bne   Asm_err2          ; not zero page
.e6f2  a6 3c      ldx $3c                         ldx   HexDigits
.e6f4  86 38      stx $38                         stx   startaddr         ; temp zp value for BBRx & BBSx cmds 
.e6f6  09 40      ora #$40                        ora   #$40              ; mark zp address fetched
.e6f8  29 f7      and #$f7                        and   #$F7              ; mask out zp address found
.e6fa  80 d4      bra $e6d0                       bra   Asm_goodSP        ; get next chr
.e6fc  e0 0d      cpx #$0d         Asm_goodSp2    cpx   #$0d              ;  CR
.e6fe  d0 03      bne $e703                       bne   Asm_eol
.e700  4c ba e7   jmp $e7ba        Asm_jmp1       jmp   Asm_modeSrch
.e703  e0 3b      cpx #$3b         Asm_eol        cpx   #$3b              ;  ";"
.e705  f0 f9      beq $e700                       beq   Asm_jmp1
.e707  48         pha                             pha
.e708  a5 36      lda $36                         lda   OpcTxtPtr
.e70a  c9 46      cmp #$46                        cmp   #$46              ; normal opcode if <=45h
.e70c  30 44      bmi $e752                       bmi   Asm_opnd1
.e70e  d0 19      bne $e729                       bne   Asm_xtra1
.e710  e0 24      cpx #$24                        cpx   #$24              ; $ .db pseudo-opcode
.e712  f0 01      beq $e715                       beq   Asm_db1
.e714  88         dey                             dey
.e715  20 7f e2   jsr $e27f        Asm_db1        jsr   ParseHexDig
.e718  fa         plx                             plx
.e719  a6 35      ldx $35                         ldx   HexDigCnt
.e71b  f0 86      beq $e6a3                       beq   Asm_err2          ; no digits retrieved
.e71d  a0 00      ldy #$00                        ldy   #$00
.e71f  a9 01      lda #$01                        lda   #$01
.e721  48         pha                             PHA
.e722  a5 3c      lda $3c                         lda   HexDigits
.e724  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e726  4c 55 e8   jmp $e855                       jmp   Asm_save
.e729  c9 47      cmp #$47         Asm_xtra1      cmp   #$47              ; .dw pseudo-opcode
.e72b  d0 1e      bne $e74b                       bne   Asm_xtra2 
.e72d  e0 24      cpx #$24                        cpx   #$24              ; $
.e72f  f0 01      beq $e732                       beq   Asm_dw1
.e731  88         dey                             dey
.e732  20 7f e2   jsr $e27f        Asm_dw1        jsr   ParseHexDig
.e735  fa         plx                             plx
.e736  a6 35      ldx $35                         ldx   HexDigCnt
.e738  f0 7d      beq $e7b7                       beq   Asm_err1          ; no digits retrieved
.e73a  a0 00      ldy #$00                        ldy   #$00
.e73c  a9 02      lda #$02                        lda   #$02
.e73e  48         pha                             PHA
.e73f  a5 3c      lda $3c                         lda   HexDigits
.e741  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e743  a5 3d      lda $3d                         lda   HexDigits+1
.e745  c8         iny                             iny
.e746  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e748  4c 55 e8   jmp $e855                       jmp   Asm_save
.e74b  c9 48      cmp #$48         Asm_xtra2      cmp   #$48              ; .ds pseudo-opcode
.e74d  d0 68      bne $e7b7                       bne   Asm_err1 
.e74f  4c 9b e8   jmp $e89b                       jmp   Asm_txt
.e752  68         pla              Asm_opnd1      pla
.e753  e0 23      cpx #$23                        cpx   #$23              ;  #    20
.e755  d0 05      bne $e75c                       bne   Asm_parse01
.e757  09 20      ora #$20                        ora   #$20
.e759  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP 
.e75c  e0 28      cpx #$28         Asm_parse01    cpx   #$28              ;  (   04
.e75e  d0 0b      bne $e76b                       bne   Asm_parse02
.e760  09 04      ora #$04                        ora   #$04
.e762  a6 34      ldx $34                         ldx   modeJmp
.e764  10 51      bpl $e7b7                       bpl   Asm_err1          ;  more than one ( 
.e766  e6 34      inc $34                         inc   ModeJmp
.e768  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP 
.e76b  e0 29      cpx #$29         Asm_parse02    cpx   #$29              ;  )
.e76d  d0 09      bne $e778                       bne   Asm_parse03
.e76f  a6 34      ldx $34                         ldx   ModeJmp
.e771  d0 44      bne $e7b7                       bne   Asm_err1          ;  ) without (
.e773  e6 34      inc $34                         inc   ModeJmp
.e775  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP 
.e778  e0 2c      cpx #$2c         Asm_parse03    cpx   #$2C              ;  ,
.e77a  d0 1e      bne $e79a                       bne   Asm_parse04
.e77c  be 00 03   ldx $0300,y                     ldx   buffer,y
.e77f  e0 58      cpx #$58                        cpx   #$58              ;  X        02
.e781  d0 06      bne $e789                       bne   Asm_parse31
.e783  09 02      ora #$02                        ora   #$02
.e785  c8         iny                             iny
.e786  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP
.e789  e0 59      cpx #$59         Asm_parse31    cpx   #$59              ;  Y        01 
.e78b  f0 07      beq $e794                       beq   Asm_parse32
.e78d  c9 80      cmp #$80                        cmp   #$80              ;  is BBRx or BBSx cmd active?
.e78f  30 26      bmi $e7b7                       bmi   Asm_err1          ;  , without X or Y or 4byte opcode      
.e791  4c dc e6   jmp $e6dc                       jmp   Asm_goodSP1       ;  save zp address
.e794  09 01      ora #$01         Asm_parse32    ora   #$01
.e796  c8         iny                             iny
.e797  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP 
.e79a  e0 24      cpx #$24         Asm_parse04    cpx   #$24              ;  $
.e79c  f0 01      beq $e79f                       beq   Asm_parse42       ;   
.e79e  88         dey                             dey                     ; not #$(),X,Y  so try Hexdig, if not err
.e79f  48         pha              Asm_parse42    pha
.e7a0  20 7f e2   jsr $e27f                       jsr   ParseHexDig
.e7a3  88         dey                             dey                     ; adjust input line pointer
.e7a4  68         pla                             pla
.e7a5  a6 35      ldx $35                         ldx   HexDigCnt
.e7a7  f0 0e      beq $e7b7                       beq   Asm_err1          ; no digits retrieved
.e7a9  a6 3d      ldx $3d                         ldx   HexDigits+1    
.e7ab  d0 05      bne $e7b2                       bne   Asm_parse41
.e7ad  09 08      ora #$08                        ora   #$08              ; <256               08
.e7af  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP
.e7b2  09 10      ora #$10         Asm_parse41    ora   #$10              ; 2 bytes            10 
.e7b4  4c d0 e6   jmp $e6d0                       jmp   Asm_goodSP 
.e7b7  4c 37 e6   jmp $e637        Asm_err1       jmp   Asm_Err
.e7ba  a2 0f      ldx #$0f         Asm_ModeSrch   ldx   #$0F              ; # of modes
.e7bc  dd 8b eb   cmp $eb8b,x      Asm_ModeS1     cmp   Asm_ModeLst,x
.e7bf  f0 05      beq $e7c6                       beq   Asm_ModeFnd 
.e7c1  ca         dex                             dex   
.e7c2  10 f8      bpl $e7bc                       bpl   Asm_ModeS1
.e7c4  80 f1      bra $e7b7                       bra   Asm_Err1          ; invalid Mode
.e7c6  86 37      stx $37          Asm_ModeFnd    stx   Memchr            ; save mode
.e7c8  c9 80      cmp #$80                        cmp   #$80              ; is it 4 chr opcode?
.e7ca  30 05      bmi $e7d1                       bmi   Asm_opcSrch       ;no
.e7cc  8a         txa                             txa
.e7cd  05 39      ora $39                         ora   startaddr_H       ; adjust the psuedo mode               
.e7cf  85 37      sta $37                         sta   Memchr            ; set proper mode
.e7d1  a2 00      ldx #$00         Asm_opcSrch    ldx   #$00
.e7d3  bd 5b e9   lda $e95b,x      Asm_opcSrch1   lda   OpcTxtidx,x
.e7d6  c5 36      cmp $36                         cmp   OpcTxtPtr
.e7d8  d0 07      bne $e7e1                       bne   Asm_srchNxt   
.e7da  bd 5b ea   lda $ea5b,x                     lda   OPCaddmode,x
.e7dd  c5 37      cmp $37                         cmp   Memchr
.e7df  f0 2d      beq $e80e                       beq   Asm_OpcFnd
.e7e1  e8         inx              Asm_srchNxt    inx
.e7e2  d0 ef      bne $e7d3                       bne   Asm_opcSrch1 
.e7e4  a5 37      lda $37                         lda   Memchr            ;
.e7e6  c9 02      cmp #$02                        cmp   #$02              ; ZP
.e7e8  d0 06      bne $e7f0                       bne   Asm_srchAlt 
.e7ea  a9 01      lda #$01                        LDA   #$01              ; ABS
.e7ec  85 37      sta $37                         sta   Memchr
.e7ee  80 e1      bra $e7d1                       bra   Asm_opcSrch
.e7f0  c9 01      cmp #$01         Asm_srchAlt    cmp   #$01              ; ABS
.e7f2  d0 06      bne $e7fa                       bne   Asm_srchA0
.e7f4  a9 0a      lda #$0a                        LDA   #$0A              ; REL
.e7f6  85 37      sta $37                         sta   Memchr
.e7f8  80 d7      bra $e7d1                       bra   Asm_opcSrch
.e7fa  c9 0d      cmp #$0d         Asm_srchA0     cmp   #$0d               ;  ind zp
.e7fc  d0 06      bne $e804                       bne   Asm_srchA1
.e7fe  a9 0b      lda #$0b                        LDA   #$0b              ; ind Abs
.e800  85 37      sta $37                         sta   Memchr
.e802  80 cd      bra $e7d1                       bra   Asm_opcSrch
.e804  c9 07      cmp #$07         Asm_SrchA1     cmp   #$07              ; zp,y
.e806  d0 af      bne $e7b7                       bne   Asm_Err1          ; no more modes to try, bad mode err
.e808  a9 09      lda #$09                        LDA   #$09              ; ABS,y
.e80a  85 37      sta $37                         sta   Memchr
.e80c  80 c3      bra $e7d1                       bra   Asm_opcSrch
.e80e  a5 37      lda $37          Asm_OpcFnd     lda   Memchr
.e810  29 0f      and #$0f                        and   #$0F              ; mask out psuedo modes
.e812  85 37      sta $37                         sta   Memchr            ;
.e814  c9 0e      cmp #$0e                        CMP   #$0E              ; BBR mode?
.e816  d0 0b      bne $e823                       bne   Asm_opcFnd0       ;
.e818  20 62 e8   jsr $e862                       jsr   Asm_BRelCalc      ;
.e81b  85 3d      sta $3d                         sta   HexDigits_H       ;
.e81d  a5 38      lda $38                         lda   Startaddr         ;
.e81f  85 3c      sta $3c                         sta   Hexdigits         ;
.e821  80 07      bra $e82a                       bra   Asm_OpcFnd1       ;   
.e823  c9 0a      cmp #$0a         Asm_OpcFnd0    cmp   #$0A              ; is Rel Mode?
.e825  d0 03      bne $e82a                       bne   Asm_OpcFnd1 
.e827  20 7a e8   jsr $e87a                       jsr   Asm_RelCalc       ; adjust rel address
.e82a  a0 00      ldy #$00         Asm_OpcFnd1    ldy   #$00
.e82c  8a         txa                             txa
.e82d  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e82f  c8         iny                             iny
.e830  a6 37      ldx $37                         ldx   Memchr            ; 
.e832  bd 5b eb   lda $eb5b,x                     lda   ModeByteCnt,x
.e835  48         pha                             PHA                     ; Save # of bytes
.e836  c9 01      cmp #$01                        cmp   #$01
.e838  f0 10      beq $e84a                       beq   Asm_EchoL
.e83a  a5 3c      lda $3c                         lda   HexDigits
.e83c  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e83e  c8         iny                             iny
.e83f  bd 5b eb   lda $eb5b,x                     lda   ModeByteCnt,x
.e842  c9 02      cmp #$02                        cmp   #$02
.e844  f0 04      beq $e84a                       beq   Asm_EchoL
.e846  a5 3d      lda $3d                         lda   HexDigits+1
.e848  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.e84a  a5 3a      lda $3a          Asm_EchoL      lda   AddrPtr
.e84c  85 38      sta $38                         sta   StartAddr
.e84e  a5 3b      lda $3b                         lda   AddrPtr+1
.e850  85 39      sta $39                         sta   StartAddr+1
.e852  20 81 e4   jsr $e481                       jsr   List_One
.e855  18         clc              Asm_Save       clc
.e856  68         pla                             PLA
.e857  65 3a      adc $3a                         adc   AddrPtr
.e859  85 3a      sta $3a                         sta   AddrPtr
.e85b  90 02      bcc $e85f                       bcc   Asm_done
.e85d  e6 3b      inc $3b                         inc   AddrPtr+1
.e85f  4c fb e5   jmp $e5fb        Asm_done       jmp   Assembler
.e862  20 69 e8   jsr $e869        Asm_BRelCalc   jsr   Asm_relsub
.e865  e9 03      sbc #$03                        sbc   #$03
.e867  80 16      bra $e87f                       bra   Asm_RelC1
.e869  38         sec              Asm_RelSub     sec
.e86a  a5 3c      lda $3c                         lda   Hexdigits
.e86c  e5 3a      sbc $3a                         sbc   AddrPtr
.e86e  85 3e      sta $3e                         sta   Memptr
.e870  a5 3d      lda $3d                         lda   Hexdigits+1
.e872  e5 3b      sbc $3b                         sbc   AddrPtr+1
.e874  85 3f      sta $3f                         sta   Memptr+1
.e876  38         sec                             sec
.e877  a5 3e      lda $3e                         lda   Memptr
.e879  60         rts                             rts 
.e87a  20 69 e8   jsr $e869        Asm_RelCalc    jsr   Asm_relsub
.e87d  e9 02      sbc #$02                        sbc   #$02
.e87f  85 3e      sta $3e          Asm_Relc1      sta   Memptr
.e881  b0 02      bcs $e885                       bcs   Asm_relC2
.e883  c6 3f      dec $3f                         dec   Memptr+1
.e885  a5 3f      lda $3f          Asm_relC2      lda   Memptr+1               
.e887  f0 0b      beq $e894                       beq   Asm_relC4         ; positive
.e889  c9 ff      cmp #$ff                        cmp   #$FF              ; negative
.e88b  d0 0b      bne $e898                       bne   Asm_txtErr
.e88d  a5 3e      lda $3e                         lda   Memptr
.e88f  10 07      bpl $e898                       bpl   Asm_txtErr
.e891  85 3c      sta $3c          Asm_relC3      sta   HexDigits
.e893  60         rts                             rts
.e894  a5 3e      lda $3e          Asm_relC4      lda   Memptr
.e896  10 f9      bpl $e891                       bpl   Asm_relC3
.e898  4c 37 e6   jmp $e637        Asm_txtErr     jmp   Asm_Err
.e89b  fa         plx              Asm_txt        plx                      ; process the .ds pseudo-opcode
.e89c  88         dey                             dey
.e89d  98         tya                             tya
.e89e  aa         tax                             tax
.e89f  a0 fe      ldy #$fe                        ldy   #$fe
.e8a1  c8         iny              Asm_txt1       iny
.e8a2  bd 00 03   lda $0300,x      Asm_txt2       lda   buffer,x           ; get next operand char
.e8a5  e8         inx                             inx                      ; point to next operand chr
.e8a6  c9 0d      cmp #$0d                        cmp   #$0d             ;  CR
.e8a8  f0 1a      beq $e8c4                       beq   Asm_txt9
.e8aa  c9 27      cmp #$27                        cmp   #$27             ; "
.e8ac  d0 06      bne $e8b4                       bne   Asm_txt3
.e8ae  c0 ff      cpy #$ff                        cpy   #$ff             ; opening " found?
.e8b0  d0 12      bne $e8c4                       bne   Asm_txt9         ; no, closing, so done
.e8b2  80 ed      bra $e8a1                       bra   Asm_txt1         ; yes, get first text chr
.e8b4  c0 ff      cpy #$ff         Asm_txt3       cpy   #$ff             ; already found opening "?
.e8b6  f0 04      beq $e8bc                       beq   Asm_txt4         ; 
.e8b8  91 3a      sta ($3a),y                     sta   (AddrPtr),y      ; yes, save chr
.e8ba  80 e5      bra $e8a1                       bra   Asm_txt1
.e8bc  c9 20      cmp #$20         Asm_txt4       cmp   #$20             ; no, if not a space, then err
.e8be  f0 e2      beq $e8a2                       beq   Asm_txt2
.e8c0  8a         txa                             txa
.e8c1  a8         tay                             tay
.e8c2  80 d4      bra $e898                       bra   Asm_txtErr
.e8c4  98         tya              Asm_txt9       tya
.e8c5  48         pha                             pha
.e8c6  4c 55 e8   jmp $e855                       jmp   Asm_save
.e8c9  a0 49      ldy #$49         Opcode_List    ldy   #$49              ; Number of Opcodes (64)
.e8cb  a2 00      ldx #$00                        ldx   #$00              ; pointer to characters
.e8cd  8a         txa              Opcode_List1   txa                     ; 
.e8ce  29 0f      and #$0f                        and   #$0F              ; Print CR after each 16 opcodes 
.e8d0  d0 03      bne $e8d5                       bne   Opcode_List2      ; not divisible by 16
.e8d2  20 5a e1   jsr $e15a                       jsr   Print_CR          ;
.e8d5  bd 9b eb   lda $eb9b,x      Opcode_List2   lda   OPCtxtData,x      ; get opcode chr data
.e8d8  20 06 e2   jsr $e206                       jsr   Output            ; print 1st char
.e8db  e8         inx                             inx                     ;
.e8dc  bd 9b eb   lda $eb9b,x                     lda   OPCtxtData,x      ; 
.e8df  20 06 e2   jsr $e206                       jsr   Output            ; print 2nd char
.e8e2  e8         inx                             inx                     ;
.e8e3  bd 9b eb   lda $eb9b,x                     lda   OPCtxtData,x      ;
.e8e6  20 06 e2   jsr $e206                       jsr   Output            ; print 3rd char
.e8e9  e8         inx                             inx                     ;
.e8ea  c0 08      cpy #$08                        cpy   #$08              ; 
.e8ec  10 09      bpl $e8f7                       bpl   Opcode_List3      ; not 4 byte code
.e8ee  c0 04      cpy #$04                        cpy   #$04              ;
.e8f0  30 05      bmi $e8f7                       bmi   Opcode_list3      ;
.e8f2  a9 78      lda #$78                        lda   #$78              ; add 'x'
.e8f4  20 06 e2   jsr $e206                       jsr   output            ; for RMBx, SMBx,BBRx, & BBSx
.e8f7  a9 20      lda #$20         Opcode_List3   lda   #$20              ; print space
.e8f9  20 06 e2   jsr $e206                       jsr   Output            ;
.e8fc  88         dey                             dey                     ;
.e8fd  d0 ce      bne $e8cd                       bne   Opcode_List1      ; 
.e8ff  20 5a e1   jsr $e15a                       jsr   Print_CR          ; one last CR-LF
.e902  60         rts                             rts                     ;

>e903  30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  Hexdigdata     .byte "0123456789ABCDEF";hex char table 
>e913  0d                          CmdAscii       .byte $0D               ; 0 enter    cmd codes
>e914  20                                         .byte $20               ; 1 SPACE
>e915  2e                                         .byte $2E               ; 2 .
>e916  3a                                         .byte $3A               ; 3 :
>e917  3e                                         .byte $3E               ; 4 >  
>e918  3f                                         .byte $3f               ; 5 ? - Help
>e919  21                                         .byte $21               ; 6 ! - Assembler
>e91a  47                                         .byte $47               ; 7 g - Go
>e91b  49                                         .byte $49               ; 8 i - Insert
>e91c  4c                                         .byte $4C               ; 9 l - List
>e91d  4d                                         .byte $4D               ; A m - Move
>e91e  51                                         .byte $51               ; B q - Query memory (text dump)
>e91f  52                                         .byte $52               ; C r - Registers
>e920  40                                         .byte $40               ; D @ - Cold Start Basic
>e921  23                                         .byte $23               ; E # - Warm Start Basic
>e922  55                          		   .byte $55		   ; F U - Uploader
>e923  56                                         .byte $56               ;10 v - Version
>e924  57                                         .byte $57               ;11 w - "(W)rite" eeprom
>e925  e6 e2                       Cmdjmptbl      .word CR_cmd            ; 0  enter   cmd jmp table
>e927  f6 e2                                      .word SP_cmd            ; 1   space
>e929  db e2                                      .word DOT_cmd           ; 2    .
>e92b  db e2                                      .word DOT_cmd           ; 3    :
>e92d  21 e4                                      .word Dest_cmd          ; 4    >  
>e92f  a0 e2                                      .word Help_Cmd          ; 5    ?
>e931  cd e5                                      .word Assem_init        ; 6    !
>e933  cf e2                                      .word Excute_cmd        ; 7    g
>e935  77 e3                                      .word Insert_Cmd        ; 8    i
>e937  2a e4                                      .word LIST_cmd          ; 9    l
>e939  ba e3                                      .word Move_cmd          ; A    m
>e93b  55 e3                                      .word TXT_cmd           ; B    q
>e93d  23 e1                                      .word Printreg          ; C    r
>e93f  00 90                                      .word LAB_COLD             ; D    @
>e941  00 00                                      .word $0000             ; E    #
>e943  cb f4                                      .word xmodem            ; F    u
>e945  be e2                                      .word Version           ;10    v
>e947  e9 e3                                      .word EEPROM_WR         ;11    w  
>e949  00                          Cmdseccode     .byte $00               ; 0   enter       secondary command table
>e94a  ff                                         .byte $FF               ; 1   sp
>e94b  01                                         .byte $01               ; 2   .
>e94c  02                                         .byte $02               ; 3   :
>e94d  00                                         .byte $00               ; 4   > 
>e94e  00                                         .byte $00               ; 5   ?
>e94f  00                                         .byte $00               ; 6   !
>e950  00                                         .byte $00               ; 7   g
>e951  00                                         .byte $00               ; 8   i
>e952  00                                         .byte $00               ; 9   l
>e953  00                                         .byte $00               ; A   m
>e954  00                                         .byte $00               ; B   q
>e955  00                                         .byte $00               ; C   r
>e956  00                                         .byte $00               ; D   @
>e957  00                                         .byte $00               ; E   #
>e958  00                                         .byte $00               ; F   u
>e959  00                                         .byte $00               ;10   v
>e95a  00                                         .byte $00               ;11   w
>e95b  0b                          OPCtxtidx      .byte $0B               ;0   operand text index
>e95c  23                                         .byte $23               ;1
>e95d  49                                         .byte $49               ;2
>e95e  49                                         .byte $49               ;3
>e95f  3b                                         .byte $3B               ;4
>e960  23                                         .byte $23               ;5
>e961  02                                         .byte $02               ;6
>e962  44                                         .byte $44               ;7
>e963  25                                         .byte $25               ;8
>e964  23                                         .byte $23               ;9
>e965  02                                         .byte $02               ;A
>e966  49                                         .byte $49               ;B
>e967  3b                                         .byte $3B               ;C
>e968  23                                         .byte $23               ;D
>e969  02                                         .byte $02               ;E
>e96a  42                                         .byte $42               ;F
>e96b  09                                         .byte $09               ;10
>e96c  23                                         .byte $23               ;11
>e96d  23                                         .byte $23               ;12
>e96e  49                                         .byte $49               ;13
>e96f  3a                                         .byte $3A               ;14
>e970  23                                         .byte $23               ;15
>e971  02                                         .byte $02               ;16
>e972  44                                         .byte $44               ;17
>e973  0e                                         .byte $0E               ;18
>e974  23                                         .byte $23               ;19
>e975  19                                         .byte $19               ;1A
>e976  49                                         .byte $49               ;1B
>e977  3a                                         .byte $3A               ;1C
>e978  23                                         .byte $23               ;1D
>e979  02                                         .byte $02               ;1E
>e97a  42                                         .byte $42               ;1F
>e97b  1d                                         .byte $1D               ;20
>e97c  01                                         .byte $01               ;21
>e97d  49                                         .byte $49               ;22
>e97e  49                                         .byte $49               ;23
>e97f  06                                         .byte $06               ;24
>e980  01                                         .byte $01               ;25
>e981  2c                                         .byte $2C               ;26
>e982  44                                         .byte $44               ;27
>e983  29                                         .byte $29               ;28
>e984  01                                         .byte $01               ;29
>e985  2c                                         .byte $2C               ;2A
>e986  49                                         .byte $49               ;2B
>e987  06                                         .byte $06               ;2C
>e988  01                                         .byte $01               ;2D
>e989  2c                                         .byte $2C               ;2E
>e98a  42                                         .byte $42               ;2F
>e98b  07                                         .byte $07               ;30
>e98c  01                                         .byte $01               ;31
>e98d  01                                         .byte $01               ;32
>e98e  49                                         .byte $49               ;33
>e98f  06                                         .byte $06               ;34
>e990  01                                         .byte $01               ;35
>e991  2c                                         .byte $2C               ;36
>e992  44                                         .byte $44               ;37
>e993  31                                         .byte $31               ;38
>e994  01                                         .byte $01               ;39
>e995  15                                         .byte $15               ;3A
>e996  49                                         .byte $49               ;3B
>e997  06                                         .byte $06               ;3C
>e998  01                                         .byte $01               ;3D
>e999  2c                                         .byte $2C               ;3E
>e99a  42                                         .byte $42               ;3F
>e99b  2e                                         .byte $2E               ;40
>e99c  18                                         .byte $18               ;41
>e99d  49                                         .byte $49               ;42
>e99e  49                                         .byte $49               ;43
>e99f  49                                         .byte $49               ;44
>e9a0  18                                         .byte $18               ;45
>e9a1  21                                         .byte $21               ;46
>e9a2  44                                         .byte $44               ;47
>e9a3  24                                         .byte $24               ;48
>e9a4  18                                         .byte $18               ;49
>e9a5  21                                         .byte $21               ;4A
>e9a6  49                                         .byte $49               ;4B
>e9a7  1c                                         .byte $1C               ;4C
>e9a8  18                                         .byte $18               ;4D
>e9a9  21                                         .byte $21               ;4E
>e9aa  42                                         .byte $42               ;4F
>e9ab  0c                                         .byte $0C               ;50
>e9ac  18                                         .byte $18               ;51
>e9ad  18                                         .byte $18               ;52
>e9ae  49                                         .byte $49               ;53
>e9af  49                                         .byte $49               ;54
>e9b0  18                                         .byte $18               ;55
>e9b1  21                                         .byte $21               ;56
>e9b2  44                                         .byte $44               ;57
>e9b3  10                                         .byte $10               ;58
>e9b4  18                                         .byte $18               ;59
>e9b5  27                                         .byte $27               ;5A
>e9b6  49                                         .byte $49               ;5B
>e9b7  49                                         .byte $49               ;5C
>e9b8  18                                         .byte $18               ;5D
>e9b9  21                                         .byte $21               ;5E
>e9ba  42                                         .byte $42               ;5F
>e9bb  2f                                         .byte $2F               ;60
>e9bc  00                                         .byte $00               ;61
>e9bd  49                                         .byte $49               ;62
>e9be  49                                         .byte $49               ;63
>e9bf  37                                         .byte $37               ;64
>e9c0  00                                         .byte $00               ;65
>e9c1  2d                                         .byte $2D               ;66
>e9c2  44                                         .byte $44               ;67
>e9c3  28                                         .byte $28               ;68
>e9c4  00                                         .byte $00               ;69
>e9c5  2d                                         .byte $2D               ;6A
>e9c6  49                                         .byte $49               ;6B
>e9c7  1c                                         .byte $1C               ;6C
>e9c8  00                                         .byte $00               ;6D
>e9c9  2d                                         .byte $2D               ;6E
>e9ca  42                                         .byte $42               ;6F
>e9cb  0d                                         .byte $0D               ;70
>e9cc  00                                         .byte $00               ;71
>e9cd  00                                         .byte $00               ;72
>e9ce  49                                         .byte $49               ;73
>e9cf  37                                         .byte $37               ;74
>e9d0  00                                         .byte $00               ;75
>e9d1  2d                                         .byte $2D               ;76
>e9d2  44                                         .byte $44               ;77
>e9d3  33                                         .byte $33               ;78
>e9d4  00                                         .byte $00               ;79
>e9d5  2b                                         .byte $2B               ;7A
>e9d6  49                                         .byte $49               ;7B
>e9d7  1c                                         .byte $1C               ;7C
>e9d8  00                                         .byte $00               ;7D
>e9d9  2d                                         .byte $2D               ;7E
>e9da  42                                         .byte $42               ;7F
>e9db  0a                                         .byte $0A               ;80
>e9dc  34                                         .byte $34               ;81
>e9dd  49                                         .byte $49               ;82
>e9de  49                                         .byte $49               ;83
>e9df  36                                         .byte $36               ;84
>e9e0  34                                         .byte $34               ;85
>e9e1  35                                         .byte $35               ;86
>e9e2  45                                         .byte $45               ;87
>e9e3  17                                         .byte $17               ;88
>e9e4  06                                         .byte $06               ;89
>e9e5  3d                                         .byte $3D               ;8A
>e9e6  49                                         .byte $49               ;8B
>e9e7  36                                         .byte $36               ;8C
>e9e8  34                                         .byte $34               ;8D
>e9e9  35                                         .byte $35               ;8E
>e9ea  43                                         .byte $43               ;8F
>e9eb  03                                         .byte $03               ;90
>e9ec  34                                         .byte $34               ;91
>e9ed  34                                         .byte $34               ;92
>e9ee  49                                         .byte $49               ;93
>e9ef  36                                         .byte $36               ;94
>e9f0  34                                         .byte $34               ;95
>e9f1  35                                         .byte $35               ;96
>e9f2  45                                         .byte $45               ;97
>e9f3  3f                                         .byte $3F               ;98
>e9f4  34                                         .byte $34               ;99
>e9f5  3e                                         .byte $3E               ;9A
>e9f6  49                                         .byte $49               ;9B
>e9f7  37                                         .byte $37               ;9C
>e9f8  34                                         .byte $34               ;9D
>e9f9  37                                         .byte $37               ;9E
>e9fa  43                                         .byte $43               ;9F
>e9fb  20                                         .byte $20               ;A0
>e9fc  1e                                         .byte $1E               ;A1
>e9fd  1f                                         .byte $1F               ;A2
>e9fe  49                                         .byte $49               ;A3
>e9ff  20                                         .byte $20               ;A4
>ea00  1e                                         .byte $1E               ;A5
>ea01  1f                                         .byte $1F               ;A6
>ea02  45                                         .byte $45               ;A7
>ea03  39                                         .byte $39               ;A8
>ea04  1e                                         .byte $1E               ;A9
>ea05  38                                         .byte $38               ;AA
>ea06  49                                         .byte $49               ;AB
>ea07  20                                         .byte $20               ;AC
>ea08  1e                                         .byte $1E               ;AD
>ea09  1f                                         .byte $1F               ;AE
>ea0a  43                                         .byte $43               ;AF
>ea0b  04                                         .byte $04               ;B0
>ea0c  1e                                         .byte $1E               ;B1
>ea0d  1e                                         .byte $1E               ;B2
>ea0e  49                                         .byte $49               ;B3
>ea0f  20                                         .byte $20               ;B4
>ea10  1e                                         .byte $1E               ;B5
>ea11  1f                                         .byte $1F               ;B6
>ea12  45                                         .byte $45               ;B7
>ea13  11                                         .byte $11               ;B8
>ea14  1e                                         .byte $1E               ;B9
>ea15  3c                                         .byte $3C               ;BA
>ea16  49                                         .byte $49               ;BB
>ea17  20                                         .byte $20               ;BC
>ea18  1e                                         .byte $1E               ;BD
>ea19  1f                                         .byte $1F               ;BE
>ea1a  43                                         .byte $43               ;BF
>ea1b  14                                         .byte $14               ;C0
>ea1c  12                                         .byte $12               ;C1
>ea1d  49                                         .byte $49               ;C2
>ea1e  49                                         .byte $49               ;C3
>ea1f  14                                         .byte $14               ;C4
>ea20  12                                         .byte $12               ;C5
>ea21  15                                         .byte $15               ;C6
>ea22  45                                         .byte $45               ;C7
>ea23  1b                                         .byte $1B               ;C8
>ea24  12                                         .byte $12               ;C9
>ea25  16                                         .byte $16               ;CA
>ea26  40                                         .byte $40               ;CB
>ea27  14                                         .byte $14               ;CC
>ea28  12                                         .byte $12               ;CD
>ea29  15                                         .byte $15               ;CE
>ea2a  43                                         .byte $43               ;CF
>ea2b  08                                         .byte $08               ;D0
>ea2c  12                                         .byte $12               ;D1
>ea2d  12                                         .byte $12               ;D2
>ea2e  49                                         .byte $49               ;D3
>ea2f  49                                         .byte $49               ;D4
>ea30  12                                         .byte $12               ;D5
>ea31  15                                         .byte $15               ;D6
>ea32  45                                         .byte $45               ;D7
>ea33  0f                                         .byte $0F               ;D8
>ea34  12                                         .byte $12               ;D9
>ea35  26                                         .byte $26               ;DA
>ea36  41                                         .byte $41               ;DB
>ea37  49                                         .byte $49               ;DC
>ea38  12                                         .byte $12               ;DD
>ea39  15                                         .byte $15               ;DE
>ea3a  43                                         .byte $43               ;DF
>ea3b  13                                         .byte $13               ;E0
>ea3c  30                                         .byte $30               ;E1
>ea3d  49                                         .byte $49               ;E2
>ea3e  49                                         .byte $49               ;E3
>ea3f  13                                         .byte $13               ;E4
>ea40  30                                         .byte $30               ;E5
>ea41  19                                         .byte $19               ;E6
>ea42  45                                         .byte $45               ;E7
>ea43  1a                                         .byte $1A               ;E8
>ea44  30                                         .byte $30               ;E9
>ea45  22                                         .byte $22               ;EA
>ea46  49                                         .byte $49               ;EB
>ea47  13                                         .byte $13               ;EC
>ea48  30                                         .byte $30               ;ED
>ea49  19                                         .byte $19               ;EE
>ea4a  43                                         .byte $43               ;EF
>ea4b  05                                         .byte $05               ;F0
>ea4c  30                                         .byte $30               ;F1
>ea4d  30                                         .byte $30               ;F2
>ea4e  49                                         .byte $49               ;F3
>ea4f  49                                         .byte $49               ;F4
>ea50  30                                         .byte $30               ;F5
>ea51  19                                         .byte $19               ;F6
>ea52  45                                         .byte $45               ;F7
>ea53  32                                         .byte $32               ;F8
>ea54  30                                         .byte $30               ;F9
>ea55  2a                                         .byte $2A               ;FA
>ea56  49                                         .byte $49               ;FB
>ea57  49                                         .byte $49               ;FC
>ea58  30                                         .byte $30               ;FD
>ea59  19                                         .byte $19               ;FE
>ea5a  43                                         .byte $43               ;FF
>ea5b  03                          OPCaddmode     .byte $03               ;0   opcode address mode
>ea5c  04                                         .byte $04               ;1
>ea5d  03                                         .byte $03               ;2
>ea5e  03                                         .byte $03               ;3
>ea5f  02                                         .byte $02               ;4
>ea60  02                                         .byte $02               ;5
>ea61  02                                         .byte $02               ;6
>ea62  0f                                         .byte $0F               ;7
>ea63  03                                         .byte $03               ;8
>ea64  00                                         .byte $00               ;9
>ea65  03                                         .byte $03               ;A
>ea66  03                                         .byte $03               ;B
>ea67  01                                         .byte $01               ;C
>ea68  01                                         .byte $01               ;D
>ea69  01                                         .byte $01               ;E
>ea6a  0e                                         .byte $0E               ;F
>ea6b  0a                                         .byte $0A               ;10
>ea6c  05                                         .byte $05               ;11
>ea6d  0d                                         .byte $0D               ;12
>ea6e  03                                         .byte $03               ;13
>ea6f  02                                         .byte $02               ;14
>ea70  06                                         .byte $06               ;15
>ea71  06                                         .byte $06               ;16
>ea72  1f                                         .byte $1F               ;17
>ea73  03                                         .byte $03               ;18
>ea74  09                                         .byte $09               ;19
>ea75  03                                         .byte $03               ;1A
>ea76  03                                         .byte $03               ;1B
>ea77  01                                         .byte $01               ;1C
>ea78  08                                         .byte $08               ;1D
>ea79  08                                         .byte $08               ;1E
>ea7a  1e                                         .byte $1E               ;1F
>ea7b  01                                         .byte $01               ;20
>ea7c  04                                         .byte $04               ;21
>ea7d  03                                         .byte $03               ;22
>ea7e  03                                         .byte $03               ;23
>ea7f  02                                         .byte $02               ;24
>ea80  02                                         .byte $02               ;25
>ea81  02                                         .byte $02               ;26
>ea82  2f                                         .byte $2F               ;27
>ea83  03                                         .byte $03               ;28
>ea84  00                                         .byte $00               ;29
>ea85  03                                         .byte $03               ;2A
>ea86  03                                         .byte $03               ;2B
>ea87  01                                         .byte $01               ;2C
>ea88  01                                         .byte $01               ;2D
>ea89  01                                         .byte $01               ;2E
>ea8a  2e                                         .byte $2E               ;2F
>ea8b  0a                                         .byte $0A               ;30
>ea8c  05                                         .byte $05               ;31
>ea8d  0d                                         .byte $0D               ;32
>ea8e  03                                         .byte $03               ;33
>ea8f  06                                         .byte $06               ;34
>ea90  06                                         .byte $06               ;35
>ea91  06                                         .byte $06               ;36
>ea92  3f                                         .byte $3F               ;37
>ea93  03                                         .byte $03               ;38
>ea94  09                                         .byte $09               ;39
>ea95  03                                         .byte $03               ;3A
>ea96  03                                         .byte $03               ;3B
>ea97  08                                         .byte $08               ;3C
>ea98  08                                         .byte $08               ;3D
>ea99  08                                         .byte $08               ;3E
>ea9a  3e                                         .byte $3E               ;3F
>ea9b  03                                         .byte $03               ;40
>ea9c  04                                         .byte $04               ;41
>ea9d  03                                         .byte $03               ;42
>ea9e  03                                         .byte $03               ;43
>ea9f  03                                         .byte $03               ;44
>eaa0  02                                         .byte $02               ;45
>eaa1  02                                         .byte $02               ;46
>eaa2  4f                                         .byte $4F               ;47
>eaa3  03                                         .byte $03               ;48
>eaa4  00                                         .byte $00               ;49
>eaa5  03                                         .byte $03               ;4A
>eaa6  03                                         .byte $03               ;4B
>eaa7  01                                         .byte $01               ;4C
>eaa8  01                                         .byte $01               ;4D
>eaa9  01                                         .byte $01               ;4E
>eaaa  4e                                         .byte $4E               ;4F
>eaab  0a                                         .byte $0A               ;50
>eaac  05                                         .byte $05               ;51
>eaad  0d                                         .byte $0D               ;52
>eaae  03                                         .byte $03               ;53
>eaaf  03                                         .byte $03               ;54
>eab0  06                                         .byte $06               ;55
>eab1  06                                         .byte $06               ;56
>eab2  5f                                         .byte $5F               ;57
>eab3  03                                         .byte $03               ;58
>eab4  09                                         .byte $09               ;59
>eab5  03                                         .byte $03               ;5A
>eab6  03                                         .byte $03               ;5B
>eab7  03                                         .byte $03               ;5C
>eab8  08                                         .byte $08               ;5D
>eab9  08                                         .byte $08               ;5E
>eaba  5e                                         .byte $5E               ;5F
>eabb  03                                         .byte $03               ;60
>eabc  04                                         .byte $04               ;61
>eabd  03                                         .byte $03               ;62
>eabe  03                                         .byte $03               ;63
>eabf  02                                         .byte $02               ;64
>eac0  02                                         .byte $02               ;65
>eac1  02                                         .byte $02               ;66
>eac2  6f                                         .byte $6F               ;67
>eac3  03                                         .byte $03               ;68
>eac4  00                                         .byte $00               ;69
>eac5  03                                         .byte $03               ;6A
>eac6  03                                         .byte $03               ;6B
>eac7  0b                                         .byte $0B               ;6C
>eac8  01                                         .byte $01               ;6D
>eac9  01                                         .byte $01               ;6E
>eaca  6e                                         .byte $6E               ;6F
>eacb  0a                                         .byte $0A               ;70
>eacc  05                                         .byte $05               ;71
>eacd  0d                                         .byte $0D               ;72
>eace  03                                         .byte $03               ;73
>eacf  06                                         .byte $06               ;74
>ead0  06                                         .byte $06               ;75
>ead1  06                                         .byte $06               ;76
>ead2  7f                                         .byte $7F               ;77
>ead3  03                                         .byte $03               ;78
>ead4  09                                         .byte $09               ;79
>ead5  03                                         .byte $03               ;7A
>ead6  03                                         .byte $03               ;7B
>ead7  0c                                         .byte $0C               ;7C
>ead8  08                                         .byte $08               ;7D
>ead9  08                                         .byte $08               ;7E
>eada  7e                                         .byte $7E               ;7F
>eadb  0a                                         .byte $0A               ;80
>eadc  04                                         .byte $04               ;81
>eadd  03                                         .byte $03               ;82
>eade  03                                         .byte $03               ;83
>eadf  02                                         .byte $02               ;84
>eae0  02                                         .byte $02               ;85
>eae1  02                                         .byte $02               ;86
>eae2  0f                                         .byte $0F               ;87
>eae3  03                                         .byte $03               ;88
>eae4  00                                         .byte $00               ;89
>eae5  03                                         .byte $03               ;8A
>eae6  03                                         .byte $03               ;8B
>eae7  01                                         .byte $01               ;8C
>eae8  01                                         .byte $01               ;8D
>eae9  01                                         .byte $01               ;8E
>eaea  0e                                         .byte $0E               ;8F
>eaeb  0a                                         .byte $0A               ;90
>eaec  05                                         .byte $05               ;91
>eaed  0d                                         .byte $0D               ;92
>eaee  03                                         .byte $03               ;93
>eaef  06                                         .byte $06               ;94
>eaf0  06                                         .byte $06               ;95
>eaf1  07                                         .byte $07               ;96
>eaf2  1f                                         .byte $1F               ;97
>eaf3  03                                         .byte $03               ;98
>eaf4  09                                         .byte $09               ;99
>eaf5  03                                         .byte $03               ;9A
>eaf6  03                                         .byte $03               ;9B
>eaf7  01                                         .byte $01               ;9C
>eaf8  08                                         .byte $08               ;9D
>eaf9  08                                         .byte $08               ;9E
>eafa  1e                                         .byte $1E               ;9F
>eafb  00                                         .byte $00               ;A0
>eafc  04                                         .byte $04               ;A1    changed from 0d to 04
>eafd  00                                         .byte $00               ;A2
>eafe  03                                         .byte $03               ;A3
>eaff  02                                         .byte $02               ;A4
>eb00  02                                         .byte $02               ;A5
>eb01  02                                         .byte $02               ;A6
>eb02  2f                                         .byte $2F               ;A7
>eb03  03                                         .byte $03               ;A8
>eb04  00                                         .byte $00               ;A9
>eb05  03                                         .byte $03               ;AA
>eb06  03                                         .byte $03               ;AB
>eb07  01                                         .byte $01               ;AC
>eb08  01                                         .byte $01               ;AD
>eb09  01                                         .byte $01               ;AE
>eb0a  2e                                         .byte $2E               ;AF
>eb0b  0a                                         .byte $0A               ;B0
>eb0c  05                                         .byte $05               ;B1
>eb0d  0d                                         .byte $0D               ;B2     
>eb0e  03                                         .byte $03               ;B3
>eb0f  06                                         .byte $06               ;B4
>eb10  06                                         .byte $06               ;B5
>eb11  07                                         .byte $07               ;B6
>eb12  3f                                         .byte $3F               ;B7
>eb13  03                                         .byte $03               ;B8
>eb14  09                                         .byte $09               ;B9
>eb15  03                                         .byte $03               ;BA
>eb16  03                                         .byte $03               ;BB
>eb17  08                                         .byte $08               ;BC
>eb18  08                                         .byte $08               ;BD
>eb19  09                                         .byte $09               ;BE
>eb1a  3e                                         .byte $3E               ;BF
>eb1b  00                                         .byte $00               ;C0
>eb1c  04                                         .byte $04               ;C1
>eb1d  03                                         .byte $03               ;C2
>eb1e  03                                         .byte $03               ;C3
>eb1f  02                                         .byte $02               ;C4
>eb20  02                                         .byte $02               ;C5
>eb21  02                                         .byte $02               ;C6
>eb22  4f                                         .byte $4F               ;C7
>eb23  03                                         .byte $03               ;C8
>eb24  00                                         .byte $00               ;C9
>eb25  03                                         .byte $03               ;CA
>eb26  03                                         .byte $03               ;CB
>eb27  01                                         .byte $01               ;CC
>eb28  01                                         .byte $01               ;CD
>eb29  01                                         .byte $01               ;CE
>eb2a  4e                                         .byte $4E               ;CF
>eb2b  0a                                         .byte $0A               ;D0
>eb2c  05                                         .byte $05               ;D1
>eb2d  0d                                         .byte $0D               ;D2
>eb2e  03                                         .byte $03               ;D3
>eb2f  03                                         .byte $03               ;D4
>eb30  06                                         .byte $06               ;D5
>eb31  06                                         .byte $06               ;D6
>eb32  5f                                         .byte $5F               ;D7
>eb33  03                                         .byte $03               ;D8
>eb34  09                                         .byte $09               ;D9
>eb35  03                                         .byte $03               ;DA
>eb36  03                                         .byte $03               ;DB
>eb37  03                                         .byte $03               ;DC
>eb38  08                                         .byte $08               ;DD
>eb39  08                                         .byte $08               ;DE
>eb3a  5e                                         .byte $5E               ;DF
>eb3b  00                                         .byte $00               ;E0
>eb3c  04                                         .byte $04               ;E1
>eb3d  03                                         .byte $03               ;E2
>eb3e  03                                         .byte $03               ;E3
>eb3f  02                                         .byte $02               ;E4
>eb40  02                                         .byte $02               ;E5
>eb41  02                                         .byte $02               ;E6
>eb42  6f                                         .byte $6F               ;E7
>eb43  03                                         .byte $03               ;E8
>eb44  00                                         .byte $00               ;E9
>eb45  03                                         .byte $03               ;EA
>eb46  03                                         .byte $03               ;EB
>eb47  01                                         .byte $01               ;EC
>eb48  01                                         .byte $01               ;ED
>eb49  01                                         .byte $01               ;EE
>eb4a  6e                                         .byte $6E               ;EF
>eb4b  0a                                         .byte $0A               ;F0
>eb4c  05                                         .byte $05               ;F1
>eb4d  0d                                         .byte $0D               ;F2
>eb4e  03                                         .byte $03               ;F3
>eb4f  03                                         .byte $03               ;F4
>eb50  06                                         .byte $06               ;F5
>eb51  06                                         .byte $06               ;F6
>eb52  7f                                         .byte $7F               ;F7
>eb53  03                                         .byte $03               ;F8
>eb54  09                                         .byte $09               ;F9
>eb55  03                                         .byte $03               ;FA
>eb56  03                                         .byte $03               ;FB
>eb57  03                                         .byte $03               ;FC
>eb58  08                                         .byte $08               ;FD
>eb59  08                                         .byte $08               ;FE
>eb5a  7e                                         .byte $7E               ;FF
>eb5b  02                          ModeByteCnt    .byte $02               ;0  opcode mode byte count
>eb5c  03                                         .byte $03               ;1
>eb5d  02                                         .byte $02               ;2
>eb5e  01                                         .byte $01               ;3
>eb5f  02                                         .byte $02               ;4
>eb60  02                                         .byte $02               ;5
>eb61  02                                         .byte $02               ;6
>eb62  02                                         .byte $02               ;7
>eb63  03                                         .byte $03               ;8
>eb64  03                                         .byte $03               ;9
>eb65  02                                         .byte $02               ;A
>eb66  03                                         .byte $03               ;B
>eb67  03                                         .byte $03               ;C
>eb68  02                                         .byte $02               ;D
>eb69  03                                         .byte $03               ;E
>eb6a  02                                         .byte $02               ;F 
>eb6b  16 e5                       ModeJmpTbl     .word IMM_mode          ;0  Operand print table
>eb6d  5c e5                                      .word ABS_mode          ;1
>eb6f  1b e5                                      .word ZP_mode           ;2
>eb71  86 e5                                      .word IMPLIED_mode      ;3
>eb73  4c e5                                      .word INDZP_X_mode      ;4
>eb75  57 e5                                      .word INDZP_Y_mode      ;5
>eb77  27 e5                                      .word ZP_X_mode         ;6
>eb79  34 e5                                      .word ZP_Y_mode         ;7
>eb7b  69 e5                                      .word ABS_X_mode        ;8
>eb7d  6e e5                                      .word ABS_Y_mode        ;9
>eb7f  a7 e5                                      .word REL_mode          ;a
>eb81  73 e5                                      .word INDABS_mode       ;b
>eb83  7b e5                                      .word INDABSX_mode      ;c
>eb85  41 e5                                      .word INDZP_mode        ;d
>eb87  8c e5                       		   .word BBREL_mode        ;e
>eb89  1b e5                                      .word ZP_mode           ;f  dup of ZP for RMB,SMB cmds
>eb8b  28                          Asm_ModeLst    .byte $28               ;0 IMM_mode
>eb8c  10                                         .byte $10               ;1 ABS_mode
>eb8d  08                                         .byte $08               ;2 ZP_mode
>eb8e  00                                         .byte $00               ;3 IMPLIED_mode
>eb8f  0e                                         .byte $0E               ;4 INDZP_X_mode
>eb90  0d                                         .byte $0D               ;5 INDZP_Y_mode
>eb91  0a                                         .byte $0A               ;6 ZP_X_mode
>eb92  09                                         .byte $09               ;7 ZP_Y_mode
>eb93  12                                         .byte $12               ;8 ABS_X_mode
>eb94  11                                         .byte $11               ;9 ABS_Y_mode
>eb95  40                                         .byte $40               ;A REL_mode   Never set!!!
>eb96  14                                         .byte $14               ;B INDABS_mode
>eb97  16                                         .byte $16               ;C INDABSX_mode
>eb98  0c                                         .byte $0C               ;D INDZP_mode
>eb99  d0                                         .byte $D0               ;E BBREL_mode
>eb9a  88                                         .byte $88               ;F used for RMBx & SMBx 
>eb9b  41 44 43                    OPCtxtData     .byte "ADC"             ;0
>eb9e  41 4e 44                                   .byte "AND"             ;1
>eba1  41 53 4c                                   .byte "ASL"             ;2
>eba4  42 43 43                                   .byte "BCC"             ;3
>eba7  42 43 53                                   .byte "BCS"             ;4
>ebaa  42 45 51                                   .byte "BEQ"             ;5
>ebad  42 49 54                                   .byte "BIT"             ;6
>ebb0  42 4d 49                                   .byte "BMI"             ;7
>ebb3  42 4e 45                                   .byte "BNE"             ;8
>ebb6  42 50 4c                                   .byte "BPL"             ;9
>ebb9  42 52 41                                   .byte "BRA"             ;A
>ebbc  42 52 4b                                   .byte "BRK"             ;B
>ebbf  42 56 43                                   .byte "BVC"             ;C
>ebc2  42 56 53                                   .byte "BVS"             ;D
>ebc5  43 4c 43                                   .byte "CLC"             ;E
>ebc8  43 4c 44                                   .byte "CLD"             ;F
>ebcb  43 4c 49                                   .byte "CLI"             ;10
>ebce  43 4c 56                                   .byte "CLV"             ;11
>ebd1  43 4d 50                                   .byte "CMP"             ;12
>ebd4  43 50 58                                   .byte "CPX"             ;13
>ebd7  43 50 59                                   .byte "CPY"             ;14
>ebda  44 45 43                                   .byte "DEC"             ;15
>ebdd  44 45 58                                   .byte "DEX"             ;16
>ebe0  44 45 59                                   .byte "DEY"             ;17
>ebe3  45 4f 52                                   .byte "EOR"             ;18
>ebe6  49 4e 43                                   .byte "INC"             ;19
>ebe9  49 4e 58                                   .byte "INX"             ;1A
>ebec  49 4e 59                                   .byte "INY"             ;1B
>ebef  4a 4d 50                                   .byte "JMP"             ;1C
>ebf2  4a 53 52                                   .byte "JSR"             ;1D
>ebf5  4c 44 41                                   .byte "LDA"             ;1E
>ebf8  4c 44 58                                   .byte "LDX"             ;1F
>ebfb  4c 44 59                                   .byte "LDY"             ;20
>ebfe  4c 53 52                                   .byte "LSR"             ;21
>ec01  4e 4f 50                                   .byte "NOP"             ;22
>ec04  4f 52 41                                   .byte "ORA"             ;23
>ec07  50 48 41                                   .byte "PHA"             ;24
>ec0a  50 48 50                                   .byte "PHP"             ;25
>ec0d  50 48 58                                   .byte "PHX"             ;26
>ec10  50 48 59                                   .byte "PHY"             ;27
>ec13  50 4c 41                                   .byte "PLA"             ;28
>ec16  50 4c 50                                   .byte "PLP"             ;29
>ec19  50 4c 58                                   .byte "PLX"             ;2A
>ec1c  50 4c 59                                   .byte "PLY"             ;2B
>ec1f  52 4f 4c                                   .byte "ROL"             ;2C
>ec22  52 4f 52                                   .byte "ROR"             ;2D
>ec25  52 54 49                                   .byte "RTI"             ;2E
>ec28  52 54 53                                   .byte "RTS"             ;2F
>ec2b  53 42 43                                   .byte "SBC"             ;30
>ec2e  53 45 43                                   .byte "SEC"             ;31
>ec31  53 45 44                                   .byte "SED"             ;32
>ec34  53 45 49                                   .byte "SEI"             ;33
>ec37  53 54 41                                   .byte "STA"             ;34
>ec3a  53 54 58                                   .byte "STX"             ;35
>ec3d  53 54 59                                   .byte "STY"             ;36
>ec40  53 54 5a                                   .byte "STZ"             ;37
>ec43  54 41 58                                   .byte "TAX"             ;38
>ec46  54 41 59                                   .byte "TAY"             ;39
>ec49  54 52 42                                   .byte "TRB"             ;3A
>ec4c  54 53 42                                   .byte "TSB"             ;3B
>ec4f  54 53 58                                   .byte "TSX"             ;3C
>ec52  54 58 41                                   .byte "TXA"             ;3D
>ec55  54 58 53                                   .byte "TXS"             ;3E
>ec58  54 59 41                                   .byte "TYA"             ;3F
>ec5b  57 41 49                                   .byte "WAI"             ;40
>ec5e  53 54 50                                   .byte "STP"             ;41
>ec61  42 42 52                                   .byte "BBR"             ;42 4Byte Opcodes
>ec64  42 42 53                                   .byte "BBS"             ;43
>ec67  52 4d 42                                   .byte "RMB"             ;44
>ec6a  53 4d 42                                   .byte "SMB"             ;45
>ec6d  2e 44 42                                   .byte ".DB"             ;46 define 1 byte for assembler
>ec70  2e 44 57                                   .byte ".DW"             ;47 define 1 word for assembler
>ec73  2e 44 53                                   .byte ".DS"             ;48 define a string block for assembler
>ec76  3f 3f 3f                                   .byte "???"             ;49 for invalid opcode
>ec79  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  HelpTxt        .byte "~Current commands are :~"
>ec91  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 2c 20 48 48 48 48 20 68 65 78 20 61 64 64 72 65 73 73 2c 20 44 44 20 68 65 78 20 64 61 74 61 7e                 .byte "Syntax = {} required, [] optional, HHHH hex address, DD hex data~"
>ecd2  7e                                         .byte "~"
>ecd3  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 28 75 70 20 74 6f 20 31 36 20 69 66 20 6e 6f 20 61 64 64 72 65 73 73 20 65 6e 74 65 72 65 64 29 7e                 .byte "[HHHH][ HHHH]{Return} - Hex dump address(s)(up to 16 if no address entered)~"
>ed1f  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Return} - Hex dump range of addresses (16 per line)~"
>ed61  5b 48 48 48 48 5d 7b 3a 44 44 7d 5b 20 44 44 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 68 61 6e 67 65 20 64 61 74 61 20 62 79 74 65 73 7e                 .byte "[HHHH]{:DD}[ DD]{Return} - Change data bytes~"
>ed8e  5b 48 48 48 48 5d 7b 47 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 65 63 75 74 65 20 61 20 70 72 6f 67 72 61 6d 20 28 75 73 65 20 52 54 53 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20 6d 6f 6e 69 74 6f 72 29 7e                 .byte "[HHHH]{G}{Return} - Execute a program (use RTS to return to monitor)~"
>edd3  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 49 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 6d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 32 6e 64 20 48 48 48 48 20 64 6f 77 6e 20 74 6f 20 31 73 74 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{I}{Return} - move range at 2nd HHHH down to 1st to 3rd HHHH~"
>ee1f  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>ee5a  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 44 69 73 73 61 73 73 65 6d 62 6c 65 20 61 20 72 61 6e 67 65 7e                 .byte "[HHHH]{.HHHH}{L}{Return} - Dissassemble a range~"
>ee8a  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 4d 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 31 73 74 20 48 48 48 48 20 74 68 72 75 20 32 6e 64 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{M}{Return} - Move range at 1st HHHH thru 2nd to 3rd HHHH~"
>eed3  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 7e                 .byte "[HHHH][ HHHH]{Q}{Return} - Text dump address(s)~"
>ef03  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Q}{Return} - Text dump range of addresses (16 per line)~"
>ef49  7b 52 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 72 65 67 69 73 74 65 72 20 63 6f 6e 74 65 6e 74 73 20 66 72 6f 6d 20 6d 65 6d 6f 72 79 20 6c 6f 63 61 74 69 6f 6e 73 7e                 .byte "{R}{Return} - Print register contents from memory locations~"
>ef85  7b 55 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 55 70 6c 6f 61 64 20 46 69 6c 65 20 28 58 6d 6f 64 65 6d 2f 43 52 43 20 6f 72 20 49 6e 74 65 6c 20 48 65 78 29 7e                 .byte "{U}{Return} - Upload File (Xmodem/CRC or Intel Hex)~"
>efb9  7b 56 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 6e 69 74 6f 72 20 56 65 72 73 69 6f 6e 7e                 .byte "{V}{Return} - Monitor Version~"
>efd7  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 57 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 72 69 74 65 20 64 61 74 61 20 69 6e 20 52 41 4d 20 74 6f 20 45 45 50 52 4f 4d 7e                 .byte "{HHHH.HHHH>HHHH{W}{Return} - Write data in RAM to EEPROM~"
>f010  7b 21 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 6e 74 65 72 20 41 73 73 65 6d 62 6c 65 72 7e                 .byte "{!}{Return} - Enter Assembler~"
>f02e  7b 40 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 6f 6c 64 2d 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{@}{Return} - Cold-Start Enhanced Basic~"
>f056  7b 23 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 61 72 6d 5f 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{#}{Return} - Warm_Start Enhanced Basic~"
>f07e  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f0a4  00                                         .byte $00
>f0a5  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  AsmHelpTxt     .byte "~Current commands are :~"
>f0bd  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 7e                 .byte "Syntax = {} required, [] optional~"
>f0df  48 48 48 48 3d 68 65 78 20 61 64 64 72 65 73 73 2c 20 4f 50 43 3d 4f 70 63 6f 64 65 2c 20 44 44 3d 68 65 78 20 64 61 74 61 2c 20 27 5f 27 3d 53 70 61 63 65 20 42 61 72 20 6f 72 20 54 61 62 7e                 .byte "HHHH=hex address, OPC=Opcode, DD=hex data, '_'=Space Bar or Tab~"
>f11f  27 24 27 20 53 79 6d 62 6f 6c 73 20 61 72 65 20 6f 70 74 69 6f 6e 61 6c 2c 20 61 6c 6c 20 76 61 6c 75 65 73 20 61 72 65 20 48 45 58 2e 7e                 .byte "'$' Symbols are optional, all values are HEX.~"
>f14d  41 6e 79 20 69 6e 70 75 74 20 61 66 74 65 72 20 61 20 27 73 65 6d 69 2d 63 6f 6c 6f 6e 27 20 69 73 20 69 67 6e 6f 72 65 64 2e 7e                 .byte "Any input after a 'semi-colon' is ignored.~"
>f178  7e                                         .byte "~"
>f179  7b 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 53 65 74 20 69 6e 70 75 74 20 61 64 64 72 65 73 73 7e                 .byte "{HHHH}{Return} - Set input address~"
>f19c  5b 48 48 48 48 5d 5b 5f 5d 7b 4f 50 43 7d 5b 5f 5d 5b 23 28 24 44 44 5f 48 48 48 48 2c 58 29 2c 59 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 41 73 73 65 6d 62 6c 65 20 6c 69 6e 65 7e                 .byte "[HHHH][_]{OPC}[_][#($DD_HHHH,X),Y]{Return} - Assemble line~"
>f1d7  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>f212  7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 69 74 20 41 73 73 65 6d 62 6c 65 72 20 62 61 63 6b 20 74 6f 20 4d 6f 6e 69 74 6f 72 7e                 .byte "{Return} - Exit Assembler back to Monitor~"
>f23c  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f262  00                                         .byte $00
>f263  36 35 43 30 32 20 4d 6f 6e 69 74 6f 72 20 76 35 2e 31 20 28 35 2d 33 30 2d 30 35 29 20 52 65 61 64 79  Porttxt        .byte "65C02 Monitor v5.1 (5-30-05) Ready"
>f285  0d 0a                                      .byte  $0d, $0a
>f287  77 69 74 68 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 20 49 6e 74 65 72 70 72 65 74 65 72 20 28 63 29 20 4c 65 65 20 44 61 76 69 73 6f 6e                 .byte "with Enhanced Basic Interpreter (c) Lee Davison" 
>f2b6  0d 0a                                      .byte  $0d, $0a
>f2b8  28 50 72 65 73 73 20 3f 20 66 6f 72 20 68 65 6c 70 29                 .byte "(Press ? for help)"
>f2ca  00                                         .byte $00
.f2cb                              crclo
>f2cb  00 21 42 63 84 a5 c6 e7 08 29 4a 6b 8c ad ce ef   .byte $00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
>f2db  31 10 73 52 b5 94 f7 d6 39 18 7b 5a bd 9c ff de   .byte $31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
>f2eb  62 43 20 01 e6 c7 a4 85 6a 4b 28 09 ee cf ac 8d   .byte $62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
>f2fb  53 72 11 30 d7 f6 95 b4 5b 7a 19 38 df fe 9d bc   .byte $53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
>f30b  c4 e5 86 a7 40 61 02 23 cc ed 8e af 48 69 0a 2b   .byte $C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
>f31b  f5 d4 b7 96 71 50 33 12 fd dc bf 9e 79 58 3b 1a   .byte $F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
>f32b  a6 87 e4 c5 22 03 60 41 ae 8f ec cd 2a 0b 68 49   .byte $A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
>f33b  97 b6 d5 f4 13 32 51 70 9f be dd fc 1b 3a 59 78   .byte $97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
>f34b  88 a9 ca eb 0c 2d 4e 6f 80 a1 c2 e3 04 25 46 67   .byte $88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
>f35b  b9 98 fb da 3d 1c 7f 5e b1 90 f3 d2 35 14 77 56   .byte $B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
>f36b  ea cb a8 89 6e 4f 2c 0d e2 c3 a0 81 66 47 24 05   .byte $EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
>f37b  db fa 99 b8 5f 7e 1d 3c d3 f2 91 b0 57 76 15 34   .byte $DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
>f38b  4c 6d 0e 2f c8 e9 8a ab 44 65 06 27 c0 e1 82 a3   .byte $4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
>f39b  7d 5c 3f 1e f9 d8 bb 9a 75 54 37 16 f1 d0 b3 92   .byte $7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
>f3ab  2e 0f 6c 4d aa 8b e8 c9 26 07 64 45 a2 83 e0 c1   .byte $2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
>f3bb  1f 3e 5d 7c 9b ba d9 f8 17 36 55 74 93 b2 d1 f0   .byte $1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0 
.f3cb                              crchi
>f3cb  00 10 20 30 40 50 60 70 81 91 a1 b1 c1 d1 e1 f1   .byte $00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
>f3db  12 02 32 22 52 42 72 62 93 83 b3 a3 d3 c3 f3 e3   .byte $12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
>f3eb  24 34 04 14 64 74 44 54 a5 b5 85 95 e5 f5 c5 d5   .byte $24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
>f3fb  36 26 16 06 76 66 56 46 b7 a7 97 87 f7 e7 d7 c7   .byte $36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
>f40b  48 58 68 78 08 18 28 38 c9 d9 e9 f9 89 99 a9 b9   .byte $48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
>f41b  5a 4a 7a 6a 1a 0a 3a 2a db cb fb eb 9b 8b bb ab   .byte $5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
>f42b  6c 7c 4c 5c 2c 3c 0c 1c ed fd cd dd ad bd 8d 9d   .byte $6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
>f43b  7e 6e 5e 4e 3e 2e 1e 0e ff ef df cf bf af 9f 8f   .byte $7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
>f44b  91 81 b1 a1 d1 c1 f1 e1 10 00 30 20 50 40 70 60   .byte $91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
>f45b  83 93 a3 b3 c3 d3 e3 f3 02 12 22 32 42 52 62 72   .byte $83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
>f46b  b5 a5 95 85 f5 e5 d5 c5 34 24 14 04 74 64 54 44   .byte $B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
>f47b  a7 b7 87 97 e7 f7 c7 d7 26 36 06 16 66 76 46 56   .byte $A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
>f48b  d9 c9 f9 e9 99 89 b9 a9 58 48 78 68 18 08 38 28   .byte $D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
>f49b  cb db eb fb 8b 9b ab bb 4a 5a 6a 7a 0a 1a 2a 3a   .byte $CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
>f4ab  fd ed dd cd bd ad 9d 8d 7c 6c 5c 4c 3c 2c 1c 0c   .byte $FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
>f4bb  ef ff cf df af bf 8f 9f 6e 7e 4e 5e 2e 3e 0e 1e   .byte $EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E 

.f4cb  20 c7 f5   jsr $f5c7        XModem		jsr   	prtMsg		; send prompt and info
.f4ce  a9 01      lda #$01         		lda   	#$01
.f4d0  85 3c      sta $3c          		sta	blkno		; set block # to 1
.f4d2  85 3f      sta $3f          		sta	bflag		; set flag to get address from block 1
.f4d4  a9 43      lda #$43         StartCrc	lda	#"C"		; "C" start with CRC mode
.f4d6  20 06 e2   jsr $e206        		jsr	output		; send it
.f4d9  a9 ff      lda #$ff         		lda	#$FF	
.f4db  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.f4dd  a9 00      lda #$00         		lda   	#$00
.f4df  85 38      sta $38                          sta	crc
.f4e1  85 39      sta $39          		sta	crch		; init CRC value	
.f4e3  20 b4 f5   jsr $f5b4        		jsr	GetByte		; wait for input
.f4e6  b0 11      bcs $f4f9                        bcs     GotByte         ; byte received, process it
.f4e8  90 ea      bcc $f4d4        		bcc	StartCrc	; resend "C"
.f4ea  a9 ff      lda #$ff         StartBlk	lda	#$FF		; 
.f4ec  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.f4ee  a9 00      lda #$00         		lda   	#$00		;
.f4f0  85 38      sta $38          		sta	crc		;
.f4f2  85 39      sta $39          		sta	crch		; init CRC value	
.f4f4  20 b4 f5   jsr $f5b4        		jsr	GetByte		; get first byte of block
.f4f7  90 f1      bcc $f4ea        		bcc	StartBlk	; timed out, keep waiting...
.f4f9  c9 1b      cmp #$1b         GotByte         cmp     #ESC            ; quitting?
.f4fb  d0 01      bne $f4fe                        bne     GotByte3
.f4fd  00         brk                              brk
.f4fe  c9 01      cmp #$01         GotByte3        cmp     #SOH            ; start of block?
.f500  f0 0e      beq $f510        		beq	BegBlk		; yes
.f502  c9 3a      cmp #$3a         		cmp	#":"		; Intel-Hex format - jump to its handler below
.f504  d0 03      bne $f509        		bne	GotByte1	; 
.f506  4c 25 f6   jmp $f625        		jmp	HexUpLd		; 
.f509  c9 04      cmp #$04         GotByte1	cmp	#EOT		;
.f50b  d0 59      bne $f566        		bne	BadCrc		; Not SOH, ":", EOT, so flush buffer & send NAK	
.f50d  4c a7 f5   jmp $f5a7        		jmp	Done		; EOT - all done!
.f510  a2 00      ldx #$00         BegBlk		ldx	#$00
.f512  a9 ff      lda #$ff         GetBlk		lda	#$ff		; 3 sec window to receive characters
.f514  85 3e      sta $3e          		sta 	retry2		;
.f516  20 b4 f5   jsr $f5b4        GetBlk1		jsr	GetByte		; get next character
.f519  90 4b      bcc $f566        		bcc	BadCrc		; chr rcv error, flush and send NAK
.f51b  9d 00 03   sta $0300,x      GetBlk2		sta	Rbuff,x		; good char, save it in the rcv buffer
.f51e  e8         inx              		inx			; inc buffer pointer	
.f51f  e0 84      cpx #$84         		cpx	#$84		; <01> <FE> <128 bytes> <CRCH> <CRCL>
.f521  d0 ef      bne $f512        		bne	GetBlk		; get 132 characters
.f523  a2 00      ldx #$00         		ldx	#$00		;
.f525  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get block # from buffer
.f528  c5 3c      cmp $3c          		cmp	blkno		; compare to expected block #	
.f52a  f0 0b      beq $f537        		beq	GoodBlk1	; matched!
.f52c  a9 f7      lda #$f7         		lda	#>MsgCrcBadBlkno
.f52e  a2 10      ldx #$10         		ldx	#<MsgCrcBadBlkno
.f530  20 fb f6   jsr $f6fb        		jsr	PrintStrAX	; Unexpected block number - abort	
.f533  20 0b f6   jsr $f60b        		jsr	Flush		; mismatched - flush buffer and then do BRK
.f536  00         brk              		brk			; unexpected block # - fatal error
.f537  49 ff      eor #$ff         GoodBlk1	eor	#$ff		; 1's comp of block #
.f539  e8         inx              		inx			;
.f53a  dd 00 03   cmp $0300,x      		cmp	Rbuff,x		; compare with expected 1's comp of block #
.f53d  f0 0b      beq $f54a        		beq	GoodBlk2 	; matched!
.f53f  a9 f7      lda #$f7         		lda	#>MsgCrcBadBlkno
.f541  a2 10      ldx #$10         		ldx	#<MsgCrcBadBlkno
.f543  20 fb f6   jsr $f6fb        		jsr	PrintStrAX	; Unexpected block number - abort	
.f546  20 0b f6   jsr $f60b        		jsr 	Flush		; mismatched - flush buffer and then do BRK
.f549  00         brk              		brk			; bad 1's comp of block#	
.f54a  a0 02      ldy #$02         GoodBlk2	ldy	#$02		; 
.f54c  b9 00 03   lda $0300,y      CalcCrc		lda	Rbuff,y		; calculate the CRC for the 128 bytes of data	
.f54f  20 15 f6   jsr $f615        		jsr	UpdCrc		; could inline sub here for speed
.f552  c8         iny              		iny			;
.f553  c0 82      cpy #$82         		cpy	#$82		; 128 bytes
.f555  d0 f5      bne $f54c        		bne	CalcCrc		;
.f557  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get hi CRC from buffer
.f55a  c5 39      cmp $39          		cmp	crch		; compare to calculated hi CRC
.f55c  d0 08      bne $f566        		bne	BadCrc		; bad crc, send NAK
.f55e  c8         iny              		iny			;
.f55f  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get lo CRC from buffer
.f562  c5 38      cmp $38          		cmp	crc		; compare to calculated lo CRC
.f564  f0 0b      beq $f571        		beq	GoodCrc		; good CRC
.f566  20 0b f6   jsr $f60b        BadCrc		jsr	Flush		; flush the input port
.f569  a9 15      lda #$15         		lda	#NAK		;
.f56b  20 06 e2   jsr $e206        		jsr	output		; send NAK to resend block
.f56e  4c ea f4   jmp $f4ea        		jmp	StartBlk	; start over, get the block again			
.f571  a2 02      ldx #$02         GoodCrc		ldx	#$02		;
.f573  a5 3c      lda $3c          		lda	blkno		; get the block number
.f575  c9 01      cmp #$01         		cmp	#$01		; 1st block?
.f577  d0 12      bne $f58b        		bne	CopyBlk		; no, copy all 128 bytes
.f579  a5 3f      lda $3f          		lda	bflag		; is it really block 1, not block 257, 513 etc.
.f57b  f0 0e      beq $f58b        		beq	CopyBlk		; no, copy all 128 bytes
.f57d  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get target address from 1st 2 bytes of blk 1
.f580  85 3a      sta $3a          		sta	ptr		; save lo address
.f582  e8         inx              		inx			;
.f583  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get hi address
.f586  85 3b      sta $3b          		sta	ptr+1		; save it
.f588  e8         inx              		inx			; point to first byte of data
.f589  c6 3f      dec $3f          		dec	bflag		; set the flag so we won't get another address		
.f58b  a0 00      ldy #$00         CopyBlk		ldy	#$00		; set offset to zero
.f58d  bd 00 03   lda $0300,x      CopyBlk3	lda	Rbuff,x		; get data byte from buffer
.f590  91 3a      sta ($3a),y      		sta	(ptr),y		; save to target
.f592  e6 3a      inc $3a          		inc	ptr		; point to next address
.f594  d0 02      bne $f598        		bne	CopyBlk4	; did it step over page boundry?
.f596  e6 3b      inc $3b          		inc	ptr+1		; adjust high address for page crossing
.f598  e8         inx              CopyBlk4	inx			; point to next data byte
.f599  e0 82      cpx #$82         		cpx	#$82		; is it the last byte
.f59b  d0 f0      bne $f58d        		bne	CopyBlk3	; no, get the next one
.f59d  e6 3c      inc $3c          IncBlk		inc	blkno		; done.  Inc the block #
.f59f  a9 06      lda #$06         		lda	#ACK		; send ACK
.f5a1  20 06 e2   jsr $e206        		jsr	output
.f5a4  4c ea f4   jmp $f4ea        		jmp	StartBlk	; get next block
.f5a7  a9 06      lda #$06         Done		lda	#ACK		; last block, send ACK and exit.
.f5a9  20 06 e2   jsr $e206        		jsr	output
.f5ac  a9 f7      lda #$f7         		lda	#>MsgCrcDone
.f5ae  a2 40      ldx #$40         		ldx	#<MsgCrcDone
.f5b0  20 fb f6   jsr $f6fb        		jsr	PrintStrAX	;
.f5b3  60         rts              		rts			;
.f5b4  a9 00      lda #$00         GetByte		lda	#$00		; wait for chr input and cycle timing loop
.f5b6  85 3d      sta $3d          		sta	retry		; set low value of timing loop
.f5b8  20 03 e2   jsr $e203        StartCrcLp	jsr	Scan_Input	; get chr from serial port, don't wait 
.f5bb  b0 09      bcs $f5c6        		bcs	GetByte1	; got one, so exit
.f5bd  c6 3d      dec $3d          		dec   	retry		; no character received, so dec counter
.f5bf  d0 f7      bne $f5b8        		bne	StartCrcLp	;
.f5c1  c6 3e      dec $3e          		dec	retry2		; dec hi byte of counter
.f5c3  d0 f3      bne $f5b8        		bne	StartCrcLp	; look for character again
.f5c5  18         clc              		clc			; if loop times out, CLC, else SEC and return
.f5c6  60         rts              GetByte1	rts			; with character in "A"
.f5c7  a2 00      ldx #$00         PrtMsg		ldx	#$00		; PRINT starting message
.f5c9  bd d6 f5   lda $f5d6,x      PrtMsg1		lda   	Msg,x
.f5cc  f0 07      beq $f5d5        		beq	PrtMsg2
.f5ce  20 06 e2   jsr $e206        		jsr   	output
.f5d1  e8         inx              		inx
.f5d2  4c c9 f5   jmp $f5c9                        jmp     PrtMsg1
.f5d5  60         rts              PrtMsg2		rts

>f5d6  42 65 67 69 6e 20 58 4d 4f 44 45 4d 2f 43 52 43 20 74 72 61 6e 73 66 65 72 2e  Msg             .byte   "Begin XMODEM/CRC transfer."
>f5f0  0d 0a                                       .byte   CR,LF
>f5f2  50 72 65 73 73 20 3c 45 73 63 3e 20 74 6f 20 61 62 6f 72 74 2e 2e 2e 20                  .byte   "Press <Esc> to abort... "
>f60a  00                                          .byte   0

.f60b  a9 70      lda #$70         Flush		lda	#$70		; flush receive buffer
.f60d  85 3e      sta $3e          		sta	retry2		; flush until empty for ~1 sec.
.f60f  20 b4 f5   jsr $f5b4        Flush1		jsr	GetByte		; read the port
.f612  b0 f7      bcs $f60b        		bcs	Flush
.f614  60         rts              		rts	
.f615  45 39      eor $39          UpdCrc		eor 	crc+1 		; Quick CRC computation with lookup tables
.f617  aa         tax                       	tax		 
.f618  a5 38      lda $38                   	lda 	crc
.f61a  5d cb f3   eor $f3cb,x               	eor 	CRCHI,X
.f61d  85 39      sta $39                   	sta 	crc+1
.f61f  bd cb f2   lda $f2cb,x               	lda 	CRCLO,X
.f622  85 38      sta $38                   	sta 	crc
.f624  60         rts                       	rts
.f625  a9 0d      lda #$0d         HexUpLd 	lda     #CR
.f627  20 06 e2   jsr $e206        		jsr	output
.f62a  a9 0a      lda #$0a         		lda	#LF
.f62c  20 06 e2   jsr $e206        		jsr	output
.f62f  a9 00      lda #$00         		lda    	#0
.f631  85 3e      sta $3e                  	sta	dlfail          ;Start by assuming no D/L failure
.f633  f0 07      beq $f63c        	  	beq	IHex		
.f635  20 d5 f6   jsr $f6d5        HdwRecs 	jsr     GetSer          ; Wait for start of record mark ':'
.f638  c9 3a      cmp #$3a                 	cmp     #":"
.f63a  d0 f9      bne $f635                	bne     HdwRecs         ; not found yet
.f63c  20 de f6   jsr $f6de        IHex    	jsr     GetHex          ; Get the record length
.f63f  85 39      sta $39                  	sta     reclen          ; save it
.f641  85 38      sta $38                 	 	sta     chksum          ; and save first byte of checksum
.f643  20 de f6   jsr $f6de                	jsr     GetHex          ; Get the high part of start address
.f646  85 3c      sta $3c                  	sta     start_hi
.f648  18         clc                      	clc
.f649  65 38      adc $38                  	adc     chksum          ; Add in the checksum       
.f64b  85 38      sta $38                  	sta     chksum          ; 
.f64d  20 de f6   jsr $f6de                	jsr     GetHex          ; Get the low part of the start address
.f650  85 3b      sta $3b                  	sta     start_lo
.f652  18         clc                      	clc
.f653  65 38      adc $38                  	adc     chksum
.f655  85 38      sta $38                  	sta     chksum  
.f657  20 de f6   jsr $f6de                	jsr     GetHex          ; Get the record type
.f65a  85 3d      sta $3d                  	sta     rectype         ; & save it
.f65c  18         clc                      	clc
.f65d  65 38      adc $38                  	adc     chksum
.f65f  85 38      sta $38                  	sta     chksum   
.f661  a5 3d      lda $3d                  	lda     rectype
.f663  d0 2c      bne $f691                	bne     HdEr1           ; end-of-record
.f665  a6 39      ldx $39                  	ldx     reclen          ; number of data bytes to write to memory
.f667  a0 00      ldy #$00                 	ldy     #0              ; start offset at 0
.f669  20 de f6   jsr $f6de        HdLp1   	jsr     GetHex          ; Get the first/next/last data byte
.f66c  91 3b      sta ($3b),y              	sta     (start_lo),y    ; Save it to RAM
.f66e  18         clc                      	clc
.f66f  65 38      adc $38                  	adc     chksum
.f671  85 38      sta $38                  	sta     chksum          ; 
.f673  c8         iny                      	iny                     ; update data pointer
.f674  ca         dex                      	dex                     ; decrement count
.f675  d0 f2      bne $f669                	bne     HdLp1
.f677  20 de f6   jsr $f6de                	jsr     GetHex          ; get the checksum
.f67a  18         clc                      	clc
.f67b  65 38      adc $38                  	adc     chksum
.f67d  d0 08      bne $f687                	bne     HdDlF1          ; If failed, report it
.f67f  a9 23      lda #$23                 	lda     #"#"            ; Character indicating record OK = '#'
.f681  8d 09 c0   sta $c009                	sta	ACIA0dat        ; write it out but don't wait for output 
.f684  4c 35 f6   jmp $f635                	jmp     HdwRecs         ; get next record     
.f687  a9 46      lda #$46         HdDlF1  	lda     #"F"            ; Character indicating record failure = 'F'
.f689  85 3e      sta $3e                  	sta     dlfail          ; upload failed if non-zero
.f68b  8d 09 c0   sta $c009                	sta	ACIA0dat        ; write it to transmit buffer register
.f68e  4c 35 f6   jmp $f635                	jmp     HdwRecs         ; wait for next record start
.f691  c9 01      cmp #$01         HdEr1   	cmp     #1              ; Check for end-of-record type
.f693  f0 1b      beq $f6b0                	beq     HdEr2
.f695  a9 f7      lda #$f7         		lda	#>MsgUnknownRecType
.f697  a2 62      ldx #$62         		ldx	#<MsgUnknownRecType
.f699  20 fb f6   jsr $f6fb                        jsr     PrintStrAX      ; Warn user of unknown record type
.f69c  a5 3d      lda $3d          		lda     rectype         ; Get it
.f69e  85 3e      sta $3e                  	sta     dlfail          ; non-zero --> upload has failed
.f6a0  20 6b e1   jsr $e16b                	jsr     Print1Byte      ; print it
.f6a3  a9 0d      lda #$0d         		lda     #CR		; but we'll let it finish so as not to 
.f6a5  20 06 e2   jsr $e206                	jsr     output		; falsely start a new d/l from existing 
.f6a8  a9 0a      lda #$0a                 	lda     #LF		; file that may still be coming in for 
.f6aa  20 06 e2   jsr $e206                	jsr     output          ; quite some time yet.
.f6ad  4c 35 f6   jmp $f635        		jmp	HdwRecs
.f6b0  20 de f6   jsr $f6de        HdEr2   	jsr     GetHex          ; get the checksum 
.f6b3  18         clc                      	clc
.f6b4  65 38      adc $38                  	adc     chksum          ; Add previous checksum accumulator value
.f6b6  f0 07      beq $f6bf                	beq     HdEr3           ; checksum = 0 means we're OK!
.f6b8  a9 f7      lda #$f7         		lda	#>MsgBadRecChksum
.f6ba  a2 7c      ldx #$7c         		ldx	#<MsgBadRecChksum
.f6bc  4c fb f6   jmp $f6fb                        jmp     PrintStrAX
.f6bf  a5 3e      lda $3e          HdEr3   	lda     dlfail
.f6c1  f0 07      beq $f6ca                	beq     HdErOK
.f6c3  a9 f7      lda #$f7         		lda	#>MsgUploadFail
.f6c5  a2 95      ldx #$95         		ldx	#<MsgUploadFail
.f6c7  4c fb f6   jmp $f6fb                        jmp     PrintStrAX
.f6ca  a9 f7      lda #$f7         HdErOK  	lda	#>MsgUploadOK
.f6cc  a2 b2      ldx #$b2         		ldx	#<MsgUploadOK
.f6ce  20 fb f6   jsr $f6fb                        jsr     PrintStrAX
.f6d1  20 0b f6   jsr $f60b        	  	jsr     Flush		; flush the input buffer
.f6d4  60         rts              HdErNX  	rts
.f6d5  20 03 e2   jsr $e203        GetSer  	jsr	scan_input	; get input from Serial Port	    
.f6d8  c9 1b      cmp #$1b                         cmp     #ESC            ; check for abort 
.f6da  d0 01      bne $f6dd                	bne     GSerXit         ; return character if not
.f6dc  00         brk                              brk
.f6dd  60         rts              GSerXit 	rts
.f6de  a9 00      lda #$00         GetHex  	lda     #$00
.f6e0  85 3f      sta $3f          	  	sta     temp
.f6e2  20 eb f6   jsr $f6eb                	jsr     GetNibl
.f6e5  0a         asl                      	asl     a
.f6e6  0a         asl                      	asl     a
.f6e7  0a         asl                      	asl     a
.f6e8  0a         asl                     	 	asl     a       	; This is the upper nibble
.f6e9  85 3f      sta $3f                  	sta     temp
.f6eb  20 d5 f6   jsr $f6d5        GetNibl 	jsr     GetSer
.f6ee  c9 3a      cmp #$3a         	        cmp     #"9"+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.f6f0  90 02      bcc $f6f4               	 	bcc     MkNnh   	; If we borrowed, we lost the carry so 0..9
.f6f2  e9 08      sbc #$08                 	sbc     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.f6f4  e9 2f      sbc #$2f         MkNnh   	sbc     #"0"-1  	; subtract off '0' (if carry clear coming in)
.f6f6  29 0f      and #$0f                 	and     #$0F    	; no upper nibble no matter what
.f6f8  05 3f      ora $3f                  	ora     temp
.f6fa  60         rts                      	rts             	; return with the nibble received
.f6fb  85 41      sta $41          PrintStrAX      sta     strptr+1
.f6fd  86 40      stx $40          		stx	strptr
.f6ff  98         tya              		tya
.f700  48         pha              		pha
.f701  a0 00      ldy #$00         		ldy	#0
.f703  b1 40      lda ($40),y      PrintStrAXL1    lda     (strptr),y
.f705  f0 06      beq $f70d                        beq     PrintStrAXX1      ; quit if NULL
.f707  20 06 e2   jsr $e206            		jsr	output
.f70a  c8         iny              		iny
.f70b  d0 f6      bne $f703                        bne     PrintStrAXL1      ; quit if > 255
.f70d  68         pla              PrintStrAXX1    pla
.f70e  a8         tay              		tay
.f70f  60         rts              		rts   

>f710  0d 0a 0d 0a                 MsgCrcBadBlkno  .byte	CR,LF,CR,LF
>f714  55 6e 65 78 70 65 63 74 65 64 20 62 6c 6f 63 6b 20 6e 75 6d 62 65 72 20 72 65 63 65 69 76 65 64  		.byte  	"Unexpected block number received"
>f734  20 41 62 6f 72 74 69 6e 67   		.byte	" Aborting"
>f73d  0d 0a                       		.byte 	CR,LF
>f73f  00                          		.byte 	0
>f740  0d 0a                       MsgCrcDone	.byte 	CR,LF
>f742  58 4d 4f 44 45 4d 2d 43 52 43 20 64 6f 77 6e 6c 6f 61 64 20 69 73 20 63 6f 6d 70 6c 65 74 65                  .byte   "XMODEM-CRC download is complete"
>f761  00                          		.byte 	0
.f762                              msgunknownrectype
>f762  0d 0a 0d 0a                 		.byte   CR,LF,CR,LF
>f766  55 6e 6b 6e 6f 77 6e 20 72 65 63 6f 72 64 20 74 79 70 65 20 24        		.byte   "Unknown record type $"
>f77b  00                          		.byte	0		; null-terminate every string
>f77c  0d 0a 0d 0a                 MsgBadRecChksum .byte   CR,LF,CR,LF
>f780  42 61 64 20 72 65 63 6f 72 64 20 63 68 65 63 6b 73 75 6d 21                  .byte   "Bad record checksum!"
>f794  00                                  	.byte   0		; Null-terminate  
>f795  0d 0a 0d 0a                 MsgUploadFail   .byte   CR,LF,CR,LF
>f799  55 70 6c 6f 61 64 20 46 61 69 6c 65 64 0d 0a                  .byte   "Upload Failed",CR,LF
>f7a8  41 62 6f 72 74 69 6e 67 21                  .byte   "Aborting!"
>f7b1  00                                          .byte   0               ; null-terminate every string or crash'n'burn
>f7b2  0d 0a 0d 0a                 MsgUploadOK	.byte   CR,LF,CR,LF
>f7b6  55 70 6c 6f 61 64 20 53 75 63 63 65 73 73 66 75 6c 21                  .byte   "Upload Successful!"
>f7c8  00                                  	.byte   0         	

.ff00  78         sei              Reset          SEI                     ; diable interupts
.ff01  d8         cld                             CLD                     ; clear decimal mode                      
.ff02  a2 ff      ldx #$ff                        LDX   #$FF              ;
.ff04  9a         txs                             TXS                     ; init stack pointer
.ff05  a9 1f      lda #$1f         Zeromem        lda   #$1F              ; top page of RAM
.ff07  85 01      sta $01                         sta   $01               ; 
.ff09  a9 00      lda #$00                        lda   #$00              ; top of page & fill chr
.ff0b  85 00      sta $00                         sta   $00               ;
.ff0d  92 00      sta ($00)        Zeromem1       sta   ($00)             ; loop will fill loc 0 of each page then 
.ff0f  c6 00      dec $00                         dec   $00               ; fill from ff->01 of that page
.ff11  d0 fa      bne $ff0d                       bne   zeromem1          ; then will drop one page and fill loc 0
.ff13  c6 01      dec $01                         dec   $01               ; doing that until page is back to FF
.ff15  10 f6      bpl $ff0d                       bpl   Zeromem1          ;
.ff17  85 01      sta $01                         sta   $01               ; fix last byte from ff to 00
.ff19  ad f8 03   lda $03f8        Set_Vectors    lda   RESvector+1       ; reset vector 
.ff1c  49 a5      eor #$a5                        EOR   #$A5              ; on reset, perform code @ label reset
.ff1e  cd f9 03   cmp $03f9                       CMP   RESvector+2       ; if checksm ok, then jmp ind to address
.ff21  f0 10      beq $ff33                       beq   nextvec1          ; else set up to jmp to monitor
.ff23  a2 d2      ldx #$d2                        LDX   #<Start_OS        ; *** only outside reference in reset routine
.ff25  a9 e0      lda #$e0                        LDA   #>Start_OS        ; *** points to Monitor Boot routine
.ff27  a8         tay                             TAY                     ;
.ff28  49 a5      eor #$a5                        EOR   #$A5              ;
.ff2a  8d f9 03   sta $03f9                       sta   RESvector+2       ;
.ff2d  8c f8 03   sty $03f8                       sty   RESvector+1       ;
.ff30  8e f7 03   stx $03f7                       stx   RESvector         ;
.ff33  ad fe 03   lda $03fe        Nextvec1       lda   NMIvector+1       ; set up NMI vectors if checksum invalid
.ff36  49 a5      eor #$a5                        EOR   #$A5              ;  
.ff38  cd ff 03   cmp $03ff                       CMP   NMIvector+2       ;
.ff3b  f0 10      beq $ff4d                       beq   nextvec2          ;
.ff3d  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff3f  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system NMI applications)
.ff41  a8         tay                             TAY                     ;
.ff42  49 a5      eor #$a5                        EOR   #$A5              ;
.ff44  8d ff 03   sta $03ff                       sta   NMIvector+2       ;
.ff47  8c fe 03   sty $03fe                       sty   NMIvector+1       ;
.ff4a  8e fd 03   stx $03fd                       stx   NMIvector         ;
.ff4d  ad fb 03   lda $03fb        Nextvec2       lda   INTvector+1       ;
.ff50  49 a5      eor #$a5                        EOR   #$A5              ;
.ff52  cd fc 03   cmp $03fc                       CMP   INTvector+2       ;
.ff55  f0 10      beq $ff67                       beq   Nextvec3          ;
.ff57  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff59  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system INT applications)
.ff5b  a8         tay                             TAY                     ;
.ff5c  49 a5      eor #$a5                        EOR   #$A5              ;
.ff5e  8d fc 03   sta $03fc                       sta   INTvector+2       ;
.ff61  8c fb 03   sty $03fb                       sty   INTvector+1       ;
.ff64  8e fa 03   stx $03fa                       stx   INTvector         ;
.ff67  ad f5 03   lda $03f5        Nextvec3       lda   BRKvector+1       ;
.ff6a  49 a5      eor #$a5                        EOR   #$A5              ;
.ff6c  cd f6 03   cmp $03f6                       CMP   BRKvector+2       ;
.ff6f  f0 10      beq $ff81                       beq   Nextvec4          ;
.ff71  a2 17      ldx #$17                        LDX   #<BRKroutine      ; set up to point to my BRK routine
.ff73  a9 e2      lda #$e2                        LDA   #>BRKroutine      ; 
.ff75  a8         tay                             TAY                     ;
.ff76  49 a5      eor #$a5                        EOR   #$A5              ;
.ff78  8d f6 03   sta $03f6                       sta   BRKvector+2       ;
.ff7b  8c f5 03   sty $03f5                       sty   BRKvector+1       ;
.ff7e  8e f4 03   stx $03f4                       stx   BRKvector         ;
.ff81  a9 b1      lda #$b1         Nextvec4       lda   #<ACIA0_Scan
.ff83  8d 05 02   sta $0205                       sta   VEC_IN
.ff86  a9 e0      lda #$e0         		   lda   #>ACIA0_Scan
.ff88  8d 06 02   sta $0206                       sta   VEC_IN+1
.ff8b  a9 c5      lda #$c5         	         lda   #<ACIA0_Output
.ff8d  8d 07 02   sta $0207                       sta   VEC_OUT
.ff90  a9 e0      lda #$e0         		   lda   #>ACIA0_OUTPUT
.ff92  8d 08 02   sta $0208                       sta   VEC_OUT+1
.ff95  a9 2e      lda #$2e         	         lda   #<Psave
.ff97  8d 0b 02   sta $020b                       sta   VEC_SV
.ff9a  a9 b8      lda #$b8         	         lda   #>Psave
.ff9c  8d 0c 02   sta $020c                       sta   VEC_SV+1
.ff9f  a9 57      lda #$57         		   lda   #<pload
.ffa1  8d 09 02   sta $0209                       sta   VEC_LD
.ffa4  a9 b8      lda #$b8         		   lda   #>pload
.ffa6  8d 0a 02   sta $020a                       sta   VEC_LD+1
.ffa9  20 00 e0   jsr $e000        		   jsr   VIA1_init	   ; init the I/O devices
.ffac  20 1d e0   jsr $e01d        		   jsr   VIA2_init	   ; init the I/O devices
.ffaf  20 4e e0   jsr $e04e        		   jsr   ACIA0_init	   ; init the I/O devices
.ffb2  a9 00      lda #$00         Clr_regs       lda   #$00              ; Clear registers
.ffb4  a8         tay                             TAY                     ;
.ffb5  aa         tax                             TAX                     ;
.ffb6  18         clc                             CLC                     ; clear flags
.ffb7  d8         cld                             CLD                     ; clear decimal mode
.ffb8  58         cli                             CLI                     ; Enable interrupt system
.ffb9  6c f7 03   jmp ($03f7)                     JMP  (RESvector)        ; Monitor for cold reset                       
.ffbc  6c fd 03   jmp ($03fd)      NMIjump        jmp  (NMIvector)        ;
.ffbf  40         rti              INTret         RTI                     ; Null Interrupt return
.ffc0  da         phx              Interrupt      PHX                     ;
.ffc1  48         pha                             PHA                     ;
.ffc2  ba         tsx                             TSX                     ; get stack pointer
.ffc3  bd 03 01   lda $0103,x                     LDA   $0103,X           ; load INT-P Reg off stack
.ffc6  29 10      and #$10                        AND   #$10              ; mask BRK
.ffc8  d0 05      bne $ffcf                       BNE   BrkCmd            ; BRK CMD
.ffca  68         pla                             PLA                     ;
.ffcb  fa         plx                             PLX                     ;
.ffcc  6c fa 03   jmp ($03fa)                     jmp   (INTvector)       ; let user routine have it 
.ffcf  68         pla              BrkCmd         pla                     ;
.ffd0  fa         plx                             plx                     ;
.ffd1  6c f4 03   jmp ($03f4)                     jmp   (BRKvector)       ; patch in user BRK routine
.ffd4  60         rts              RRTS           rts                     ; documented RTS instruction

>fffa  bc ff                                      .word  NMIjump
>fffc  00 ff                                      .word  Reset 
>fffe  c0 ff                                      .word  Interrupt

--- end of code ---
